{"/home/travis/build/npmtest/node-npmtest-waterline/test.js":"/* istanbul instrument in package npmtest_waterline */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-waterline/lib.npmtest_waterline.js":"/* istanbul instrument in package npmtest_waterline */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_waterline = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_waterline = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-waterline/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-waterline && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_waterline */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_waterline\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_waterline.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_waterline.rollup.js'] =\n            local.assetsDict['/assets.npmtest_waterline.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_waterline.__dirname +\n                    '/lib.npmtest_waterline.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline.js":"var _ = require('lodash');\nvar async = require('async');\nvar Schema = require('waterline-schema');\nvar Connections = require('./waterline/connections');\nvar CollectionLoader = require('./waterline/collection/loader');\nvar COLLECTION_DEFAULTS = require('./waterline/collection/defaults');\nvar hasOwnProperty = require('./waterline/utils/helpers').object.hasOwnProperty;\n\n/**\n * Waterline\n */\n\nvar Waterline = module.exports = function() {\n\n  if (!(this instanceof Waterline)) {\n    return new Waterline();\n  }\n\n  // Keep track of all the collections internally so we can build associations\n  // between them when needed.\n  this._collections = [];\n\n  // Keep track of all the active connections used by collections\n  this._connections = {};\n\n  return this;\n};\n\n/*\n ***********************************************************\n * Modules that can be extended\n ***********************************************************/\n\n// Collection to be extended in your application\nWaterline.Collection = require('./waterline/collection');\n\n// Model Instance, returned as query results\nWaterline.Model = require('./waterline/model');\n\n/*\n ***********************************************************\n * Prototype Methods\n ***********************************************************/\n\n/**\n * loadCollection\n *\n * Loads a new Collection. It should be an extended Waterline.Collection\n * that contains your attributes, instance methods and class methods.\n *\n * @param {Object} collection\n * @return {Object} internal models dictionary\n * @api public\n */\n\nWaterline.prototype.loadCollection = function(collection) {\n\n  // Cache collection\n  this._collections.push(collection);\n\n  return this._collections;\n};\n\n/**\n * initialize\n *\n * Creates an initialized version of each Collection and auto-migrates depending on\n * the Collection configuration.\n *\n * @param {Object} config object containing adapters\n * @param {Function} callback\n * @return {Array} instantiated collections\n * @api public\n */\n\nWaterline.prototype.initialize = function(options, cb) {\n  var self = this;\n\n  // Ensure a config object is passed in containing adapters\n  if (!options) { throw new Error('Usage Error: function(options, callback)'); }\n  if (!options.adapters) { throw new Error('Options object must contain an adapters object'); }\n  if (!options.connections) { throw new Error('Options object must contain a connections object'); }\n\n  // Check that the given adapter is compatible with Waterline 0.11.x.\n  try {\n    _.each(options.adapters, function(adapter) {\n      // Adapters meant for Waterline >= 0.12 will have an adapterApiVersion property, so if we\n      // see that then we know the adapter won't work with this version of Waterline.\n      if (!_.isUndefined(adapter.adapterApiVersion)) {\n        throw new Error(\n          '\\n-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-\\n'+\n          'Cannot initialize Waterline.\\n'+\n          'The installed version of adapter `' + adapter.identity + '` is too new!\\n' +\n          'Please try installing a version < 1.0.\\n' +\n          '-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-\\n');\n      }\n    });\n  } catch (e) {\n    return cb(e);\n  }\n\n  // Allow collections to be passed in to the initialize method\n  if (options.collections) {\n    for (var collection in options.collections) {\n      this.loadCollection(_.cloneDeep(options.collections[collection]));\n    }\n\n    // Remove collections from the options after they have been loaded\n    delete options.collections;\n  }\n\n  // Cache a reference to instantiated collections\n  this.collections = {};\n\n  // Build up all the connections used by the collections\n  this.connections = new Connections(options.adapters, options.connections);\n\n  // Grab config defaults or set them to empty\n  var defaults = _.merge({}, COLLECTION_DEFAULTS, options.defaults);\n\n  // Build a schema map\n  this.schema = new Schema(this._collections, this.connections, defaults);\n\n  // Load a Collection into memory\n  function loadCollection(item, next) {\n    var loader = new CollectionLoader(item, self.connections, defaults);\n    var collection = loader.initialize(self);\n\n    // Store the instantiated collection so it can be used\n    // internally to create other records\n    self.collections[collection.identity.toLowerCase()] = collection;\n\n    next();\n  }\n\n  async.auto({\n\n    // Load all the collections into memory\n    loadCollections: function(next) {\n      async.each(self._collections, loadCollection, function(err) {\n        if (err) return next(err);\n\n        // Migrate Junction Tables\n        var junctionTables = [];\n\n        Object.keys(self.schema).forEach(function(table) {\n          if (!self.schema[table].junctionTable) return;\n          junctionTables.push(Waterline.Collection.extend(self.schema[table]));\n        });\n\n        async.each(junctionTables, loadCollection, function(err) {\n          if (err) return next(err);\n          next(null, self.collections);\n        });\n      });\n    },\n\n    // Build up Collection Schemas\n    buildCollectionSchemas: ['loadCollections', function(next, results) {\n      var collections = self.collections;\n      var schemas = {};\n\n      Object.keys(collections).forEach(function(key) {\n        var collection = collections[key];\n\n        // Remove hasMany association keys\n        var schema = _.clone(collection._schema.schema);\n\n        Object.keys(schema).forEach(function(key) {\n          if (hasOwnProperty(schema[key], 'type')) return;\n          delete schema[key];\n        });\n\n        // Grab JunctionTable flag\n        var meta = collection.meta || {};\n        meta.junctionTable = hasOwnProperty(collection.waterline.schema[collection.identity], 'junctionTable') ?\n          collection.waterline.schema[collection.identity].junctionTable : false;\n\n        schemas[collection.identity] = collection;\n        schemas[collection.identity].definition = schema;\n        schemas[collection.identity].meta = meta;\n      });\n\n      next(null, schemas);\n    }],\n\n    // Register the Connections with an adapter\n    registerConnections: ['buildCollectionSchemas', function(next, results) {\n      async.each(Object.keys(self.connections), function(item, nextItem) {\n        var connection = self.connections[item];\n        var config = {};\n        var usedSchemas = {};\n\n        // Check if the connection's adapter has a register connection method\n        if (!hasOwnProperty(connection._adapter, 'registerConnection')) return nextItem();\n\n        // Copy all values over to a tempory object minus the adapter definition\n        Object.keys(connection.config).forEach(function(key) {\n          config[key] = connection.config[key];\n        });\n\n        // Set an identity on the connection\n        config.identity = item;\n\n        // Grab the schemas used on this connection\n        connection._collections.forEach(function(coll) {\n          var identity = coll;\n          if (hasOwnProperty(self.collections[coll].__proto__, 'tableName')) {\n            identity = self.collections[coll].__proto__.tableName;\n          }\n\n          usedSchemas[identity] = results.buildCollectionSchemas[coll];\n        });\n\n        // Call the registerConnection method\n        connection._adapter.registerConnection(config, usedSchemas, function(err) {\n          if (err) return nextItem(err);\n          nextItem();\n        });\n      }, next);\n    }]\n\n  }, function(err) {\n    if (err) return cb(err);\n    self.bootstrap(function(err) {\n      if (err) return cb(err);\n      cb(null, { collections: self.collections, connections: self.connections });\n    });\n  });\n\n};\n\n/**\n * Teardown\n *\n * Calls the teardown method on each connection if available.\n */\n\nWaterline.prototype.teardown = function teardown(cb) {\n  var self = this;\n\n  async.each(Object.keys(this.connections), function(item, next) {\n    var connection = self.connections[item];\n\n    // Check if the adapter has a teardown method implemented\n    if (!hasOwnProperty(connection._adapter, 'teardown')) return next();\n\n    connection._adapter.teardown(item, next);\n  }, cb);\n};\n\n/**\n * Bootstrap\n *\n * Auto-migrate all collections\n */\n\nWaterline.prototype.bootstrap = function bootstrap(cb) {\n  var self = this;\n\n  //\n  // TODO:\n  // Come back to this -- see https://github.com/balderdashy/waterline/issues/259\n  // (the stuff in this file works fine-- the work would be structural changes elsewhere)\n  //\n\n  // // Use the shema to get a list of junction tables idents\n  // // and then determine which are \"logical\" collections\n  // // (i.e. everything EXCEPT junction tables)\n  // var junctionTableIdents = _(this.schema).filter({junctionTable: true}).pluck('identity').value();\n  // var logicalCollections = _(this.collections).omit(junctionTableIdents).value();\n\n  // // Flatten logical collections obj into an array for convenience\n  // var toBeSynced = _.reduce(logicalCollections, function(logicals,coll,ident) {\n  //     logicals.push(coll);\n  //     return logicals;\n  //   }, []);\n\n  // // console.log(junctionTableIdents);\n  // // console.log(Object.keys(logicalCollections));\n  // // console.log('\\n',\n  // //   'Migrating collections ::',\n  // //   _(toBeSynced).pluck('identity').value()\n  // // );\n\n  // For now:\n  var toBeSynced = _.reduce(this.collections, function(resources, collection, ident) {\n    resources.push(collection);\n    return resources;\n  }, []);\n\n  // Run auto-migration strategies on each collection\n  // async.each(toBeSynced, function(collection, next) {\n  async.eachSeries(toBeSynced, function(collection, next) {\n  // async.eachLimit(toBeSynced, 9, function(collection, next) {\n    collection.sync(next);\n  }, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-schema/lib/waterline-schema.js":"\n/**\n * Module dependencies\n */\n\nvar Attributes = require('./waterline-schema/attributes');\nvar ForeignKeys = require('./waterline-schema/foreignKeys');\nvar JoinTables = require('./waterline-schema/joinTables');\nvar References = require('./waterline-schema/references');\n\n/**\n * Used to build a Waterline Schema object from a set of\n * loaded collections. It should turn the attributes into an\n * object that can be sent down to an adapter and understood.\n *\n * @param {Array} collections\n * @param {Object} connections\n * @return {Object}\n * @api public\n */\n\nmodule.exports = function(collections, connections, defaults) {\n\n  this.schema = {};\n\n  // Transform Collections into a basic schema\n  this.schema = new Attributes(collections, connections, defaults);\n\n  // Build Out Foreign Keys\n  this.schema = new ForeignKeys(this.schema);\n\n  // Add Join Tables\n  this.schema = new JoinTables(this.schema);\n\n  // Add References for Has Many Keys\n  this.schema = new References(this.schema);\n\n  return this.schema;\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-schema/lib/waterline-schema/attributes.js":"\n/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('./utils');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Expose Attributes\n */\n\nmodule.exports = Attributes;\n\n/**\n * Build an Attributes Definition\n *\n * Takes a collection of attributes from a Waterline Collection\n * and builds up an initial schema by normalizing into a known format.\n *\n * @param {Array} collections\n * @param {Object} connections\n * @return {Object}\n * @api private\n */\n\nfunction Attributes(collections, connections, defaults) {\n  var self = this;\n\n  this.attributes = {};\n\n  // Ensure a value is set for connections\n  connections = connections || {};\n\n  collections.forEach(function (collection) {\n    collection = self.normalize(collection.prototype, connections, defaults);\n    var conns = _.cloneDeep(collection.connection);\n    var attributes = _.cloneDeep(collection.attributes);\n\n    self.stripFunctions(attributes);\n    self.stripProperties(attributes);\n    self.validatePropertyNames(attributes);\n\n    self.attributes[collection.identity.toLowerCase()] = {\n      connection: conns,\n      identity: collection.identity.toLowerCase(),\n      tableName: collection.tableName || collection.identity,\n      migrate: collection.migrate || 'safe',\n      attributes: attributes,\n      meta: collection.meta || {}\n    };\n  });\n\n  return this.attributes;\n\n}\n\n/**\n * Normalize attributes for a collection into a known format.\n *\n * @param {Object} collection\n * @param {Object} connections\n * @return {Object}\n * @api private\n */\n\nAttributes.prototype.normalize = function(collection, connections, defaults) {\n\n  this.normalizeIdentity(collection);\n  this.setDefaults(collection, defaults);\n  this.autoAttributes(collection, connections);\n\n  return collection;\n\n};\n\n/**\n * Set Default Values for the collection.\n *\n * Adds flags to the collection to determine if timestamps and a primary key\n * should be added to the collection's schema.\n *\n * @param {Object} collection\n * @api private\n */\n\nAttributes.prototype.setDefaults = function(collection, defaults) {\n\n  // Ensure defaults is always set to something\n  defaults = defaults || {};\n\n  if(!hop(collection, 'connection')) {\n    collection.connection = '';\n  }\n\n  if(!hop(collection, 'attributes')) {\n    collection.attributes = {};\n  }\n\n  var defaultSettings = {\n    autoPK: true,\n    autoCreatedAt: true,\n    autoUpdatedAt: true,\n    migrate: 'alter'\n  };\n\n  // Override default settings with user defined defaults\n  if(hop(defaults, 'autoPK')) defaultSettings.autoPK = defaults.autoPK;\n  if(hop(defaults, 'autoCreatedAt')) defaultSettings.autoCreatedAt = defaults.autoCreatedAt;\n  if(hop(defaults, 'autoUpdatedAt')) defaultSettings.autoUpdatedAt = defaults.autoUpdatedAt;\n  if(hop(defaults, 'migrate')) defaultSettings.migrate = defaults.migrate;\n\n  // Override defaults with collection defined values\n  if(hop(collection, 'autoPK')) defaultSettings.autoPK = collection.autoPK;\n  if(hop(collection, 'autoCreatedAt')) defaultSettings.autoCreatedAt = collection.autoCreatedAt;\n  if(hop(collection, 'autoUpdatedAt')) defaultSettings.autoUpdatedAt = collection.autoUpdatedAt;\n  if(hop(collection, 'migrate')) defaultSettings.migrate = collection.migrate;\n\n  var flags = {\n    autoPK: defaultSettings.autoPK,\n    autoCreatedAt: defaultSettings.autoCreatedAt,\n    autoUpdatedAt: defaultSettings.autoUpdatedAt,\n    migrate: defaultSettings.migrate\n  };\n\n  // Set the property for the automatic attributes if the user didn't\n  // customize it/disable it.\n  if(flags.autoCreatedAt === true) {\n    flags.autoCreatedAt = 'createdAt';\n  }\n\n  if(flags.autoUpdatedAt === true) {\n    flags.autoUpdatedAt = 'updatedAt';\n  }\n\n  for(var flag in flags) {\n    collection[flag] = flags[flag];\n  }\n\n};\n\n/**\n * Normalize identity\n *\n * @param {Object} collection\n * @api private\n */\n\nAttributes.prototype.normalizeIdentity = function(collection) {\n\n  if(hop(collection, 'tableName') && !hop(collection, 'identity')) {\n    collection.identity = collection.tableName.toLowerCase();\n  }\n\n  // Require an identity so the object key can be set\n  if(!hop(collection, 'identity')) {\n    throw new Error('A Collection must include an identity or tableName attribute');\n  }\n\n};\n\n/**\n * Add Auto Attribute definitions to the schema if they are not defined.\n *\n * Adds in things such as an Id primary key and timestamps unless they have been\n * disabled in the collection.\n *\n * @param {Object} collection\n * @param {Object} connections\n * @api private\n */\n\nAttributes.prototype.autoAttributes = function(collection, connections) {\n\n  var attributes = collection.attributes;\n  var pk = false;\n  var mainConnection;\n\n  // Check to make sure another property hasn't set itself as a primary key\n  for(var key in attributes) {\n    if(hop(attributes[key], 'primaryKey')) pk = true;\n  }\n\n  // If a primary key was manually defined, turn off autoPK\n  if(pk) collection.autoPK = false;\n\n  // Add a primary key attribute\n  if(!pk && collection.autoPK && !attributes.id) {\n    attributes.id = {\n      type: 'integer',\n      autoIncrement: true,\n      primaryKey: true,\n      unique: true\n    };\n\n    // Check if the adapter used in the collection specifies the primary key format\n    if(Array.isArray(collection.connection)) {\n      mainConnection = collection.connection[0];\n    }\n    else {\n      mainConnection = collection.connection;\n    }\n\n    if(hop(connections, mainConnection)) {\n      var connection = connections[mainConnection];\n      if(hop(connection._adapter, 'pkFormat')) {\n        attributes.id.type = connection._adapter.pkFormat;\n      }\n    }\n  }\n\n  // Extend definition with autoUpdatedAt and autoCreatedAt timestamps\n  var now = {\n    type: 'datetime',\n    'default': 'NOW'\n  };\n\n  if(collection.autoCreatedAt && !attributes[collection.autoCreatedAt]) {\n    attributes[collection.autoCreatedAt] = now;\n  }\n\n  if(collection.autoUpdatedAt && !attributes[collection.autoUpdatedAt]) {\n    attributes[collection.autoUpdatedAt] = now;\n  }\n\n};\n\n/**\n * Strip Functions From Schema\n *\n * @param {Object} attributes\n * @api private\n */\n\nAttributes.prototype.stripFunctions = function(attributes) {\n\n  for(var attribute in attributes) {\n    if(typeof attributes[attribute] === 'function') delete attributes[attribute];\n  }\n\n};\n\n/**\n * Strip Non-Reserved Properties\n *\n * @param {Object} attributes\n * @api private\n */\n\nAttributes.prototype.stripProperties = function(attributes) {\n\n  for(var attribute in attributes) {\n    this.stripProperty(attributes[attribute]);\n  }\n\n};\n\n/**\n * Strip Property that isn't in the reserved words list.\n *\n * @param {Object}\n * @api private\n */\n\nAttributes.prototype.stripProperty = function(properties) {\n\n  for(var prop in properties) {\n    if(utils.reservedWords.indexOf(prop) > -1) continue;\n    delete properties[prop];\n  }\n\n};\n\n/**\n * Validates property names to ensure they are valid.\n *\n * @param {Object}\n * @api private\n */\n\nAttributes.prototype.validatePropertyNames = function(attributes) {\n\n  for(var attribute in attributes) {\n\n    // Check for dots in name\n    if(attribute.match(/\\./g)) {\n      var error = 'Invalid Attribute Name: Attributes may not contain a \".\"\" character';\n      throw new Error(error);\n    }\n\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-schema/lib/waterline-schema/utils.js":"\n\n/**\n * Contains a list of reserved words. All others should be stripped from\n * a schema when building.\n */\n\nexports.reservedWords = [\n  'defaultsTo',\n  'primaryKey',\n  'autoIncrement',\n  'unique',\n  'index',\n  'columnName',\n  'foreignKey',\n  'references',\n  'on',\n  'through',\n  'groupKey',\n  'required',\n  'default',\n  'type',\n  'dbType',\n  'collection',\n  'model',\n  'via',\n  'dominant',\n  'migrate'\n];\n\n/**\n * ignore\n */\n\nexports.object = {};\n\n/**\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n * @return {Boolean}\n * @api public\n */\n\nvar hop = Object.prototype.hasOwnProperty;\nexports.object.hasOwnProperty = function(obj, prop) {\n  return hop.call(obj, prop);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-schema/lib/waterline-schema/foreignKeys.js":"\n/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('./utils');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Expose Foreign Keys\n */\n\nmodule.exports = ForeignKeys;\n\n/**\n * Adds Foreign keys to a Collection where needed for belongsTo associations.\n *\n * @param {Object} collections\n * @return {Object}\n * @api private\n */\n\nfunction ForeignKeys(collections) {\n\n  collections = collections || {};\n  this.collections = _.clone(collections);\n\n  for(var collection in collections) {\n    this.replaceKeys(collections[collection].attributes);\n  }\n\n  return collections;\n\n}\n\n/**\n * Replace Model Association with a foreign key attribute\n *\n * @param {Object} attributes\n * @api private\n */\n\nForeignKeys.prototype.replaceKeys = function(attributes) {\n\n  for(var attribute in attributes) {\n\n    // We only care about adding foreign key values to attributes\n    // with a `model` key\n    if(!hop(attributes[attribute], 'model')) continue;\n\n    var modelName = attributes[attribute].model.toLowerCase();\n    var primaryKey = this.findPrimaryKey(modelName);\n    var columnName = this.buildColumnName(attribute, attributes[attribute]);\n    var foreignKey = {\n      columnName: columnName,\n      type: primaryKey.attributes.type,\n      foreignKey: true,\n      references: modelName,\n      on: primaryKey.attributes.columnName || primaryKey.name,\n      onKey: primaryKey.name\n    };\n\n    // Remove the attribute and replace it with the foreign key\n    delete attributes[attribute];\n    attributes[attribute] = foreignKey;\n  }\n\n};\n\n/**\n * Find a collection's primary key attribute\n *\n * @param {String} collection\n * @return {Object}\n * @api private\n */\n\nForeignKeys.prototype.findPrimaryKey = function(collection) {\n\n  if(!this.collections[collection]) {\n    throw new Error('Trying to access a collection ' + collection + ' that is not defined.');\n  }\n\n  if(!this.collections[collection].attributes) {\n    throw new Error('Collection, ' + collection + ', has no attributes defined.');\n  }\n\n  var primaryKey = null;\n\n  for(var key in this.collections[collection].attributes) {\n    var attribute = this.collections[collection].attributes[key];\n\n    if(!hop(attribute, 'primaryKey')) continue;\n\n    primaryKey = {\n      name: key,\n      attributes: attribute\n    };\n  }\n\n  if(!primaryKey) {\n    var error = 'Trying to create an association on a model that doesn\\'t have a Primary Key.';\n    throw new Error(error);\n  }\n\n  return primaryKey;\n\n};\n\n/**\n * Build A Column Name\n *\n * Uses either the attributes defined columnName or the user defined attribute name\n *\n * @param {String} key\n * @param {Object} attribute\n * @param {Object} primaryKey\n * @return {String}\n * @api private\n */\n\nForeignKeys.prototype.buildColumnName = function(key, attribute) {\n\n  if(hop(attribute, 'columnName')) return attribute.columnName;\n  return key;\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-schema/lib/waterline-schema/joinTables.js":"\n/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('./utils');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Expose JoinTables\n */\n\nmodule.exports = JoinTables;\n\n/**\n * Insert Join/Junction Tables where needed whenever two collections\n * point to each other. Also replaces the references to point to the new join table.\n *\n * @param {Object} collections\n * @return {Object}\n * @api private\n */\n\nfunction JoinTables(collections) {\n\n  var self = this;\n  var joinTables;\n\n  collections = collections || {};\n  this.tables = {};\n\n  this.collections = _.cloneDeep(collections);\n\n  // Build Up Join Tables\n  for(var collection in collections) {\n\n    // Parse the collection's attributes and create join tables\n    // where needed for collections\n    joinTables = this.buildJoins(collection);\n    this.uniqueTables(joinTables);\n\n    // Mark hasManyThrough tables as junction tables with select all set to true\n    this.markCustomJoinTables(collection);\n  }\n\n  // Update Collection Attributes to point to the join table\n  this.linkAttributes();\n\n  // Filter all the tables which have at least on collection on migrate: self, so they won't be built\n  this.filterMigrateSafeTables();\n\n  // Remove properties added just for unqueness\n  Object.keys(this.tables).forEach(function(table) {\n    delete self.tables[table].joinedAttributes;\n  });\n\n  return _.extend(this.collections, this.tables);\n\n}\n\n/**\n * Build A Set of Join Tables\n *\n * @param {String} collection\n * @api private\n * @return {Array}\n */\n\nJoinTables.prototype.buildJoins = function(collection) {\n\n  var self = this;\n  var tables = [];\n\n  var attributes = this.collections[collection].attributes;\n  var collectionAttributes = this.mapCollections(attributes);\n\n  // If there are no collection attributes return an empty array\n  if(Object.keys(collectionAttributes).length === 0) return [];\n\n  // For each collection attribute, inspect it to build up a join table if needed.\n  collectionAttributes.forEach(function(attribute) {\n    var table = self.parseAttribute(collection, attribute);\n    if(table) tables.push(self.buildTable(table));\n  });\n\n  return tables;\n\n};\n\n/**\n * Find Has Many attributes for a given set of attributes.\n *\n * @param {Object} attributes\n * @return {Object}\n * @api private\n */\n\nJoinTables.prototype.mapCollections = function(attributes) {\n\n  var collectionAttributes = [];\n\n  for(var attribute in attributes) {\n    if(!hop(attributes[attribute], 'collection')) continue;\n    collectionAttributes.push({ key: attribute, val: attributes[attribute] });\n  }\n\n  return collectionAttributes;\n\n};\n\n/**\n * Parse Collection Attributes\n *\n * Check the collection the attribute references to see if this is a one-to-many or many-to-many\n * relationship. If it's a one-to-many we don't need to build up a join table.\n *\n * @param {String} collectionName\n * @param {Object} attribute\n * @return {Object}\n * @api private\n */\n\nJoinTables.prototype.parseAttribute = function(collectionName, attribute) {\n\n  var error = '';\n  var attr = attribute.val;\n\n  // Check if this is a hasManyThrough attribute,\n  // if so a join table doesn't need to be created\n  if(hop(attr, 'through')) return;\n\n  // Normalize `collection` property name to lowercased version\n  attr.collection = attr.collection.toLowerCase();\n\n  // Grab the associated collection and ensure it exists\n  var child = this.collections[attr.collection];\n  if(!child) {\n    error = 'Collection ' + collectionName + ' has an attribute named ' + attribute.key + ' that is ' +\n            'pointing to a collection named ' + attr.collection + ' which doesn\\'t exist. You must ' +\n            ' first create the ' + attr.collection + ' collection.';\n\n    throw new Error(error);\n  }\n\n  // If the child attribute does not exist, throw an Error.\n  if(hop(attr, 'via') && (!child.attributes[attr.via])) {\n    error = 'on mapping custom foreign keys: ' + collectionName + '->' +  attr.collection +  '. Attribute: `' +\n    attr.via + '` does not exist on: collection: `' + attr.collection + '`';\n    throw new Error(error);\n  }\n\n  // If the attribute has a `via` key, check if it's a foreign key. If so this is a one-to-many\n  // relationship and no join table is needed.\n  if(hop(attr, 'via') && hop(child.attributes[attr.via], 'foreignKey')) return;\n\n  // If no via is specified, a name needs to be created for the other column\n  // in the join table. Use the attribute key and the associated collection name\n  // which will be unique.\n  if(!hop(attr, 'via')) attr.via = attribute.key + '_' + attr.collection;\n\n  // Build up an object that can be used to build a join table\n  var tableAttributes = {\n    column_one: {\n      collection: collectionName.toLowerCase(),\n      attribute: attribute.key,\n      via: attr.via\n    },\n\n    column_two: {\n      collection: attr.collection,\n      attribute: attr.via,\n      via: attribute.key\n    }\n  };\n\n  return tableAttributes;\n\n};\n\n/**\n * Build Collection for a single join\n *\n * @param {Object} columns\n * @return {Object}\n * @api private\n */\n\nJoinTables.prototype.buildTable = function(columns) {\n\n  var table = {};\n  var c1 = columns.column_one;\n  var c2 = columns.column_two;\n\n  table.identity = this.buildCollectionName(columns).toLowerCase();\n  table.tableName = table.identity;\n  table.tables = [c1.collection, c2.collection];\n  table.joinedAttributes = [];\n  table.junctionTable = true;\n\n  // Append the meta data if defined.\n  // To do this, find the dominant collection or just use C1 and then merge the\n  // two meta objects together with the dominant side taking precedence.\n  var dominantCollection;\n  var nonDominantCollection;\n  if(this.searchForAttribute(c2.collection, 'dominant')) {\n    dominantCollection = c2.collection;\n    nonDominantCollection = c1.collection;\n  } else {\n    dominantCollection = c1.collection;\n    nonDominantCollection = c2.collection;\n  }\n\n  var metaData = _.merge({}, (this.collections[nonDominantCollection].meta || {}), (this.collections[dominantCollection].meta || {}));\n  table.meta = metaData;\n\n  // Look for a dominant collection property so the join table can be created on the correct connection.\n  table.connection = this.findDominantConnection(columns);\n  if(!table.connection) {\n    var err = \"A 'dominant' property was not supplied for the two collections in a many-to-many relationship. \" +\n        \"One side of the relationship between '\" + c1.collection + \"' and '\" + c2.collection + \"' needs a \" +\n        \"'dominant: true' flag set so a join table can be created on the correct connection.\";\n\n    throw new Error(err);\n  }\n\n  // Set a primary key (should probably be refactored)\n  table.attributes = {\n    id: {\n      primaryKey: true,\n      autoIncrement: true,\n      type: 'integer'\n    }\n  };\n\n  // Add each foreign key as an attribute\n  table.attributes[c1.collection + '_' + c1.attribute] = this.buildForeignKey(c1, c2);\n  table.attributes[c2.collection + '_' + c2.attribute] = this.buildForeignKey(c2, c1);\n\n  table.joinedAttributes.push(c1.collection + '_' + c1.attribute);\n  table.joinedAttributes.push(c2.collection + '_' + c2.attribute);\n\n  return table;\n\n};\n\n/**\n * Build a collection name by combining two collection and attribute names.\n *\n * @param {Object} columns\n * @return {String}\n * @api private\n */\n\nJoinTables.prototype.buildCollectionName = function(columns) {\n\n  var c1 = columns.column_one;\n  var c2 = columns.column_two;\n\n  if(c1.collection < c2.collection) {\n    return c1.collection + '_' + c1.attribute + '__' + c2.collection + '_' + c2.attribute;\n  }\n\n  return c2.collection + '_' + c2.attribute + '__' + c1.collection + '_' + c1.attribute;\n\n};\n\n/**\n * Find the dominant collection.\n *\n * @param {Object} columns\n * @return {String}\n * @api private\n */\n\nJoinTables.prototype.findDominantConnection = function(columns) {\n\n  var c1 = this.collections[columns.column_one.collection];\n  var c2 = this.collections[columns.column_two.collection];\n  var dominantCollection;\n\n  // Don't require a dominant collection on self-referencing associations\n  if(columns.column_one.collection === columns.column_two.collection) {\n    return c1.connection;\n  }\n\n  dominantCollection = this.searchForAttribute(columns.column_one.collection, 'dominant');\n  if(dominantCollection) return c1.connection;\n\n  dominantCollection = this.searchForAttribute(columns.column_two.collection, 'dominant');\n  if(dominantCollection) return c2.connection;\n\n  // Don't require a dominant collection for models on the same connection.\n  if (c1.connection[0] === c2.connection[0]) {\n    return c1.connection;\n  }\n\n  return false;\n\n};\n\n/**\n * Search Attributes for an attribute property.\n *\n * @param {String} collectionName\n * @param {String} attributeName\n * @param {String} value (optional)\n * @return {String}\n * @api private\n */\n\nJoinTables.prototype.searchForAttribute = function(collectionName, attributeName, value) {\n\n  var collection = this.collections[collectionName];\n  var matching;\n  var properties;\n\n  Object.keys(collection.attributes).forEach(function(key) {\n    properties = collection.attributes[key];\n    if(!value && hop(properties, attributeName)) matching = key;\n    if(hop(properties, attributeName) && properties[attributeName] === value) matching = key;\n  });\n\n  return matching;\n\n};\n\n/**\n * Build a Foreign Key value for an attribute in the join collection\n *\n * @param {Object} column_one\n * @param {Object} column_two\n * @return {Object}\n * @api private\n */\n\nJoinTables.prototype.buildForeignKey = function(column_one, column_two) {\n\n  var primaryKey = this.findPrimaryKey(column_one.collection);\n  var columnName = (column_one.collection + '_' + column_one.attribute);\n  var viaName = column_two.collection + '_' + column_one.via;\n\n  return {\n    columnName: columnName,\n    type: primaryKey.attributes.type,\n    foreignKey: true,\n    references: column_one.collection,\n    on: primaryKey.name,\n    onKey: primaryKey.name,\n    via: viaName,\n    groupKey: column_one.collection\n  };\n\n};\n\n/**\n * Filter Out Duplicate Join Tables\n *\n * @param {Array} tables\n * @api private\n */\n\nJoinTables.prototype.uniqueTables = function(tables) {\n\n  var self = this;\n\n  tables.forEach(function(table) {\n    var add = true;\n\n    // Check if any tables are already joining these attributes together\n    Object.keys(self.tables).forEach(function(tableName) {\n      var currentTable = self.tables[tableName];\n      if(currentTable.joinedAttributes.indexOf(table.joinedAttributes[0]) === -1) return;\n      if(currentTable.joinedAttributes.indexOf(table.joinedAttributes[1]) === -1) return;\n\n      add = false;\n    });\n\n    if(hop(self.tables, table.identity)) return;\n    if(add) self.tables[table.identity] = table;\n  });\n\n};\n\n/**\n * Find a collection's primary key attribute\n *\n * @param {String} collection\n * @return {Object}\n * @api private\n */\n\nJoinTables.prototype.findPrimaryKey = function(collection) {\n\n  var primaryKey = null;\n  var attribute;\n  var error;\n\n  if(!this.collections[collection]) {\n    throw new Error('Trying to access a collection ' + collection + ' that is not defined.');\n  }\n\n  if(!this.collections[collection].attributes) {\n    throw new Error('Collection, ' + collection + ', has no attributes defined.');\n  }\n\n  for(var key in this.collections[collection].attributes) {\n    attribute = this.collections[collection].attributes[key];\n\n    if(!hop(attribute, 'primaryKey')) continue;\n\n    primaryKey = {\n      name: attribute.columnName || key,\n      attributes: attribute\n    };\n  }\n\n  if(!primaryKey) {\n    error = 'Trying to create an association on a model that doesn\\'t have a Primary Key.';\n    throw new Error(error);\n  }\n\n  return primaryKey;\n\n};\n\n/**\n * Update Collection Attributes to point to the join table instead of the other collection\n *\n * @api private\n */\n\nJoinTables.prototype.linkAttributes = function() {\n\n  for(var collection in this.collections) {\n    var attributes = this.collections[collection].attributes;\n    this.updateAttribute(collection, attributes);\n  }\n\n};\n\n/**\n * Update An Attribute\n *\n * @param {String} collection\n * @param {Object} attributes\n * @api private\n */\n\nJoinTables.prototype.updateAttribute = function(collection, attributes) {\n\n  for(var attribute in attributes) {\n    if(!hop(attributes[attribute], 'collection')) continue;\n\n    var attr = attributes[attribute];\n    var parent = collection;\n    var child = attr.collection;\n    var via = attr.via;\n\n    var joined = this.findJoinTable(parent, child, via);\n\n    if(!joined.join) continue;\n\n    // If the table doesn't know about the other side ignore updating anything\n    if(!hop(joined.table.attributes, collection + '_' + attribute)) continue;\n\n    this.collections[collection].attributes[attribute] = {\n      collection: joined.table.identity,\n      references: joined.table.identity,\n      on: joined.table.attributes[collection + '_' + attribute].columnName,\n      onKey: joined.table.attributes[collection + '_' + attribute].columnName\n    };\n  }\n\n};\n\n/**\n * Mark Custom Join Tables as a Junction Table\n *\n * If a collection has an attribute with a `through` property, lookup\n * the collection it points to and mark it as a `junctionTable`.\n *\n * @param {String} collection\n * @api private\n */\n\nJoinTables.prototype.markCustomJoinTables = function(collection) {\n\n  var attributes = this.collections[collection].attributes;\n\n  for(var attribute in attributes) {\n    if(!hop(attributes[attribute], 'through')) continue;\n\n    var linkedCollection = attributes[attribute].through;\n    this.collections[linkedCollection].throughTable = this.collections[linkedCollection].throughTable || {};\n    var throughPath = collection + '.' + attribute;\n    var linkedAttrs = this.collections[linkedCollection].attributes;\n    this.collections[linkedCollection].throughTable[throughPath] = _.find(_.keys(linkedAttrs), function(attr){\n      return linkedAttrs[attr].references === attributes[attribute].collection.toLowerCase();\n    });\n\n    // Build up proper reference on the attribute\n    attributes[attribute].collection = linkedCollection;\n    attributes[attribute].references = linkedCollection;\n\n    // Find Reference Key\n    var via = attributes[attribute].via;\n    var reference = this.findReference(collection, linkedCollection, via);\n    var referencedAttr = this.collections[linkedCollection].attributes[reference];\n    var onValue;\n    if (referencedAttr && referencedAttr.columnName) {\n      onValue = referencedAttr.columnName;\n    } else {\n      onValue = reference;\n    }\n\n    attributes[attribute].on = onValue;\n    attributes[attribute].onKey = reference;\n\n    delete attributes[attribute].through;\n  }\n\n};\n\n/**\n * Find Reference attribute name in a set of attributes\n *\n * @param {String} parent\n * @param {String} collection\n * @return {String}\n * @api private\n */\n\nJoinTables.prototype.findReference = function(parent, collection, via) {\n\n  var attributes = this.collections[collection].attributes;\n  var reference;\n\n  for(var attribute in attributes) {\n    if(!hop(attributes[attribute], 'foreignKey')) continue;\n    if(!hop(attributes[attribute], 'references')) continue;\n    if(attributes[attribute].references !== parent) continue;\n    if(via && via !== attribute) continue;\n\n    reference = attribute;\n    break;\n  }\n\n  return reference;\n\n};\n\n/**\n * Search for a matching join table\n *\n * @param {String} parent\n * @param {String} child\n * @param {String} via\n * @return {Object}\n * @api private\n */\n\nJoinTables.prototype.findJoinTable = function(parent, child, via) {\n\n  var join = false;\n  var tableCollection;\n\n  for(var table in this.tables) {\n    var tables = this.tables[table].tables;\n\n    if(tables.indexOf(parent) < 0) continue;\n    if(tables.indexOf(child) < 0) continue;\n\n    var column = child + '_' + via;\n\n    if(!hop(this.tables[table].attributes, column)) continue;\n\n    join = true;\n    tableCollection = this.tables[table];\n    break;\n  }\n\n  return { join: join, table: tableCollection };\n\n};\n\n\n/**\n * Filter all tables which have at least one collection set to migrate: true, before they get physically created in the database\n * AFTER all references are set and all collections have been linked\n *\n * @param {String} tables\n * @api private\n */\n\nJoinTables.prototype.filterMigrateSafeTables = function() {\n  var self = this;\n\n  for(var table in this.tables) {\n    var tables = this.tables[table].tables;\n\n    // iterate through all collections, if one of them is migrate: safe we delete the table\n    // so it does not get built\n    var migrateSafe = false;\n    tables.forEach(function(collection) {\n      if(self.collections[collection].migrate === 'safe') {\n        migrateSafe = true;\n      }\n    });\n\n    if(migrateSafe === true) {\n      this.tables[table].migrate = 'safe';\n    }\n  }\n\n  return this.tables;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-schema/lib/waterline-schema/references.js":"\n/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('./utils');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Expose References\n */\n\nmodule.exports = References;\n\n/**\n * Map References for hasMany attributes. Not necessarily used for most schemas\n * but used internally in Waterline. It could also be helpful for key/value datastores.\n *\n * @param {Object} collections\n * @return {Object}\n * @api private\n */\n\nfunction References(collections) {\n\n  collections = collections || {};\n  this.collections = _.clone(collections);\n\n  for(var collection in collections) {\n    this.addKeys(collection);\n  }\n\n  return this.collections;\n\n}\n\n/**\n * Add Reference Keys to hasMany attributes\n *\n * @param {String} collection\n * @api private\n */\n\nReferences.prototype.addKeys = function(collection) {\n\n  var attributes = this.collections[collection].attributes;\n  var reference;\n\n  for(var attribute in attributes) {\n    if(!hop(attributes[attribute], 'collection')) continue;\n\n    // If references have already been configured, continue on\n    if(attributes[attribute].references && attributes[attribute].on) continue;\n\n    attributes[attribute].collection = attributes[attribute].collection;\n\n    // Check For HasMany Through\n    if(hop(attributes[attribute], 'through')) {\n      reference = this.findReference(attributes[attribute].collection.toLowerCase(), attributes[attribute].through.toLowerCase());\n      if(!reference) continue;\n\n      attributes[attribute].references = attributes[attribute].through;\n      attributes[attribute].on = reference.reference;\n      attributes[attribute].onKey = reference.keyName;\n      delete attributes[attribute].through;\n\n      continue;\n    }\n\n    // Figure out what to reference by looping through the other collection\n    reference = this.findReference(collection, attributes[attribute].collection.toLowerCase(), attributes[attribute]);\n    if(!reference) continue;\n\n    attributes[attribute].references = attributes[attribute].collection.toLowerCase();\n    attributes[attribute].on = reference.reference;\n    attributes[attribute].onKey = reference.keyName;\n  }\n\n};\n\n/**\n * Find Reference attribute name in a set of attributes\n *\n * @param {String} parent\n * @param {String} collection\n * @param {Object} attribute\n * @return {String}\n * @api private\n */\n\nReferences.prototype.findReference = function(parent, collection, attribute) {\n\n  if(typeof this.collections[collection] != 'object') {\n    throw new Error('Cannot find collection \\'' + collection + '\\' referenced in ' + parent);\n  }\n\n  var attributes = this.collections[collection].attributes;\n  var reference;\n  var matchingAttributes = [];\n  var obj = {};\n\n  for(var attr in attributes) {\n    if(!hop(attributes[attr], 'foreignKey')) continue;\n    if(!hop(attributes[attr], 'references')) continue;\n    if(attributes[attr].references !== parent) continue;\n\n    // Add the attribute to the matchingAttribute array\n    matchingAttributes.push(attr);\n  }\n\n  // If no matching attributes are found, throw an error because you are trying to add a hasMany\n  // attribute to a model where the association doesn't have a foreign key matching the collection.\n  if(matchingAttributes.length === 0) {\n    throw new Error('Trying to associate a collection attribute to a model that doesn\\'t have a ' +\n                    'Foreign Key. ' + parent + ' is trying to reference a foreign key in ' + collection);\n  }\n\n  // If multiple matching attributes were found on the model, ensure that the collection has a `via`\n  // key that describes which foreign key to use when populating.\n  if(matchingAttributes.length > 1) {\n    if(!hop(attribute, 'via')) {\n      throw new Error('Multiple foreign keys were found on ' + collection + '. You need to specify a ' +\n                      'foreign key to use by adding in the `via` property to the collection association');\n    }\n\n    // Find the collection attribute used in the `via` property\n    var via = false;\n    var viaName;\n\n    matchingAttributes.forEach(function(attr) {\n      if(attr !== attribute.via) return;\n      via = attributes[attr];\n      viaName = attr;\n    });\n\n    if(!via) {\n      throw new Error('No matching attribute was found on ' + collection + ' with the name ' + attribute.via);\n    }\n\n    reference = via.columnName || viaName;\n    obj = { reference: reference, keyName: viaName };\n    return obj;\n  }\n\n  // If only a single matching attribute was found we can just use that for the reference\n  reference = attributes[matchingAttributes[0]].columnName || matchingAttributes[0];\n  obj = { reference: reference, keyName: matchingAttributes[0] };\n  return obj;\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/connections/index.js":"/**\n * Module Dependencies\n */\nvar _ = require('lodash');\nvar util = require('util');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\n/**\n * Connections are active \"connections\" to a specific adapter for a specific configuration.\n * This allows you to have collections share named connections.\n *\n * @param {Object} adapters\n * @param {Object} objects\n * @api public\n */\n\nvar Connections = module.exports = function(adapters, options) {\n\n  // Hold the active connections\n  this._connections = {};\n\n  // Build the connections\n  this._build(adapters, options);\n\n  return this._connections;\n};\n\n\n/**\n * Builds up a named connections object with a clone of the adapter\n * it will use for the connection.\n *\n * @param {Object} adapters\n * @param {Object} options\n * @api private\n */\nConnections.prototype._build = function _build(adapters, options) {\n\n  var self = this;\n\n  // For each of the configured connections in options, find the required\n  // adapter by name and build up an object that can be attached to the\n  // internal connections object.\n  Object.keys(options).forEach(function(key) {\n    var config = options[key];\n    var msg,\n        connection;\n\n    // Ensure an adapter module is specified\n    if (!hasOwnProperty(config, 'adapter')) {\n      msg = util.format('Connection (\"%s\") is missing a required property (`adapter`).  You should indicate the name of one of your adapters.', key);\n      throw new Error(msg);\n    }\n\n    // Ensure the adapter exists in the adapters options\n    if (!hasOwnProperty(adapters, config.adapter)) {\n      if (typeof config.adapter !== 'string') {\n        msg = util.format('Invalid `adapter` property in connection `%s`.  It should be a string (the name of one of the adapters you passed into `waterline.initialize()`)', key);\n      }\n      else msg = util.format('Unknown adapter \"%s\" for connection `%s`.  You should double-check that the connection\\'s `adapter` property matches the name of one of your adapters.  Or perhaps you forgot to include your \"%s\" adapter when you called `waterline.initialize()`...', config.adapter, key, config.adapter);\n      throw new Error(msg);\n    }\n\n    // Build the connection config\n    connection = {\n      config: _.merge({}, adapters[config.adapter].defaults, config),\n      _adapter: _.cloneDeep(adapters[config.adapter]),\n      _collections: []\n    };\n\n    // Attach the connections to the connection library\n    self._connections[key] = connection;\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/helpers.js":"\n/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\n\n/**\n * Equivalent to _.objMap, _.map for objects, keeps key/value associations\n *\n * Should be deprecated.\n *\n * @api public\n */\nexports.objMap = function objMap(input, mapper, context) {\n  return _.reduce(input, function(obj, v, k) {\n    obj[k] = mapper.call(context, v, k, input);\n    return obj;\n  }, {}, context);\n};\n\n/**\n * Run a method meant for a single object on a object OR array\n * For an object, run the method and return the result.\n * For a list, run the method on each item return the resulting array.\n * For anything else, return it silently.\n *\n * Should be deprecated.\n *\n * @api public\n */\n\nexports.pluralize = function pluralize(collection, application) {\n  if (Array.isArray(collection)) return _.map(collection, application);\n  if (_.isObject(collection)) return application(collection);\n  return collection;\n};\n\n/**\n * _.str.capitalize\n *\n * @param {String} str\n * @return {String}\n * @api public\n */\n\nexports.capitalize = function capitalize(str) {\n  str = str === null ? '' : String(str);\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n * ignore\n */\n\nexports.object = {};\n\n/**\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n * @return {Boolean}\n * @api public\n */\n\nvar hop = Object.prototype.hasOwnProperty;\nexports.object.hasOwnProperty = function(obj, prop) {\n  if (obj === null || obj === undefined) return false;\n  return hop.call(obj, prop);\n};\n\n/**\n * Check if an ID resembles a Mongo BSON ID.\n * Can't use the `hop` helper above because BSON ID's will have their own hasOwnProperty value.\n *\n * @param {String} id\n * @return {Boolean}\n * @api public\n */\n\nexports.matchMongoId = function matchMongoId(id) {\n  // id must be truthy- and either BE a string, or be an object\n  // with a toString method.\n  if (!id ||\n   !(_.isString(id) || (_.isObject(id) || _.isFunction(id.toString)))\n  ) return false;\n  else return /^[a-fA-F0-9]{24}$/.test(id.toString());\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/collection/loader.js":"/**\n * Module Dependencies\n */\n\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\n/**\n * Collection Loader\n *\n * @param {Object} connections\n * @param {Object} collection\n * @api public\n */\n\nvar CollectionLoader = module.exports = function(collection, connections, defaults) {\n\n  this.defaults = defaults;\n\n  // Normalize and validate the collection\n  this.collection = this._validate(collection, connections);\n\n  // Find the named connections used in the collection\n  this.namedConnections = this._getConnections(collection, connections);\n\n  return this;\n};\n\n/**\n * Initalize the collection\n *\n * @param {Object} context\n * @param {Function} callback\n * @api public\n */\n\nCollectionLoader.prototype.initialize = function initialize(context) {\n  return new this.collection(context, this.namedConnections);\n};\n\n/**\n * Validate Collection structure.\n *\n * @param {Object} collection\n * @param {Object} connections\n * @api private\n */\n\nCollectionLoader.prototype._validate = function _validate(collection, connections) {\n\n  // Throw Error if no Tablename/Identity is set\n  if (!hasOwnProperty(collection.prototype, 'tableName') && !hasOwnProperty(collection.prototype, 'identity')) {\n    throw new Error('A tableName or identity property must be set.');\n  }\n\n  // Ensure identity is lowercased\n  collection.prototype.identity = collection.prototype.identity.toLowerCase();\n\n  // Set the defaults\n  collection.prototype.defaults = this.defaults;\n\n  // Find the connections used by this collection\n  // If none is specified check if a default connection exist\n  if (!hasOwnProperty(collection.prototype, 'connection')) {\n\n    // Check if a default connection was specified\n    if (!hasOwnProperty(connections, 'default')) {\n      throw new Error('No adapter was specified for collection: ' + collection.prototype.identity);\n    }\n\n    // Set the connection as the default\n    collection.prototype.connection = 'default';\n  }\n\n  return collection;\n};\n\n/**\n * Get the named connections\n *\n * @param {Object} collection\n * @param {Object} connections\n * @api private\n */\n\nCollectionLoader.prototype._getConnections = function _getConnections(collection, connections) {\n\n  // Hold the used connections\n  var usedConnections = {};\n\n  // Normalize connection to array\n  if (!Array.isArray(collection.prototype.connection)) {\n    collection.prototype.connection = [collection.prototype.connection];\n  }\n\n  // Set the connections used for the adapter\n  collection.prototype.connection.forEach(function(conn) {\n\n    // Ensure the named connection exist\n    if (!hasOwnProperty(connections, conn)) {\n      var msg = 'The connection ' + conn + ' specified in ' + collection.prototype.identity + ' does not exist!';\n      throw new Error(msg);\n    }\n\n    usedConnections[conn] = connections[conn];\n  });\n\n  return usedConnections;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/collection/defaults.js":"\n/**\n * Default Collection properties\n * @type {Object}\n */\nmodule.exports = {\n\n\tmigrate: 'alter'\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/collection/index.js":"/**\n * Dependencies\n */\n\nvar _ = require('lodash');\nvar extend = require('../utils/extend');\nvar inherits = require('util').inherits;\n\n// Various Pieces\nvar Core = require('../core');\nvar Query = require('../query');\n\n/**\n * Collection\n *\n * A prototype for managing a collection of database\n * records.\n *\n * This file is the prototype for collections defined using Waterline.\n * It contains the entry point for all ORM methods (e.g. User.find())\n *\n * Methods in this file defer to the adapter for their true implementation:\n * the implementation here just validates and normalizes the parameters.\n *\n * @param {Object} waterline, reference to parent\n * @param {Object} options\n * @param {Function} callback\n */\n\nvar Collection = module.exports = function(waterline, connections, cb) {\n\n  var self = this;\n\n  // Set the named connections\n  this.connections = connections || {};\n\n  // Cache reference to the parent\n  this.waterline = waterline;\n\n  // Default Attributes\n  this.attributes = this.attributes || {};\n\n  // Instantiate Base Collection\n  Core.call(this);\n\n  // Instantiate Query Language\n  Query.call(this);\n\n  return this;\n};\n\ninherits(Collection, Core);\ninherits(Collection, Query);\n\n// Make Extendable\nCollection.extend = extend;\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/extend.js":"/**\n * Extend Method\n *\n * Taken from Backbone Source:\n * http://backbonejs.org/docs/backbone.html#section-189\n */\n\nvar _ = require('lodash');\n\nmodule.exports = function(protoProps, staticProps) {\n  var parent = this;\n  var child;\n\n  if (protoProps && _.has(protoProps, 'constructor')) {\n    child = protoProps.constructor;\n  } else {\n    child = function() { return parent.apply(this, arguments); };\n  }\n\n  _.extend(child, parent, staticProps);\n\n  var Surrogate = function() { this.constructor = child; };\n  Surrogate.prototype = parent.prototype;\n  child.prototype = new Surrogate();\n\n  if (protoProps) _.extend(child.prototype, protoProps);\n\n  child.__super__ = parent.prototype;\n\n  return child;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/core/index.js":"/**\n * Dependencies\n */\n\nvar _ = require('lodash');\nvar schemaUtils = require('../utils/schema');\nvar COLLECTION_DEFAULTS = require('../collection/defaults');\nvar Model = require('../model');\nvar Cast = require('./typecast');\nvar Schema = require('./schema');\nvar Dictionary = require('./dictionary');\nvar Validator = require('./validations');\nvar Transformer = require('./transformations');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\n/**\n * Core\n *\n * Setup the basic Core of a collection to extend.\n */\n\nvar Core = module.exports = function(options) {\n\n  options = options || {};\n\n  // Set Defaults\n  this.adapter = this.adapter || {};\n  this._attributes = _.clone(this.attributes);\n  this.connections = this.connections || {};\n\n  this.defaults = _.merge(COLLECTION_DEFAULTS, this.defaults);\n\n  // Construct our internal objects\n  this._cast = new Cast();\n  this._schema = new Schema(this);\n  this._validator = new Validator();\n\n  // Normalize attributes, extract instance methods, and callbacks\n  // Note: this is ordered for a reason!\n  this._callbacks = schemaUtils.normalizeCallbacks(this);\n  this._instanceMethods = schemaUtils.instanceMethods(this.attributes);\n  this._attributes = schemaUtils.normalizeAttributes(this._attributes);\n\n  this.hasSchema = Core._normalizeSchemaFlag.call(this);\n\n  this.migrate = Object.getPrototypeOf(this).hasOwnProperty('migrate') ?\n    this.migrate : this.defaults.migrate;\n\n  // Initalize the internal values from the Collection\n  Core._initialize.call(this, options);\n\n  return this;\n};\n\n/**\n * Initialize\n *\n * Setups internal mappings from an extended collection.\n */\n\nCore._initialize = function(options) {\n  var self = this;\n\n  options = options || {};\n\n  // Extend a base Model with instance methods\n  this._model = new Model(this, this._instanceMethods);\n\n  // Cache the attributes from the schema builder\n  var schemaAttributes = this.waterline.schema[this.identity].attributes;\n\n  // Remove auto attributes for validations\n  var _validations = _.clone(this._attributes);\n  if (this.autoPK) delete _validations.id;\n  if (this.autoCreatedAt) delete _validations.createdAt;\n  if (this.autoUpdatedAt) delete _validations.updatedAt;\n\n  // If adapter exposes any reserved attributes, pass them to the schema\n  var connIdx = Array.isArray(this.connection) ? this.connection[0] : this.connection;\n\n  var adapterInfo = {};\n  if (this.connections[connIdx] && this.connections[connIdx]._adapter) {\n    adapterInfo = this.connections[connIdx]._adapter;\n  }\n\n  var reservedAttributes = adapterInfo.reservedAttributes || {};\n\n  // Initialize internal objects from attributes\n  this._schema.initialize(this._attributes, this.hasSchema, reservedAttributes);\n  this._cast.initialize(this._schema.schema);\n  this._validator.initialize(_validations, this.types, this.defaults.validations);\n\n  // Set the collection's primaryKey attribute\n  Object.keys(schemaAttributes).forEach(function(key) {\n    if (hasOwnProperty(schemaAttributes[key], 'primaryKey') && schemaAttributes[key].primaryKey) {\n      self.primaryKey = key;\n    }\n  });\n\n  // Build Data Transformer\n  this._transformer = new Transformer(schemaAttributes, this.waterline.schema);\n\n  // Transform Schema\n  this._schema.schema = this._transformer.serialize(this._schema.schema, 'schema');\n\n  // Build up a dictionary of which methods run on which connection\n  this.adapterDictionary = new Dictionary(_.cloneDeep(this.connections), this.connection);\n\n  // Add this collection to the connection\n  Object.keys(this.connections).forEach(function(conn) {\n    self.connections[conn]._collections = self.connections[conn]._collections || [];\n    self.connections[conn]._collections.push(self.identity);\n  });\n\n  // Remove remnants of user defined attributes\n  delete this.attributes;\n};\n\n/**\n * Normalize Schema Flag\n *\n * Normalize schema setting by looking at the model first to see if it is defined, if not look at\n * the connection and see if it's defined and if not finally look into the adapter and check if\n * there is a default setting. If not found anywhere be safe and set to true.\n *\n * @api private\n * @return {Boolean}\n */\n\nCore._normalizeSchemaFlag = function() {\n\n  // If schema is defined on the collection, return the value\n  if (hasOwnProperty(Object.getPrototypeOf(this), 'schema')) {\n    return Object.getPrototypeOf(this).schema;\n  }\n\n  // Grab the first connection used\n  if (!this.connection || !Array.isArray(this.connection)) return true;\n  var connection = this.connections[this.connection[0]];\n\n  // Check the user defined config\n  if (hasOwnProperty(connection, 'config') && hasOwnProperty(connection.config, 'schema')) {\n    return connection.config.schema;\n  }\n\n  // Check the defaults defined in the adapter\n  if (!hasOwnProperty(connection, '_adapter')) return true;\n  if (!hasOwnProperty(connection._adapter, 'schema')) return true;\n\n  return connection._adapter.schema;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/schema.js":"/**\n * Dependencies\n */\n\nvar _ = require('lodash');\nvar types = require('./types');\nvar callbacks = require('./callbacks');\nvar hasOwnProperty = require('./helpers').object.hasOwnProperty;\n\n/**\n * Expose schema\n */\n\nvar schema = module.exports = exports;\n\n/**\n * Iterate over `attrs` normalizing string values to the proper\n * attribute object.\n *\n * Example:\n * {\n *   name: 'STRING',\n *   age: {\n *     type: 'INTEGER'\n *   }\n * }\n *\n * Returns:\n * {\n *   name: {\n *     type: 'string'\n *   },\n *   age: {\n *     type: 'integer'\n *   }\n * }\n *\n * @param {Object} attrs\n * @return {Object}\n */\n\nschema.normalizeAttributes = function(attrs) {\n  var attributes = {};\n\n  Object.keys(attrs).forEach(function(key) {\n\n    // Not concerned with functions\n    if (typeof attrs[key] === 'function') return;\n\n    // Expand shorthand type\n    if (typeof attrs[key] === 'string') {\n      attributes[key] = { type: attrs[key] };\n    } else {\n      attributes[key] = attrs[key];\n    }\n\n    // Ensure type is lower case\n    if (attributes[key].type && typeof attributes[key].type !== 'undefined') {\n      attributes[key].type = attributes[key].type.toLowerCase();\n    }\n\n    // Ensure Collection property is lowercased\n    if (hasOwnProperty(attrs[key], 'collection')) {\n      attrs[key].collection = attrs[key].collection.toLowerCase();\n    }\n\n    // Ensure Model property is lowercased\n    if (hasOwnProperty(attrs[key], 'model')) {\n      attrs[key].model = attrs[key].model.toLowerCase();\n    }\n  });\n\n  return attributes;\n};\n\n\n/**\n * Return all methods in `attrs` that should be provided\n * on the model.\n *\n * Example:\n * {\n *   name: 'string',\n *   email: 'string',\n *   doSomething: function() {\n *     return true;\n *   }\n * }\n *\n * Returns:\n * {\n *   doSomething: function() {\n *     return true;\n *   }\n * }\n *\n * @param {Object} attrs\n * @return {Object}\n */\n\nschema.instanceMethods = function(attrs) {\n  var methods = {};\n\n  if (!attrs) return methods;\n\n  Object.keys(attrs).forEach(function(key) {\n    if (typeof attrs[key] === 'function') {\n      methods[key] = attrs[key];\n    }\n  });\n\n  return methods;\n};\n\n\n/**\n * Normalize callbacks\n *\n * Return all callback functions in `context`, allows for string mapping to\n * functions located in `context.attributes`.\n *\n * Example:\n * {\n *   attributes: {\n *     name: 'string',\n *     email: 'string',\n *     increment: function increment() { i++; }\n *   },\n *   afterCreate: 'increment',\n *   beforeCreate: function() { return true; }\n * }\n *\n * Returns:\n * {\n *   afterCreate: [\n *     function increment() { i++; }\n *   ],\n *   beforeCreate: [\n *     function() { return true; }\n *   ]\n * }\n *\n * @param {Object} context\n * @return {Object}\n */\n\nschema.normalizeCallbacks = function(context) {\n  var i, _i, len, _len, fn;\n  var fns = {};\n\n  function defaultFn(fn) {\n    return function(values, next) { return next(); };\n  }\n\n  for (i = 0, len = callbacks.length; i < len; i = i + 1) {\n    fn = callbacks[i];\n\n    // Skip if the model hasn't defined this callback\n    if (typeof context[fn] === 'undefined') {\n      fns[fn] = [ defaultFn(fn) ];\n      continue;\n    }\n\n    if (Array.isArray(context[fn])) {\n      fns[fn] = [];\n\n      // Iterate over all functions\n      for (_i = 0, _len = context[fn].length; _i < _len; _i = _i + 1) {\n        if (typeof context[fn][_i] === 'string') {\n          // Attempt to map string to function\n          if (typeof context.attributes[context[fn][_i]] === 'function') {\n            fns[fn][_i] = context.attributes[context[fn][_i]];\n            delete context.attributes[context[fn][_i]];\n          } else {\n            throw new Error('Unable to locate callback `' + context[fn][_i] + '`');\n          }\n        } else {\n          fns[fn][_i] = context[fn][_i];\n        }\n      }\n    } else if (typeof context[fn] === 'string') {\n      // Attempt to map string to function\n      if (typeof context.attributes[context[fn]] === 'function') {\n        fns[fn] = [ context.attributes[context[fn]] ];\n        delete context.attributes[context[fn]];\n      } else {\n        throw new Error('Unable to locate callback `' + context[fn] + '`');\n      }\n    } else {\n      // Just add a single function\n      fns[fn] = [ context[fn] ];\n    }\n  }\n\n  return fns;\n};\n\n\n/**\n * Replace any Join Criteria references with the defined tableName for a collection.\n *\n * @param {Object} criteria\n * @param {Object} collections\n * @return {Object}\n * @api public\n */\n\nschema.serializeJoins = function(criteria, collections) {\n\n  if (!criteria.joins) return criteria;\n\n  var joins = _.cloneDeep(criteria.joins);\n\n  joins.forEach(function(join) {\n\n    if (!hasOwnProperty(collections[join.parent], 'tableName')) return;\n    if (!hasOwnProperty(collections[join.child], 'tableName')) return;\n\n    join.parent = collections[join.parent].tableName;\n    join.child = collections[join.child].tableName;\n\n  });\n\n  criteria.joins = joins;\n  return criteria;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/types.js":"/**\n * Types Supported By Schemas\n */\n\nmodule.exports = [\n  'string',\n  'text',\n  'integer',\n  'float',\n  'date',\n  'time',\n  'datetime',\n  'boolean',\n  'binary',\n  'array',\n  'json',\n  'mediumtext',\n  'longtext',\n  'objectid'\n];\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/callbacks.js":"/**\n * Lifecycle Callbacks Allowed\n */\n\nmodule.exports = [\n  'beforeValidate',\n  'afterValidate',\n  'beforeUpdate',\n  'afterUpdate',\n  'beforeCreate',\n  'afterCreate',\n  'beforeDestroy',\n  'afterDestroy'\n];\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/index.js":"\n/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar Bluebird = require('bluebird');\nvar Model = require('./lib/model');\nvar defaultMethods = require('./lib/defaultMethods');\nvar internalMethods = require('./lib/internalMethods');\n\n/**\n * Build Extended Model Prototype\n *\n * @param {Object} context\n * @param {Object} mixins\n * @return {Object}\n * @api public\n */\n\nmodule.exports = function(context, mixins) {\n\n  /**\n   * Extend the model prototype with default instance methods\n   */\n\n  var prototypeFns = {\n\n    toObject: function() {\n      return new defaultMethods.toObject(context, this);\n    },\n\n    save: function(options, cb) {\n      return new defaultMethods.save(context, this, options, cb);\n    },\n\n    destroy: function(cb) {\n      return new defaultMethods.destroy(context, this, cb);\n    },\n\n    _defineAssociations: function() {\n      new internalMethods.defineAssociations(context, this);\n    },\n\n    _normalizeAssociations: function() {\n      new internalMethods.normalizeAssociations(context, this);\n    },\n\n    _cast: function(values) {\n      _.keys(context._attributes).forEach(function(key) {\n        var type = context._attributes[key].type;\n\n        // Attempt to parse Array or JSON type\n        if (type === 'array' || type === 'json') {\n          if (!_.isString(values[key])) return;\n          try {\n            values[key] = JSON.parse(values[key]);\n          } catch(e) {\n            return;\n          }\n        }\n\n        // Convert booleans back to true/false\n        if (type === 'boolean') {\n          var val = values[key];\n          if (val === 0) values[key] = false;\n          if (val === 1) values[key] = true;\n        }\n\n      });\n    },\n\n    /**\n     * Model.validate()\n     *\n     * Takes the currently set attributes and validates the model\n     * Shorthand for Model.validate({ attributes }, cb)\n     *\n     * @param {Function} callback - (err)\n     * @return {Promise}\n     */\n\n    validate: function(cb) {\n      // Collect current values\n      var values = this.toObject();\n\n      if (cb) {\n        context.validate(values, function(err) {\n          if (err) { return cb(err); }\n          cb();\n        });\n        return;\n      } else {\n        return new Bluebird(function(resolve, reject) {\n          context.validate(values, function(err) {\n            if (err) { return reject(err); }\n            resolve();\n          });\n        });\n      }\n    }\n\n  };\n\n  // If any of the attributes are protected, the default toJSON method should\n  // remove them.\n  var protectedAttributes = _.compact(_.map(context._attributes, function(attr, key) {return attr.protected ? key : undefined;}));\n\n  prototypeFns.toJSON = function() {\n    var obj = this.toObject();\n\n    if (protectedAttributes.length) {\n      _.each(protectedAttributes, function(key) {\n        delete obj[key];\n      });\n    }\n\n    // Remove toJSON from the result, to prevent infinite recursion with\n    // msgpack or other recursive object transformation tools.\n    //\n    // Causes issues if set to null and will error in Sails if we delete it because blueprints call it.\n    //\n    // obj.toJSON = null;\n\n    return obj;\n  };\n\n  var prototype = _.extend(prototypeFns, mixins);\n\n  var model = Model.extend(prototype);\n\n  // Return the extended model for use in Waterline\n  return model;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/model.js":"\n/**\n * Dependencies\n */\n\nvar extend = require('../../utils/extend');\nvar _ = require('lodash');\nvar util = require('util');\n\n/**\n * A Basic Model Interface\n *\n * Initialize a new Model with given params\n *\n * @param {Object} attrs\n * @param {Object} options\n * @return {Object}\n * @api public\n *\n * var Person = Model.prototype;\n * var person = new Person({ name: 'Foo Bar' });\n * person.name # => 'Foo Bar'\n */\n\nvar Model = module.exports = function(attrs, options) {\n  var self = this;\n\n  attrs = attrs || {};\n  options = options || {};\n\n  // Store options as properties\n  Object.defineProperty(this, '_properties', {\n    enumerable: false,\n    writable: false,\n    value: options\n  });\n\n  // Cast things that need to be cast\n  this._cast(attrs);\n\n  // Build association getters and setters\n  this._defineAssociations();\n\n  // Attach attributes to the model instance\n  for (var key in attrs) {\n    this[key] = attrs[key];\n\n    if (this.associationsCache.hasOwnProperty(key)) {\n      this.associationsCache[key] = _.cloneDeep(attrs[key]);\n    }\n  }\n\n  // Normalize associations\n  this._normalizeAssociations();\n\n\n  /**\n   * Log output\n   * @return {String} output when this model is util.inspect()ed\n   * (usually with console.log())\n   */\n\n  Object.defineProperty(this, 'inspect', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: function() {\n      var output;\n      try {\n        output = self.toObject();\n      } catch (e) {}\n\n      return output ? util.inspect(output) : self;\n    }\n  });\n\n  return this;\n};\n\n// Make Extendable\nModel.extend = extend;\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/defaultMethods/index.js":"\n/**\n * Export Default Methods\n */\n\nmodule.exports = {\n  toObject: require('./toObject'),\n  destroy: require('./destroy'),\n  save: require('./save')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/defaultMethods/toObject.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Model.toObject()\n *\n * Returns an object containing just the model values. Useful for doing\n * operations on the current values minus the instance methods.\n *\n * @param {Object} context, Waterline collection instance\n * @param {Object} proto, model prototype\n * @api public\n * @return {Object}\n */\n\nvar toObject = module.exports = function(context, proto) {\n\n  var self = this;\n\n  this.context = context;\n  this.proto = proto;\n\n  // Hold joins used in the query\n  this.usedJoins = [];\n\n  // Create an object that can hold the values to be returned\n  this.object = {};\n\n  // Run methods to add and modify values to the above object\n  this.addAssociations();\n  this.addProperties();\n  this.makeObject();\n  this.filterJoins();\n  this.filterFunctions();\n\n  // Ok now we want to create a POJO that can be serialized for use in a response.\n  // This is after all usually called in a toJSON method so lets make sure its all\n  // good in there. This could be faster and safer I recon.\n  try {\n\n    // Stringify/parse the object\n    var _obj = JSON.parse(JSON.stringify(this.object));\n\n    return _obj;\n\n  // Return a nicer error message than just throwing the json parse message\n  } catch (e) {\n    var err = new Error();\n    err.message = 'There was an error turning the model into an object.';\n    err.data = self.object;\n    throw err;\n  }\n};\n\n\n/**\n * Add Association Keys\n *\n * If a showJoins flag is active, add all association keys.\n *\n * @param {Object} keys\n * @api private\n */\n\ntoObject.prototype.addAssociations = function() {\n  var self = this;\n\n  if (!this.proto._properties) return;\n  if (!this.proto._properties.showJoins) return;\n\n  // Copy prototype over for attributes\n  for (var association in this.proto.associations) {\n\n    // Handle hasMany attributes\n    if (hasOwnProperty(this.proto.associations[association], 'value')) {\n\n      var records = [];\n      var values = this.proto.associations[association].value;\n\n      values.forEach(function(record) {\n        if (typeof record !== 'object') return;\n        // Since `typeof null` === `\"object\"`, we should also check for that case:\n        if (record === null) return;\n        var item = Object.create(record.__proto__);\n        Object.keys(record).forEach(function(key) {\n          item[key] = _.cloneDeep(record[key]);\n        });\n        records.push(item);\n      });\n\n      this.object[association] = records;\n      continue;\n    }\n\n    // Handle belongsTo attributes\n    var record = this.proto[association];\n    var item;\n\n    // Check if the association foreign key is a date. If so set the object's\n    // association and continue. Manual check here is needed because _.isObject\n    // matches dates and you will end up with a loop that never exits.\n    if (_.isDate(record)) {\n\n      item = new Date(record);\n      _.extend(item.__proto__ , record.__proto__);\n\n      this.object[association] = item;\n    }\n\n    // Is the record is a populated object, create a new object from it.\n    // _.isObject() does not match null, so we're good here.\n    else if (_.isObject(record) && !Array.isArray(record)) {\n\n      item = Object.create(record.__proto__);\n\n      Object.keys(record).forEach(function(key) {\n        item[key] = record[key];\n      });\n\n      this.object[association] = item;\n    }\n\n    else if (!_.isUndefined(record)) {\n      this.object[association] = record;\n    }\n  }\n};\n\n/**\n * Add Properties\n *\n * Copies over non-association attributes to the newly created object.\n *\n * @api private\n */\n\ntoObject.prototype.addProperties = function() {\n  var self = this;\n\n  Object.keys(this.proto).forEach(function(key) {\n    if (hasOwnProperty(self.object, key)) return;\n    self.object[key] = self.proto[key];\n  });\n\n};\n\n/**\n * Make Object\n *\n * Runs toJSON on all associated values\n *\n * @api private\n */\n\ntoObject.prototype.makeObject = function() {\n  var self = this;\n\n  if (!this.proto._properties) return;\n  if (!this.proto._properties.showJoins) return;\n\n  // Handle Joins\n  Object.keys(this.proto.associations).forEach(function(association) {\n\n    // Don't run toJSON on records that were not populated\n    if (!self.proto._properties || !self.proto._properties.joins) return;\n\n    // Build up a join key name based on the attribute's model/collection name\n    var joinsName = association;\n    if (self.context._attributes[association].model) joinsName = self.context._attributes[association].model.toLowerCase();\n    if (self.context._attributes[association].collection) joinsName = self.context._attributes[association].collection.toLowerCase();\n\n    // Check if the join was used\n    if (self.proto._properties.joins.indexOf(joinsName) < 0 && self.proto._properties.joins.indexOf(association) < 0) return;\n    self.usedJoins.push(association);\n\n    // Call toJSON on each associated record\n    if (Array.isArray(self.object[association])) {\n      var records = [];\n\n      self.object[association].forEach(function(item) {\n        if (!hasOwnProperty(item.__proto__, 'toJSON')) return;\n        records.push(item.toJSON());\n      });\n\n      self.object[association] = records;\n      return;\n    }\n\n    if (!self.object[association]) return;\n\n    // Association was null or not valid\n    // (don't try to `hasOwnProperty` it so we don't throw)\n    if (typeof self.object[association] !== 'object') {\n      self.object[association] = self.object[association];\n      return;\n    }\n\n    if (!hasOwnProperty(self.object[association].__proto__, 'toJSON')) return;\n    self.object[association] = self.object[association].toJSON();\n  });\n\n};\n\n/**\n * Remove Non-Joined Associations\n *\n * @api private\n */\n\ntoObject.prototype.filterJoins = function() {\n  var attributes = this.context._attributes;\n  var properties = this.proto._properties;\n\n  for (var attribute in attributes) {\n    if (!hasOwnProperty(attributes[attribute], 'model') && !hasOwnProperty(attributes[attribute], 'collection')) continue;\n\n    // If no properties and a collection attribute, delete the association and return\n    if (!properties && hasOwnProperty(attributes[attribute], 'collection')) {\n      delete this.object[attribute];\n      continue;\n    }\n\n    // If showJoins is false remove the association object\n    if (properties && !properties.showJoins) {\n\n      // Don't delete belongs to keys\n      if (!attributes[attribute].model) delete this.object[attribute];\n    }\n\n    if (properties && properties.joins) {\n      if (this.usedJoins.indexOf(attribute) < 0) {\n\n        // Don't delete belongs to keys\n        if (!attributes[attribute].model) delete this.object[attribute];\n      }\n    }\n  }\n};\n\n/**\n * Filter Functions\n *\n * @api private\n */\n\ntoObject.prototype.filterFunctions = function() {\n  for (var key in this.object) {\n    if (typeof this.object[key] === 'function') {\n      delete this.object[key];\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/defaultMethods/destroy.js":"\n/**\n * Module dependencies\n */\n\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\nvar defer = require('../../../utils/defer');\nvar noop = function() {};\n\n/**\n * Model.destroy()\n *\n * Destroys an instance of a model\n *\n * @param {Object} context,\n * @param {Object} proto\n * @param {Function} callback\n * @return {Promise}\n * @api public\n */\n\nvar Destroy = module.exports = function(context, proto, cb) {\n\n  var deferred;\n  var err;\n\n  if (typeof cb !== 'function') {\n    deferred = defer();\n  }\n\n  cb = cb || noop;\n\n  var values = proto.toObject();\n  var attributes = context.waterline.schema[context.identity].attributes;\n  var primaryKey = this.findPrimaryKey(attributes, values);\n\n  if (!primaryKey) {\n    err = new Error('No Primary Key set to update the record with! ' +\n    'Try setting an attribute as a primary key or include an ID property.');\n\n    if (deferred) {\n      deferred.reject(err);\n    }\n\n    return cb(err);\n  }\n\n  if (!values[primaryKey]) {\n    err = new Error('No Primary Key set to update the record with! ' +\n    'Primary Key must have a value, it can\\'t be an optional value.');\n\n    if (deferred) {\n      deferred.reject(err);\n    }\n\n    return cb(err);\n  }\n\n  // Build Search Criteria\n  var criteria = {};\n  criteria[primaryKey] = values[primaryKey];\n\n  // Execute Query\n  context.destroy(criteria, function(err, status) {\n    if (err) {\n\n      if (deferred) {\n        deferred.reject(err);\n      }\n\n      return cb(err);\n    }\n\n    if (deferred) {\n      deferred.resolve(status);\n    }\n\n    cb.apply(this, arguments);\n  });\n\n  if (deferred) {\n    return deferred.promise;\n  }\n};\n\n/**\n * Find Primary Key\n *\n * @param {Object} attributes\n * @param {Object} values\n * @api private\n */\n\nDestroy.prototype.findPrimaryKey = function(attributes, values) {\n  var primaryKey = null;\n\n  for (var attribute in attributes) {\n    if (hasOwnProperty(attributes[attribute], 'primaryKey') && attributes[attribute].primaryKey) {\n      primaryKey = attribute;\n      break;\n    }\n  }\n\n  // If no primary key check for an ID property\n  if (!primaryKey && hasOwnProperty(values, 'id')) primaryKey = 'id';\n\n  return primaryKey;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/defer.js":"var Promise = require('bluebird');\n\nmodule.exports = function defer() {\n  var resolve, reject;\n\n  var promise = new Promise(function() {\n    resolve = arguments[0];\n    reject = arguments[1];\n  });\n\n  return {\n    resolve: resolve,\n    reject: reject,\n    promise: promise\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/defaultMethods/save.js":"var _ = require('lodash');\nvar async = require('async');\nvar deep = require('deep-diff');\nvar updateInstance = require('../associationMethods/update');\nvar addAssociation = require('../associationMethods/add');\nvar removeAssociation = require('../associationMethods/remove');\nvar hop = require('../../../utils/helpers').object.hasOwnProperty;\nvar defer = require('../../../utils/defer');\nvar WLError = require('../../../error/WLError');\nvar noop = function() {};\n\n/**\n * Model.save()\n *\n * Takes the currently set attributes and updates the database.\n * Shorthand for Model.update({ attributes }, cb)\n *\n * @param {Object} context\n * @param {Object} proto\n * @param {Function} callback\n * @param {Object} options\n * @return {Promise}\n * @api public\n */\n\nmodule.exports = function(context, proto, options, cb) {\n\n  var deferred;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (typeof cb !== 'function') {\n    deferred = defer();\n  }\n\n  cb = cb || noop;\n\n  /**\n   * TO-DO:\n   * This should all be wrapped in a transaction. That's coming next but for the meantime\n   * just hope we don't get in a nasty state where the operation fails!\n   */\n\n  var mutatedModels = [];\n\n  async.auto({\n\n    // Compare any populated model values to their current state.\n    // If they have been mutated then the values will need to be synced.\n    compareModelValues: function(next) {\n      var modelKeys = Object.keys(proto.associationsCache);\n\n      async.each(modelKeys, function(key, nextKey) {\n        if (!hop(proto, key) || proto[key] === undefined) {\n          return async.setImmediate(function() {\n            nextKey();\n          });\n        }\n\n        var currentVal = proto[key];\n        var previousVal = proto.associationsCache[key];\n\n        // Normalize previousVal to an object\n        if (Array.isArray(previousVal)) {\n          previousVal = previousVal[0];\n        }\n\n        if (deep(currentVal, previousVal)) {\n          mutatedModels.push(key);\n        }\n\n        return async.setImmediate(function() {\n          nextKey();\n        });\n      }, next);\n    },\n\n    // Update The Current Record\n    updateRecord: ['compareModelValues', function(next) {\n\n      // Shallow clone proto.toObject() to remove all the functions\n      var data = _.clone(proto.toObject());\n\n      new updateInstance(context, data, mutatedModels, function(err, data) {\n        next(err, data);\n      });\n    }],\n\n\n    // Build a set of associations to add and remove.\n    // These are populated from using model[associationKey].add() and\n    // model[associationKey].remove().\n    buildAssociationOperations: ['compareModelValues', function(next) {\n\n      // Build a dictionary to hold operations based on association key\n      var operations = {\n        addKeys: {},\n        removeKeys: {}\n      };\n\n      Object.keys(proto.associations).forEach(function(key) {\n\n        // Ignore belongsTo associations\n        if (proto.associations[key].hasOwnProperty('model')) return;\n\n        // Grab what records need adding\n        if (proto.associations[key].addModels.length > 0) {\n          operations.addKeys[key] = proto.associations[key].addModels;\n        }\n\n        // Grab what records need removing\n        if (proto.associations[key].removeModels.length > 0) {\n          operations.removeKeys[key] = proto.associations[key].removeModels;\n        }\n      });\n\n      return async.setImmediate(function() {\n        return next(null, operations);\n      });\n\n    }],\n\n    // Create new associations for each association key\n    addAssociations: ['buildAssociationOperations', 'updateRecord', function(next, results) {\n      var keys = results.buildAssociationOperations.addKeys;\n      return new addAssociation(context, proto, keys, function(err, failedTransactions) {\n        if (err) return next(err);\n\n        // reset addKeys\n        for (var key in results.buildAssociationOperations.addKeys) {\n          proto.associations[key].addModels = [];\n        }\n\n        next(null, failedTransactions);\n      });\n    }],\n\n    // Remove associations for each association key\n    // Run after the addAssociations so that the connection pools don't get exhausted.\n    // Once transactions are ready we can remove this restriction as they will be run on the same\n    // connection.\n    removeAssociations: ['buildAssociationOperations', 'addAssociations', function(next, results) {\n      var keys = results.buildAssociationOperations.removeKeys;\n      return new removeAssociation(context, proto, keys, function(err, failedTransactions) {\n        if (err) return next(err);\n\n        // reset removeKeys\n        for (var key in results.buildAssociationOperations.removeKeys) {\n          proto.associations[key].removeModels = [];\n        }\n\n        next(null, failedTransactions);\n      });\n    }]\n\n  },\n\n  function(err, results) {\n    if (err) {\n      if (deferred) {\n        deferred.reject(err);\n      }\n      return cb(err);\n    }\n\n    // Collect all failed transactions if any\n    var failedTransactions = [];\n    var error;\n\n    if (results.addAssociations) {\n      failedTransactions = failedTransactions.concat(results.addAssociations);\n    }\n\n    if (results.removeAssociations) {\n      failedTransactions = failedTransactions.concat(results.removeAssociations);\n    }\n\n    if (failedTransactions.length > 0) {\n      error = new Error('Some associations could not be added or destroyed during save().');\n      error.failedTransactions = failedTransactions;\n\n      if (deferred) {\n        deferred.reject(new WLError(error));\n      }\n      return cb(new WLError(error));\n    }\n\n    if (!results.updateRecord.length) {\n      error = new Error('Error updating a record.');\n      if (deferred) {\n        deferred.reject(new WLError(error));\n      }\n      return cb(new WLError(error));\n    }\n\n    // Reset the model attribute values with the new values.\n    // This is needed because you could have a lifecycle callback that has\n    // changed the data since last time you accessed it.\n    // Attach attributes to the model instance\n    var newData = results.updateRecord[0];\n    _.each(newData, function(val, key) {\n      proto[key] = val;\n    });\n\n    // If a promise, resolve it\n    if (deferred) {\n      deferred.resolve();\n    }\n\n    // Return the callback\n    return cb();\n  });\n\n  if (deferred) {\n    return deferred.promise;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/associationMethods/update.js":"\n/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('../../../utils/helpers');\nvar nestedOperations = require('../../../utils/nestedOperations');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Update the current instance with the currently set values\n *\n * Called in the model instance context.\n *\n * @param {Object} collection\n * @param {Object} proto\n * @param {Array} mutatedModels\n * @param {Function} callback\n */\n\nvar Update = module.exports = function(collection, proto, mutatedModels, cb) {\n\n  var values = typeof proto.toObject === 'function' ? proto.toObject() : proto;\n  var attributes = collection.waterline.schema[collection.identity].attributes;\n  var primaryKey = this.findPrimaryKey(attributes, values);\n\n  if (!primaryKey) {\n    return cb(new Error('No Primary Key set to update the record with! ' +\n      'Try setting an attribute as a primary key or include an ID property.'));\n  }\n\n  if (!values[primaryKey]) {\n    return cb(new Error('No Primary Key set to update the record with! ' +\n      'Primary Key must have a value, it can\\'t be an optional value.'));\n  }\n\n  // Build Search Criteria\n  var criteria = {};\n  criteria[primaryKey] = values[primaryKey];\n\n  // Clone values so they can be mutated\n  var _values = _.cloneDeep(values);\n\n  // For any nested model associations (objects not collection arrays) that were not changed,\n  // lets set the value to just the foreign key so that an update query is not performed on the\n  // associatied model.\n  var keys = _.keys(_values);\n  keys.forEach(function(key) {\n\n    // Nix any collection attributes so that they do not get sync'd during the update process.\n    // One reason for this is that the result set is not guaranteed to be complete,\n    // so the sync could exclude items.\n    if (attributes[key] && hop(attributes[key], 'collection') && attributes[key].collection) {\n\n      delete _values[key];\n      return;\n    }\n\n    // If the key was changed, keep it expanded\n    if (mutatedModels.indexOf(key) !== -1) return;\n\n    // Reduce it down to a foreign key value\n    var vals = {};\n    vals[key] = _values[key];\n\n    // Delete and replace the value with a reduced version\n    delete _values[key];\n    var reduced = nestedOperations.reduceAssociations.call(collection, collection.identity, collection.waterline.schema, vals);\n    _values = _.merge(_values, reduced);\n  });\n\n  // Update the collection with the new values\n  collection.update(criteria, _values, cb);\n};\n\n\n/**\n * Find Primary Key\n *\n * @param {Object} attributes\n * @param {Object} values\n * @api private\n */\n\nUpdate.prototype.findPrimaryKey = function(attributes, values) {\n  var primaryKey = null;\n\n  for (var attribute in attributes) {\n    if (hop(attributes[attribute], 'primaryKey') && attributes[attribute].primaryKey) {\n      primaryKey = attribute;\n      break;\n    }\n  }\n\n  // If no primary key check for an ID property\n  if (!primaryKey && hop(values, 'id')) primaryKey = 'id';\n\n  return primaryKey;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/nestedOperations/index.js":"/**\n * Handlers for parsing nested associations within create/update values.\n */\n\nmodule.exports = {\n  reduceAssociations: require('./reduceAssociations'),\n  valuesParser: require('./valuesParser'),\n  create: require('./create'),\n  update: require('./update')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/nestedOperations/reduceAssociations.js":"/**\n * Module Dependencies\n */\n\nvar hop = require('../helpers').object.hasOwnProperty;\nvar _ = require('lodash');\nvar assert = require('assert');\nvar util = require('util');\n\n/**\n * Traverse an object representing values replace associated objects with their\n * foreign keys.\n *\n * @param {String} model\n * @param {Object} schema\n * @param {Object} values\n * @return {Object}\n * @api private\n */\n\n\nmodule.exports = function(model, schema, values, method) {\n  var self = this;\n\n  Object.keys(values).forEach(function(key) {\n\n    // Check to see if this key is a foreign key\n    var attribute = schema[model].attributes[key];\n\n    // If not a plainObject, check if this is a model instance and has a toObject method\n    if (!_.isPlainObject(values[key])) {\n      if (_.isObject(values[key]) && !Array.isArray(values[key]) && values[key].toObject && typeof values[key].toObject === 'function') {\n        values[key] = values[key].toObject();\n      } else {\n        return;\n      }\n    }\n    // Check that this user-specified value is not NULL\n    if (values[key] === null) return;\n\n    // Check that this user-specified value actually exists\n    // as an attribute in `model`'s schema.\n    // If it doesn't- just ignore it\n    if (typeof attribute !== 'object') return;\n\n    if (!hop(values[key], attribute.on)) return;\n\n    // Look and see if the related model has a custom primary key AND that\n    // the intended method is \"create\"\n    var related = self.waterline.collections[attribute.references];\n    var relatedPK = _.find(related.attributes, { primaryKey: true });\n\n    // If a custom PK was used and it's not autoIncrementing and the record\n    // is being created then go ahead and don't reduce it. This allows nested\n    // creates to work when custom PK's are used.\n    if (!relatedPK.autoIncrement && !related.autoPK && method && (method == 'create' || method == 'update')) {\n      return;\n    }\n\n    // Otherwise reduce the association like normal\n    var fk = values[key][attribute.on];\n    values[key] = fk;\n\n  });\n\n  return values;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/nestedOperations/valuesParser.js":"/**\n * Module Dependencies\n */\n\nvar hasOwnProperty = require('../helpers').object.hasOwnProperty;\n\n/**\n * Traverse an object representing values and map out any associations.\n *\n * @param {String} model\n * @param {Object} schema\n * @param {Object} values\n * @return {Object}\n * @api private\n */\n\n\nmodule.exports = function(model, schema, values) {\n  var self = this;\n\n  // Pick out the top level associations\n  var associations = {\n    collections: [],\n    models: []\n  };\n\n  Object.keys(values).forEach(function(key) {\n\n    // Ignore values equal to null\n    if (values[key] === null) return;\n\n    // Ignore joinTables\n    if (hasOwnProperty(schema[model], 'junctionTable')) return;\n    if (!hasOwnProperty(schema[model].attributes, key)) return;\n\n    var attribute = schema[model].attributes[key];\n    if (!hasOwnProperty(attribute, 'collection') && !hasOwnProperty(attribute, 'foreignKey')) return;\n\n    if (hasOwnProperty(attribute, 'collection')) associations.collections.push(key);\n    if (hasOwnProperty(attribute, 'foreignKey')) associations.models.push(key);\n\n  });\n\n  return associations;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/nestedOperations/create.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar hasOwnProperty = require('../helpers').object.hasOwnProperty;\n\n/**\n * Queue up .add() operations on a model instance for any nested association\n * values in a .create() query.\n *\n * @param {Object} parentModel\n * @param {Object} values\n * @param {Object} associations\n * @param {Function} cb\n * @api private\n */\n\nmodule.exports = function(parentModel, values, associations, cb) {\n  var self = this;\n\n  // For each association, grab the primary key value and normalize into model.add methods\n  associations.forEach(function(association) {\n    var attribute = self.waterline.schema[self.identity].attributes[association];\n    var modelName;\n\n    if (hasOwnProperty(attribute, 'collection')) modelName = attribute.collection;\n\n    if (!modelName) return;\n\n    // Grab the relation's PK\n    var related = self.waterline.collections[modelName];\n    var relatedPK = _.find(related.attributes, { primaryKey: true });\n\n    // Get the attribute's name\n    var pk = self.waterline.collections[modelName].primaryKey;\n\n    var optValues = values[association];\n    if (!optValues) return;\n    if (!_.isArray(optValues)) {\n      optValues = _.isString(optValues) ? optValues.split(',') : [optValues];\n    }\n    optValues.forEach(function(val) {\n\n      // If value is not an object, queue up an add\n      if (!_.isPlainObject(val)) return parentModel[association].add(val);\n\n      // If value is an object, check if a primary key is defined\n      // If a custom PK was used and it's not autoIncrementing and the record\n      // is being created then go ahead and don't reduce it. This allows nested\n      // creates to work when custom PK's are used.\n      if (relatedPK.autoIncrement && related.autoPK && hasOwnProperty(val, pk)) {\n        return parentModel[association].add(val[pk]);\n      } else {\n        parentModel[association].add(val);\n      }\n    });\n  });\n\n  // Save the parent model\n  parentModel.save(cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/nestedOperations/update.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar hop = require('../helpers').object.hasOwnProperty;\n\n\n/**\n * Update nested associations. Will take a values object and perform updating and\n * creating of all the nested associations. It's the same as syncing so it will first\n * remove any associations related to the parent and then \"sync\" the new associations.\n *\n * @param {Array} parents\n * @param {Object} values\n * @param {Object} associations\n * @param {Function} cb\n */\n\nmodule.exports = function(parents, values, associations, cb) {\n\n  var self = this;\n\n  // Combine model and collection associations\n  associations = associations.collections.concat(associations.models);\n\n  // Build up .add and .update operations for each association\n  var operations = buildOperations.call(self, parents, associations, values);\n\n  // Now that our operations are built, lets go through and run any updates.\n  // Then for each parent, find all the current associations and remove them then add\n  // all the new associations in using .add()\n  sync.call(self, parents, operations, cb);\n\n};\n\n\n/**\n * Build Up Operations (add and update)\n *\n * @param {Array} associations\n * @param {Object} values\n * @return {Object}\n */\n\nfunction buildOperations(parents, associations, values) {\n\n  var self = this;\n  var operations = {};\n\n  // For each association, grab the primary key value and normalize into model.add methods\n  associations.forEach(function(association) {\n\n    var optValues = values[association];\n\n    // If values are being nulled out just return. This is used when removing foreign\n    // keys on the parent model.\n    if (optValues === null) return;\n\n    // Pull out any association values that have primary keys, these will need to be updated. All\n    // values can be added for each parent however.\n    operations[association] = {\n      add: [],\n      update: []\n    };\n\n    // Normalize optValues to an array\n    if (!Array.isArray(optValues)) optValues = [optValues];\n    queueOperations.call(self, parents, association, operations[association], optValues);\n  });\n\n  return operations;\n}\n\n/**\n * Queue Up Operations.\n *\n * Takes the array normalized association values and queues up\n * operations for the specific association.\n *\n * @param {String} association\n * @param {Object} operation\n * @param {Array} values\n */\n\nfunction queueOperations(parents, association, operation, values) {\n\n  var self = this;\n  var attribute = self.waterline.schema[self.identity].attributes[association];\n  var modelName;\n\n  if (hop(attribute, 'collection')) modelName = attribute.collection;\n  if (hop(attribute, 'foreignKey')) modelName = attribute.references;\n  if (!modelName) return;\n\n  var collection = self.waterline.collections[modelName];\n\n  // Grab the relation's PK\n  var relatedPK = _.find(collection.attributes, { primaryKey: true });\n  var relatedPkName = collection.primaryKey;\n\n  // If this is a join table, we can just queue up operations on the parent\n  // for this association.\n  if (collection.junctionTable) {\n\n    // For each parent, queue up any .add() operations\n    parents.forEach(function(parent) {\n      values.forEach(function(val) {\n        if (!hop(parent, association)) return;\n        if (typeof parent[association].add !== 'function') return;\n        parent[association].add(val);\n      });\n    });\n\n    return;\n  }\n\n  values.forEach(function(val) {\n\n    // Check the values and see if the model's primary key is given. If so look into\n    // the schema attribute and check if this is a collection or model attribute. If it's\n    // a collection attribute lets update the child record and if it's a model attribute,\n    // update the child and set the parent's foreign key value to the new primary key.\n    //\n    // If a custom PK was used and it's not autoIncrementing add the record. This\n    // allows nested creates to work when custom PK's are used.\n    if (!relatedPK.autoIncrement && !collection.autoPK) {\n      operation.add.push(val);\n      return;\n    }\n\n    // If it's missing a PK queue up an add\n    if (!hop(val, relatedPkName)) {\n      operation.add.push(val);\n      return;\n    }\n\n    // Build up the criteria that will be used to update the child record\n    var criteria = {};\n    criteria[relatedPkName] = val[relatedPkName];\n\n    // Queue up the update operation\n    operation.update.push({ model: modelName, criteria: criteria, values: val });\n\n    // Check if the parents foreign key needs to be updated\n    if (!hop(attribute, 'foreignKey')) {\n      operation.add.push(val[relatedPkName]);\n      return;\n    }\n\n    // Set the new foreign key value for each parent\n    parents.forEach(function(parent) {\n      parent[association] = val[relatedPkName];\n    });\n\n  });\n}\n\n/**\n * Sync Associated Data\n *\n * Using the operations, lets go through and run any updates on any nested object with\n * primary keys. This ensures that all the data passed up is persisted. Then for each parent,\n * find all the current associations and unlink them and then add all the new associations\n * in using .add(). This ensures that whatever is passed in to an update is what the value will\n * be when queried again.\n *\n * @param {Object} operations\n * @param {Function} cb\n */\n\nfunction sync(parents, operations, cb) {\n  var self = this;\n\n  async.auto({\n\n    // Update any nested associations\n    update: function(next) {\n      updateRunner.call(self, parents, operations, next);\n    },\n\n    // For each parent, unlink all the associations currently set\n    unlink: ['update', function(next) {\n      unlinkRunner.call(self, parents, operations, next);\n    }],\n\n    // For each parent found, link any associations passed in by either creating\n    // the new record or linking an existing record\n    link: ['unlink', function(next) {\n      linkRunner.call(self, parents, operations, next);\n    }]\n\n  }, cb);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n// .sync() - Async Auto Runners\n////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Run Update Operations.\n *\n * Uses the information stored in an operation to perform a .update() on the\n * associated model using the new values.\n *\n * @param {Object} operation\n * @param {Function} cb\n */\n\nfunction updateRunner(parents, operations, cb) {\n\n  var self = this;\n\n  // There will be an array of update operations inside of a namespace. Use this to run\n  // an update on the model instance of the association.\n  function associationLoop(association, next) {\n    async.each(operations[association].update, update, next);\n  }\n\n  function update(operation, next) {\n    var model = self.waterline.collections[operation.model];\n    model.update(operation.criteria, operation.values).exec(next);\n  }\n\n  // Operations are namespaced under an association key. So run each association's updates\n  // in parallel for now. May need to be limited in the future but all adapters should\n  // support connection pooling.\n  async.each(Object.keys(operations), associationLoop, cb);\n\n}\n\n\n/**\n * Unlink Associated Records.\n *\n * For each association passed in to the update we are essentially replacing the\n * association's value. In order to do this we first need to clear out any associations\n * that currently exist.\n *\n * @param {Object} operations\n * @param {Function} cb\n */\n\nfunction unlinkRunner(parents, operations, cb) {\n\n  var self = this;\n\n  // Given a parent, build up remove operations and run them.\n  function unlinkParentAssociations(parent, next) {\n    var opts = buildParentRemoveOperations.call(self, parent, operations);\n    removeOperationRunner.call(self, opts, next);\n  }\n\n  async.each(parents, unlinkParentAssociations, cb);\n}\n\n\n/**\n * Link Associated Records\n *\n * Given a set of operations, associate the records with the parent records. This\n * can be done by either creating join table records or by setting foreign keys.\n * It defaults to a parent.add() method for most situations.\n *\n * @param {Object} operations\n * @param {Function} cb\n */\n\nfunction linkRunner(parents, operations, cb) {\n\n  var self = this;\n\n  function linkChildRecords(parent, next) {\n\n    // Queue up `.add()` operations on the parent model and figure out\n    // which records need to be created.\n    //\n    // If an .add() method is available always use it. If this is a nested model an .add()\n    // method won't be available so queue up a create operation.\n    var recordsToCreate = buildParentLinkOperations.call(self, parent, operations);\n\n    // Create the new records and update the parent with the new foreign key\n    // values that may have been set when creating child records.\n    createNewRecords.call(self, parent, recordsToCreate, function(err) {\n      if (err) return next(err);\n      updateParentRecord(parent, cb);\n    });\n  }\n\n  // Update the parent record one last time. This ensures a model attribute (single object)\n  // on the parent can create a new record and then set the parent's foreign key value to\n  // the newly created child record's primary key.\n  //\n  // Example:\n  // Parent.update({\n  //   name: 'foo',\n  //   nestedModel: {\n  //     name: 'bar'\n  //   }\n  // })\n  //\n  // The above query would create the new nested model and then set the parent's nestedModel\n  // value to the newly created model's primary key.\n  //\n  // We then run a .save() to persist any .add() records that may have been used. The update and\n  // .save() are used instead of a find and then save because it's the same amount of queries\n  // and it's easier to take advantage of all that the .add() method gives us.\n  //\n  //\n  // TO-DO:\n  // Make this much smarter to reduce the amount of queries that need to be run. We should probably\n  // be able to at least cut this in half!\n  //\n  function updateParentRecord(parent, next) {\n\n    var criteria = {};\n    var model = self.waterline.collections[self.identity];\n\n    criteria[self.primaryKey] = parent[self.primaryKey];\n    var pValues = parent.toObject();\n\n    model.update(criteria, pValues).exec(function(err) {\n      if (err) return next(err);\n\n      // Call .save() to persist any .add() functions that may have been used.\n      parent.save(next);\n    });\n  }\n\n  async.each(parents, linkChildRecords, cb);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n// .sync() - Helper Functions\n////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Build up operations for performing unlinks.\n *\n * Given a parent and a set of operations, queue up operations to either\n * remove join table records or null out any foreign keys on an child model.\n *\n * @param {Object} parent\n * @param {Object} operations\n * @return {Array}\n */\n\nfunction buildParentRemoveOperations(parent, operations) {\n\n  var self = this;\n  var opts = [];\n\n  // Inspect the association and see if this relationship has a joinTable.\n  // If so create an operation criteria that clears all matching records from the\n  // table. If it doesn't have a join table, build an operation criteria that\n  // nulls out the foreign key on matching records.\n  Object.keys(operations).forEach(function(association) {\n\n    var criteria = {};\n    var searchCriteria = {};\n    var attribute = self.waterline.schema[self.identity].attributes[association];\n\n    /////////////////////////////////////////////////////////////////////////\n    // Parent Record:\n    // If the foreign key is stored on the parent side, null it out\n    /////////////////////////////////////////////////////////////////////////\n\n    if (hop(attribute, 'foreignKey')) {\n\n      // Set search criteria where primary key is equal to the parents primary key\n      searchCriteria[self.primaryKey] = parent[self.primaryKey];\n\n      // Store any information we may need to build up an operation.\n      // Use the `nullify` key to show we want to perform an update and not a destroy.\n      criteria = {\n        model: self.identity,\n        criteria: searchCriteria,\n        keyName: association,\n        nullify: true\n      };\n\n      opts.push(criteria);\n      return;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Child Record:\n    // Lookup the attribute on the other side of the association on in the\n    // case of a m:m association the child table will be the join table.\n    /////////////////////////////////////////////////////////////////////////\n\n    var child = self.waterline.schema[attribute.collection];\n    var childAttribute = child.attributes[attribute.onKey];\n\n    // Set the search criteria to use the collection's `via` key and the parent's primary key.\n    searchCriteria[attribute.on] = parent[self.primaryKey];\n\n    // If the childAttribute stores the foreign key, find all children with the\n    // foreignKey equal to the parent's primary key and null them out or in the case of\n    // a `junctionTable` flag destroy them.\n    if (hop(childAttribute, 'foreignKey')) {\n\n      // Store any information needed to perform the query. Set nullify to false if\n      // a `junctionTable` property is found.\n      criteria = {\n        model: child.identity,\n        criteria: searchCriteria,\n        keyName: attribute.on,\n        nullify: !hop(child, 'throughTable')\n      };\n\n\n      opts.push(criteria);\n      return;\n    }\n  });\n\n  return opts;\n}\n\n\n/**\n * Remove Operation Runner\n *\n * Given a criteria object matching a remove operation, perform the\n * operation using waterline collection instances.\n *\n * @param {Array} operations\n * @param {Function} callback\n */\n\nfunction removeOperationRunner(operations, cb) {\n\n  var self = this;\n\n  function runner(operation, next) {\n    var values = {};\n\n    // If nullify is false, run a destroy method using the criteria to destroy\n    // the join table records.\n    if (!operation.nullify) {\n      self.waterline.collections[operation.model].destroy(operation.criteria).exec(next);\n      return;\n    }\n\n    // Run an update operation to set the foreign key to null on all the\n    // associated child records.\n    values[operation.keyName] = null;\n\n    self.waterline.collections[operation.model].update(operation.criteria, values).exec(next);\n  }\n\n\n  // Run the operations\n  async.each(operations, runner, cb);\n}\n\n\n/**\n * Build up operations for performing links.\n *\n * Given a parent and a set of operations, queue up operations to associate two\n * records together. This could be using the parent's `.add()` method which handles\n * the logic for us or building up a `create` operation that we can run to create the\n * associated record with the correct foreign key set.\n *\n * @param {Object} parent\n * @param {Object} operations\n * @return {Object}\n */\n\nfunction buildParentLinkOperations(parent, operations) {\n\n  var recordsToCreate = {};\n\n  // Determine whether to use the parent association's `.add()` function\n  // or whether to queue up a create operation.\n  function determineOperation(association, opt) {\n\n    // Check if the association has an `add` method, if so use it.\n    if (hop(parent[association], 'add')) {\n      parent[association].add(opt);\n      return;\n    }\n\n    recordsToCreate[association] = recordsToCreate[association] || [];\n    recordsToCreate[association].push(opt);\n  }\n\n  // For each operation look at all the .add operations and determine\n  // what to do with them.\n  Object.keys(operations).forEach(function(association) {\n    operations[association].add.forEach(function(opt) {\n      determineOperation(association, opt);\n    });\n  });\n\n  return recordsToCreate;\n}\n\n\n/**\n * Create New Records.\n *\n * Given an object of association records to create, perform a create\n * on the child model and set the parent's foreign key to the newly\n * created record's primary key.\n *\n * @param {Object} parent\n * @param {Object} recordsToCreate\n * @param {Function} cb\n */\n\nfunction createNewRecords(parent, recordsToCreate, cb) {\n\n  var self = this;\n\n  // For each association, run the createRecords function\n  // in the model context.\n  function mapAssociations(association, next) {\n\n    // First, pull the model attribute's referenced (foreign) collection\n    var attribute = self.waterline.schema[self.identity].attributes[association];\n    var referencedCollection = attribute.references;\n\n    var model = self.waterline.collections[referencedCollection];\n    var records = recordsToCreate[association];\n\n    function createRunner(record, nextRecord) {\n      var args = [parent, association, record, nextRecord];\n      createRecord.apply(model, args);\n    }\n\n    async.each(records, createRunner, next);\n  }\n\n  // Create a record and set the parent's foreign key to the\n  // newly created record's primary key.\n  function createRecord(parent, association, record, next) {\n    var self = this;\n\n    this.create(record).exec(function(err, val) {\n      if (err) return next(err);\n      parent[association] = val[self.primaryKey];\n      next();\n    });\n  }\n\n\n  async.each(Object.keys(recordsToCreate), mapAssociations, cb);\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/associationMethods/add.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Add associations for a model.\n *\n * If an object was used a new record should be created and linked to the parent.\n * If only a primary key was used then the record should only be linked to the parent.\n *\n * Called in the model instance context.\n *\n * @param {Object} collection\n * @param {Object} proto\n * @param {Object} records\n * @param {Function} callback\n */\n\nvar Add = module.exports = function(collection, proto, records, cb) {\n\n  this.collection = collection;\n  this.proto = proto;\n  this.failedTransactions = [];\n  this.primaryKey = null;\n\n  var values = proto.toObject();\n  var attributes = collection.waterline.schema[collection.identity].attributes;\n\n  this.primaryKey = this.findPrimaryKey(attributes, values);\n\n  if (!this.primaryKey) {\n    return cb(new Error('No Primary Key set to associate the record with! ' +\n      'Try setting an attribute as a primary key or include an ID property.'));\n  }\n\n  if (!proto.toObject()[this.primaryKey]) {\n    return cb(new Error('No Primary Key set to associate the record with! ' +\n      'Primary Key must have a value, it can\\'t be an optional value.'));\n  }\n\n  // Loop through each of the associations on this model and add any associations\n  // that have been specified. Do this in series and limit the actual saves to 10\n  // at a time so that connection pools are not exhausted.\n  //\n  // In the future when transactions are available this will all be done on a single\n  // connection and can be re-written.\n\n  this.createCollectionAssociations(records, cb);\n};\n\n/**\n * Find Primary Key\n *\n * @param {Object} attributes\n * @param {Object} values\n * @api private\n */\n\nAdd.prototype.findPrimaryKey = function(attributes, values) {\n  var primaryKey = null;\n\n  for (var attribute in attributes) {\n    if (hasOwnProperty(attributes[attribute], 'primaryKey') && attributes[attribute].primaryKey) {\n      primaryKey = attribute;\n      break;\n    }\n  }\n\n  // If no primary key check for an ID property\n  if (!primaryKey && hasOwnProperty(values, 'id')) primaryKey = 'id';\n\n  return primaryKey;\n};\n\n/**\n * Create Collection Associations\n *\n * @param {Object} records\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.createCollectionAssociations = function(records, cb) {\n  var self = this;\n\n  async.eachSeries(Object.keys(records), function(associationKey, next) {\n    self.createAssociations(associationKey, records[associationKey], next);\n  },\n\n  function(err) {\n    if (err || self.failedTransactions.length > 0) {\n      return cb(null, self.failedTransactions);\n    }\n\n    cb();\n  });\n};\n\n/**\n * Create Records for an Association property on a collection\n *\n * @param {String} key\n * @param {Array} records\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.createAssociations = function(key, records, cb) {\n  var self = this;\n\n  // Grab the collection the attribute references\n  // this allows us to make a query on it\n  var attribute = this.collection._attributes[key];\n  var collectionName = attribute.collection.toLowerCase();\n  var associatedCollection = this.collection.waterline.collections[collectionName];\n  var relatedPK = _.find(associatedCollection.attributes, { primaryKey: true });\n  var schema = this.collection.waterline.schema[this.collection.identity].attributes[key];\n\n  // Limit Adds to 10 at a time to prevent the connection pool from being exhausted\n  async.eachLimit(records, 10, function(association, next) {\n\n    // If an object was passed in it should be created.\n    // This allows new records to be created through the association interface\n    if (association !== null && typeof association === 'object' && Object.keys(association).length > 0) {\n\n      // If a custom PK was used on the associated collection and it's not\n      // autoIncrementing, create the record. This allows nested\n      // creates to work when custom PK's are used.\n      if (!relatedPK || !relatedPK.autoIncrement && !associatedCollection.autoPK) {\n        return self.createNewRecord(associatedCollection, schema, association, key, next);\n      }\n\n      // Check if the record contains a primary key, if so just link the values\n      if (hasOwnProperty(association, associatedCollection.primaryKey)) {\n        var pk = associatedCollection.primaryKey;\n        return self.updateRecord(associatedCollection, schema, association[pk], key, next);\n      }\n\n      return self.createNewRecord(associatedCollection, schema, association, key, next);\n    }\n\n    // If the value is a primary key just update the association's foreign key\n    // This will either create the new association through a foreign key or re-associatiate\n    // with another collection.\n    self.updateRecord(associatedCollection, schema, association, key, next);\n\n  }, cb);\n};\n\n/**\n * Create A New Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.createNewRecord = function(collection, attribute, values, key, cb) {\n  var self = this;\n\n  // Check if this is a many-to-many by looking at the junctionTable flag\n  var schema = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var junctionTable = schema.junctionTable || schema.throughTable;\n\n  // If this isn't a many-to-many then add the foreign key in to the values\n  if (!junctionTable) {\n    values[attribute.onKey] = this.proto[this.primaryKey];\n  }\n\n  collection.create(values, function(err, record) {\n    if (err) {\n\n      // If no via was specified and the insert failed on a one-to-many build up an error message that\n      // properly reflects the error.\n      if (!junctionTable && !hasOwnProperty(attribute, 'via')) {\n        err = new Error('You attempted to create a has many relationship but didn\\'t link the two ' +\n          'atttributes together. Please setup a link using the via keyword.');\n      }\n\n      self.failedTransactions.push({\n        type: 'insert',\n        collection: collection.identity,\n        values: values,\n        err: err\n      });\n    }\n\n    // if no junction table then return\n    if (!junctionTable) return cb();\n\n    // if junction table but there was an error don't try and link the records\n    if (err) return cb();\n\n    // Find the collection's Primary Key value\n    var primaryKey = self.findPrimaryKey(collection._attributes, record.toObject());\n\n    if (!primaryKey) {\n      self.failedTransactions.push({\n        type: 'insert',\n        collection: collection.identity,\n        values: {},\n        err: new Error('No Primary Key value was found on the joined collection')\n      });\n    }\n\n    // Find the Many To Many Collection\n    var joinCollection = self.collection.waterline.collections[attribute.collection.toLowerCase()];\n\n    // The related record was created now the record in the junction table\n    // needs to be created to link the two records\n    self.createManyToMany(joinCollection, attribute, record[primaryKey], key, cb);\n  });\n};\n\n/**\n * Update A Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.updateRecord = function(collection, attribute, pk, key, cb) {\n  var self = this;\n\n  // Check if this is a many-to-many by looking at the junctionTable flag\n  var schema = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var junctionTable = schema.junctionTable || schema.throughTable;\n\n  // If so build out the criteria and create a new record in the junction table\n  if (junctionTable) {\n    var joinCollection = this.collection.waterline.collections[attribute.collection.toLowerCase()];\n    return this.createManyToMany(joinCollection, attribute, pk, key, cb);\n  }\n\n  // Grab the associated collection's primaryKey\n  var attributes = this.collection.waterline.schema[collection.identity].attributes;\n  var associationKey = this.findPrimaryKey(attributes, attributes);\n\n  if (!associationKey) {\n    return cb(new Error('No Primary Key defined on the child record you ' +\n      'are trying to associate the record with! Try setting an attribute as a primary key or ' +\n      'include an ID property.'));\n  }\n\n  // Build up criteria and updated values used to update the record\n  var criteria = {};\n  var _values = {};\n\n  criteria[associationKey] = pk;\n  _values[attribute.onKey] = this.proto[this.primaryKey];\n\n  collection.update(criteria, _values, function(err) {\n\n    if (err) {\n      self.failedTransactions.push({\n        type: 'update',\n        collection: collection.identity,\n        criteria: criteria,\n        values: _values,\n        err: err\n      });\n    }\n\n    cb();\n  });\n};\n\n/**\n * Create A Many To Many Join Table Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.createManyToMany = function(collection, attribute, pk, key, cb) {\n  var self = this;\n\n  // Grab the associated collection's primaryKey\n  var collectionAttributes = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var associationKeyAttr = collectionAttributes.attributes[attribute.on] || collectionAttributes.attributes[attribute.via];\n  var associationKey = associationKeyAttr.via;\n\n  // If this is a throughTable, look into the meta data cache for what key to use\n  if (collectionAttributes.throughTable) {\n    var cacheKey = collectionAttributes.throughTable[self.collection.adapter.identity + '.' + key] || collectionAttributes.throughTable[attribute.via + '.' + key];\n    if (!cacheKey) {\n      return cb(new Error('Unable to find the proper cache key in the through table definition'));\n    }\n\n    associationKey = cacheKey;\n  }\n\n  if (!associationKey) {\n    return cb(new Error('No Primary Key set on the child record you ' +\n      'are trying to associate the record with! Try setting an attribute as a primary key or ' +\n      'include an ID property.'));\n  }\n\n  // Build up criteria and updated values used to create the record\n  var criteria = {};\n  var _values = {};\n\n  criteria[associationKey] = pk;\n  criteria[attribute.onKey] = this.proto[this.primaryKey];\n  _values = _.clone(criteria);\n\n  async.auto({\n\n    validateAssociation: function(next) {\n      var associatedCollectionName = collectionAttributes.attributes[associationKey].references;\n      var associatedCollection = self.collection.waterline.collections[associatedCollectionName];\n      var primaryKey = self.findPrimaryKey(associatedCollection.attributes, {});\n      var _criteria = {};\n      _criteria[primaryKey] = pk;\n\n      associatedCollection.findOne(_criteria, function(err, record) {\n        if (err) return next(err);\n        if (!record) {\n          return next(new Error('Associated Record For ' + associatedCollectionName +\n            ' with ' + primaryKey + ' = ' + pk + ' No Longer Exists'));\n        }\n\n        next();\n      });\n    },\n\n    validateRecord: function(next) {\n\n      // First look up the record to ensure it doesn't exist\n      collection.findOne(criteria, function(err, val) {\n        if (err) {\n          return next(err);\n        }\n\n        next(null, val);\n      });\n    },\n\n    createRecord: ['validateAssociation', 'validateRecord', function(next, results) {\n      // If the record already exists, don't try and create it again to prevent\n      // duplicates.\n      var validateRecord = results.validateRecord;\n      if (validateRecord) {\n        return async.setImmediate(function() {\n          next();\n        });\n      }\n\n      collection.create(_values, next);\n    }]\n\n  }, function(err) {\n    if (err) {\n      self.failedTransactions.push({\n        type: 'insert',\n        collection: collection.identity,\n        criteria: criteria,\n        values: _values,\n        err: err\n      });\n    }\n\n    return cb();\n\n  });\n};\n\n/**\n * Find Association Key\n *\n * @param {Object} collection\n * @return {String}\n * @api private\n */\n\nAdd.prototype.findAssociationKey = function(collection) {\n  var associationKey = null;\n\n  for (var attribute in collection.attributes) {\n    var attr = collection.attributes[attribute];\n    var identity = this.collection.identity;\n\n    if (!hasOwnProperty(attr, 'references')) continue;\n    var attrCollection = attr.references;\n\n    if (attrCollection !== identity) {\n      associationKey = attr.columnName;\n    }\n  }\n\n  return associationKey;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/associationMethods/remove.js":"var _ = require('lodash');\nvar async = require('async');\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Remove associations from a model.\n *\n * Accepts a primary key value of an associated record that already exists in the database.\n *\n *\n * @param {Object} collection\n * @param {Object} proto\n * @param {Object} records\n * @param {Function} callback\n */\n\nvar Remove = module.exports = function(collection, proto, records, cb) {\n\n  this.collection = collection;\n  this.proto = proto;\n  this.failedTransactions = [];\n  this.primaryKey = null;\n\n  var values = proto.toObject();\n  var attributes = collection.waterline.schema[collection.identity].attributes;\n\n  this.primaryKey = this.findPrimaryKey(attributes, values);\n\n  if (!this.primaryKey) {\n    return cb(new Error('No Primary Key set to associate the record with! ' +\n      'Try setting an attribute as a primary key or include an ID property.'));\n  }\n\n  if (!proto.toObject()[this.primaryKey]) {\n    return cb(new Error('No Primary Key set to associate ' +\n      'the record with! Primary Key must have a value, it can\\'t be an optional value.'));\n  }\n\n  // Loop through each of the associations on this model and remove any associations\n  // that have been specified. Do this in series and limit the actual saves to 10\n  // at a time so that connection pools are not exhausted.\n  //\n  // In the future when transactions are available this will all be done on a single\n  // connection and can be re-written.\n  this.removeCollectionAssociations(records, proto, cb);\n};\n\n/**\n * Find Primary Key\n *\n * @param {Object} attributes\n * @param {Object} values\n * @api private\n */\n\nRemove.prototype.findPrimaryKey = function(attributes, values) {\n  var primaryKey = null;\n\n  for (var attribute in attributes) {\n    if (hasOwnProperty(attributes[attribute], 'primaryKey') && attributes[attribute].primaryKey) {\n      primaryKey = attribute;\n      break;\n    }\n  }\n\n  // If no primary key check for an ID property\n  if (!primaryKey && hasOwnProperty(values, 'id')) primaryKey = 'id';\n\n  return primaryKey;\n};\n\n/**\n * Remove Collection Associations\n *\n * @param {Object} records\n * @param {Function} callback\n * @api private\n */\n\nRemove.prototype.removeCollectionAssociations = function(records, proto, cb) {\n  var self = this;\n\n  async.eachSeries(_.keys(records), function(associationKey, next) {\n    self.removeAssociations(associationKey, records[associationKey], proto, next);\n  },\n\n  function(err) {\n    if (err || self.failedTransactions.length > 0) {\n      return cb(null, self.failedTransactions);\n    }\n\n    cb();\n  });\n};\n\n/**\n * Remove Associations\n *\n * @param {String} key\n * @param {Array} records\n * @param {Function} callback\n * @api private\n */\n\nRemove.prototype.removeAssociations = function(key, records, proto, cb) {\n  var self = this;\n\n  // Grab the collection the attribute references\n  // this allows us to make a query on it\n  var attribute = this.collection._attributes[key];\n  var collectionName = attribute.collection.toLowerCase();\n  var associatedCollection = this.collection.waterline.collections[collectionName];\n  var schema = this.collection.waterline.schema[this.collection.identity].attributes[key];\n\n  // Limit Removes to 10 at a time to prevent the connection pool from being exhausted\n  async.eachLimit(records, 10, function(associationId, next) {\n    self.removeRecord(associatedCollection, schema, associationId, key, proto, next);\n  }, cb);\n\n};\n\n/**\n * Remove A Single Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nRemove.prototype.removeRecord = function(collection, attribute, associationId, key, proto, cb) {\n  var self = this;\n\n  // Validate `values` is a correct primary key format\n  var validAssociationKey = this.validatePrimaryKey(associationId);\n\n  if (!validAssociationKey) {\n    this.failedTransactions.push({\n      type: 'remove',\n      collection: collection.identity,\n      values: associationId,\n      err: new Error('Remove association only accepts a single primary key value')\n    });\n\n    return cb();\n  }\n\n  // Check if this is a many-to-many by looking at the junctionTable flag\n  var schema = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var junctionTable = schema.junctionTable || schema.throughTable;\n\n  // If so build out the criteria and remove a record from the junction table\n  if (junctionTable) {\n    var joinCollection = this.collection.waterline.collections[attribute.collection.toLowerCase()];\n    return this.removeManyToMany(joinCollection, attribute, associationId, key, cb);\n  }\n\n  // Grab the associated collection's primaryKey\n  var attributes = this.collection.waterline.schema[collection.identity].attributes;\n  var associationKey = this.findPrimaryKey(attributes, attributes);\n\n  if (!associationKey) {\n    return cb(new Error('No Primary Key defined on the child record you ' +\n      'are trying to un-associate the record with! Try setting an attribute as a primary key or ' +\n      'include an ID property.'));\n  }\n\n  // Build up criteria and updated values used to update the record\n  var criteria = {};\n  var _values = {};\n\n  criteria[associationKey] = associationId;\n  criteria[attribute.on] = proto.id;\n  _values[attribute.on] = null;\n\n  collection.update(criteria, _values, function(err) {\n\n    if (err) {\n      self.failedTransactions.push({\n        type: 'update',\n        collection: collection.identity,\n        criteria: criteria,\n        values: _values,\n        err: err\n      });\n    }\n\n    cb();\n  });\n};\n\n/**\n * Validate A Primary Key\n *\n * Only support primary keys being passed in to the remove function. Check if it's a mongo\n * id or anything that has a toString method.\n *\n * @param {Integer|String} key\n * @return {Boolean}\n * @api private\n */\n\nRemove.prototype.validatePrimaryKey = function(key) {\n  var validAssociation = false;\n\n  // Attempt to see if the value is an ID and resembles a MongoID\n  if (_.isString(key) && utils.matchMongoId(key)) validAssociation = true;\n\n  // Check it can be turned into a string\n  if (key && key.toString() !== '[object Object]') validAssociation = true;\n\n  return validAssociation;\n};\n\n/**\n * Remove A Many To Many Join Table Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nRemove.prototype.removeManyToMany = function(collection, attribute, pk, key, cb) {\n  var self = this;\n\n  // Grab the associated collection's primaryKey\n  var collectionAttributes = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var associationKeyAttr = collectionAttributes.attributes[attribute.on] || collectionAttributes.attributes[attribute.via];\n  var associationKey = associationKeyAttr.via;\n\n  // If this is a throughTable, look into the meta data cache for what key to use\n  if (collectionAttributes.throughTable) {\n    var cacheKey = collectionAttributes.throughTable[self.collection.adapter.identity + '.' + key] || collectionAttributes.throughTable[attribute.via + '.' + key];\n    if (!cacheKey) {\n      return cb(new Error('Unable to find the proper cache key in the through table definition'));\n    }\n\n    associationKey = cacheKey;\n  }\n\n  if (!associationKey) {\n    return cb(new Error('No Primary Key set on the child record you ' +\n      'are trying to associate the record with! Try setting an attribute as a primary key or ' +\n      'include an ID property.'));\n  }\n\n  // Build up criteria and updated values used to create the record\n  var criteria = {};\n  criteria[associationKey] = pk;\n  criteria[attribute.on] = this.proto[this.primaryKey];\n\n  // Run a destroy on the join table record\n  collection.destroy(criteria, function(err) {\n\n    if (err) {\n      self.failedTransactions.push({\n        type: 'destroy',\n        collection: collection.identity,\n        criteria: criteria,\n        err: err\n      });\n    }\n\n    cb();\n  });\n};\n\n/**\n * Find Association Key\n *\n * @param {Object} collection\n * @return {String}\n * @api private\n */\n\nRemove.prototype.findAssociationKey = function(collection) {\n  var associationKey = null;\n\n  for (var attribute in collection.attributes) {\n    var attr = collection.attributes[attribute];\n    var identity = this.collection.identity;\n\n    if (!hasOwnProperty(attr, 'references')) continue;\n    var attrCollection = attr.references.toLowerCase();\n\n    if (attrCollection !== identity) {\n      associationKey = attr.columnName;\n    }\n  }\n\n  return associationKey;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/error/WLError.js":"var util = require('util');\nvar _ = require('lodash');\n\n/**\n * WLError\n *\n * All errors passed to a query callback in Waterline extend\n * from this base error class.\n *\n * @param  {Object} properties\n * @constructor {WLError}\n */\nfunction WLError(properties) {\n  WLError.super_.call(this);\n\n  // Fold defined properties into the new WLError instance.\n  properties || (properties = { });\n  _.extend(this, properties);\n\n  // Generate stack trace\n  // (or use `originalError` if it is a true error instance)\n  if (_.isObject(this.originalError) && this.originalError instanceof Error) {\n    this._e = this.originalError;\n  } else {\n    this._e = new Error();\n  }\n\n  // Doctor up a modified version of the stack trace called `rawStack`:\n  this.rawStack = (this._e.stack.replace(/^Error(\\r|\\n)*(\\r|\\n)*/, ''));\n\n  // Customize `details`:\n  // Try to dress up the wrapped \"original\" error as much as possible.\n  // @type {String} a detailed explanation of this error\n  if (_.isString(this.originalError)) {\n    this.details = this.originalError;\n\n  // Run toString() on Errors:\n  } else if (this.originalError && util.isError(this.originalError)) {\n    this.details = this.originalError.toString();\n\n  // But for other objects, use util.inspect()\n  } else if (this.originalError) {\n    this.details = util.inspect(this.originalError);\n  }\n\n  // If `details` is set, prepend it with \"Details:\"\n  if (this.details) {\n    this.details = 'Details:  ' + this.details + '\\n';\n  }\n}\n\nutil.inherits(WLError, Error);\n\n// Default properties\nWLError.prototype.status = 500;\nWLError.prototype.code = 'E_UNKNOWN';\nWLError.prototype.reason = 'Encountered an unexpected error';\nWLError.prototype.details = '';\n\n/**\n * Override JSON serialization.\n * (i.e. when this error is passed to `res.json()` or `JSON.stringify`)\n *\n * For example:\n * ```json\n * {\n *   status: 500,\n *   code: 'E_UNKNOWN'\n * }\n * ```\n *\n * @return {Object}\n */\nWLError.prototype.toJSON =\nWLError.prototype.toPOJO =\nfunction() {\n  var obj = {\n    error: this.code,\n    status: this.status,\n    summary: this.reason,\n    raw: this.originalError\n  };\n\n  // Only include `raw` if its truthy.\n  if (!obj.raw) delete obj.raw;\n\n  return obj;\n};\n\n/**\n * Override output for `sails.log[.*]`\n *\n * @return {String}\n *\n * For example:\n * ```sh\n * Waterline: ORM encountered an unexpected error:\n * { ValidationError: { name: [ [Object], [Object] ] } }\n * ```\n */\nWLError.prototype.toLog = function() {\n  return this.inspect();\n};\n\n/**\n * Override output for `util.inspect`\n * (also when this error is logged using `console.log`)\n *\n * @return {String}\n */\nWLError.prototype.inspect = function() {\n  return util.format('Error (%s) :: %s\\n%s\\n\\n%s', this.code, this.reason, this.rawStack, this.details);\n};\n\n/**\n * @return {String}\n */\nWLError.prototype.toString = function() {\n  return util.format('[Error (%s) %s]', this.code, this.reason, this.details);\n};\n\nObject.defineProperties(WLError.prototype, {\n  stack: {\n    enumerable: true,\n    get: function() {\n      return util.format('Error (%s) :: %s\\n%s', this.code, this.reason, this.rawStack);\n    },\n    set: function(value) {\n      this.rawStack = value;\n    }\n  },\n  message: {\n    enumerable: true,\n    get: function() {\n      return this.rawMessage || this.toString();\n    },\n    set: function(value) {\n      this.rawMessage = value;\n    }\n  }\n});\n\nmodule.exports = WLError;\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/internalMethods/index.js":"\n/**\n * Export Internal Methods\n */\n\nmodule.exports = {\n  normalizeAssociations: require('./normalizeAssociations'),\n  defineAssociations: require('./defineAssociations')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/internalMethods/normalizeAssociations.js":"\n/**\n * Check and normalize belongs_to and has_many association keys\n *\n * Ensures that a belongs_to association is an object and that a has_many association\n * is an array.\n *\n * @param {Object} context,\n * @param {Object} proto\n * @api private\n */\n\nvar Normalize = module.exports = function(context, proto) {\n\n  this.proto = proto;\n\n  var attributes = context.waterline.collections[context.identity].attributes || {};\n\n  this.collections(attributes);\n  this.models(attributes);\n};\n\n/**\n * Normalize Collection Attribute to Array\n *\n * @param {Object} attributes\n * @api private\n */\n\nNormalize.prototype.collections = function(attributes) {\n  for (var attribute in attributes) {\n\n    // If attribute is not a collection, it doesn't need normalizing\n    if (!attributes[attribute].collection) continue;\n\n    // Sets the attribute as an array if it's not already\n    if (this.proto[attribute] && !Array.isArray(this.proto[attribute])) {\n      this.proto[attribute] = [this.proto[attribute]];\n    }\n  }\n};\n\n/**\n * Normalize Model Attribute to Object\n *\n * @param {Object} attributes\n * @api private\n */\n\nNormalize.prototype.models = function(attributes) {\n  for (var attribute in attributes) {\n\n    // If attribute is not a model, it doesn't need normalizing\n    if (!attributes[attribute].model) continue;\n\n    // Sets the attribute to the first item in the array if it's an array\n    if (this.proto[attribute] && Array.isArray(this.proto[attribute])) {\n      this.proto[attribute] = this.proto[attribute][0];\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/internalMethods/defineAssociations.js":"\n/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar Association = require('../association');\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Add association getters and setters for any has_many\n * attributes.\n *\n * @param {Object} context\n * @param {Object} proto\n * @api private\n */\n\nvar Define = module.exports = function(context, proto) {\n  var self = this;\n\n  this.proto = proto;\n\n  // Build Associations Listing\n  Object.defineProperty(proto, 'associations', {\n    enumerable: false,\n    writable: true,\n    value: {}\n  });\n\n  // Build associations cache to hold original values.\n  // Used to check if values have been mutated and need to be synced when\n  // a model.save call is made.\n  Object.defineProperty(proto, 'associationsCache', {\n    enumerable: false,\n    writable: true,\n    value: {}\n  });\n\n  var attributes = context._attributes || {};\n  var collections = this.collectionKeys(attributes);\n  var models = this.modelKeys(attributes);\n\n  if (collections.length === 0 && models.length === 0) return;\n\n  // Create an Association getter and setter for each collection\n  collections.forEach(function(collection) {\n    self.buildHasManyProperty(collection);\n  });\n\n  // Attach Models to the prototype and set in the associations object\n  models.forEach(function(model) {\n    self.buildBelongsToProperty(model);\n  });\n};\n\n/**\n * Find Collection Keys\n *\n * @param {Object} attributes\n * @api private\n * @return {Array}\n */\n\nDefine.prototype.collectionKeys = function(attributes) {\n  var collections = [];\n\n  // Find any collection keys\n  for (var attribute in attributes) {\n    if (!hasOwnProperty(attributes[attribute], 'collection')) continue;\n    collections.push(_.cloneDeep(attribute));\n  }\n\n  return collections;\n};\n\n/**\n * Find Model Keys\n *\n * @param {Object} attributes\n * @api private\n * @return {Array}\n */\n\nDefine.prototype.modelKeys = function(attributes) {\n  var models = [];\n\n  // Find any collection keys\n  for (var attribute in attributes) {\n    if (!hasOwnProperty(attributes[attribute], 'model')) continue;\n    models.push({ key: _.cloneDeep(attribute), val: _.cloneDeep(attributes[attribute]) });\n  }\n\n  return models;\n};\n\n/**\n * Create Getter/Setter for hasMany associations\n *\n * @param {String} collection\n * @api private\n */\n\nDefine.prototype.buildHasManyProperty = function(collection) {\n  var self = this;\n\n  // Attach to a non-enumerable property\n  this.proto.associations[collection] = new Association();\n\n  // Attach getter and setter to the model\n  Object.defineProperty(this.proto, collection, {\n    set: function(val) { self.proto.associations[collection]._setValue(val); },\n    get: function() { return self.proto.associations[collection]._getValue(); },\n    enumerable: true,\n    configurable: true\n  });\n};\n\n/**\n * Add belongsTo attributes to associations object\n *\n * @param {String} collection\n * @api private\n */\n\nDefine.prototype.buildBelongsToProperty = function(model) {\n\n  // Attach to a non-enumerable property\n  this.proto.associations[model.key] = model.val;\n\n  // Build a cache for this model\n  this.proto.associationsCache[model.key] = {};\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/model/lib/association.js":"\n/**\n * Handles an Association\n */\n\nvar Association = module.exports = function() {\n  this.addModels = [];\n  this.removeModels = [];\n  this.value = [];\n};\n\n/**\n * Set Value\n *\n * @param {Number|Object} value\n * @api private\n */\n\nAssociation.prototype._setValue = function(value) {\n  if (Array.isArray(value)) {\n    this.value = value;\n    return;\n  }\n\n  this.value = this.value = [value];\n};\n\n/**\n * Get Value\n *\n * @api private\n */\n\nAssociation.prototype._getValue = function() {\n  var self = this;\n  var value = this.value;\n\n  // Attach association methods to values array\n  // This allows access using the getter and the desired\n  // API for synchronously adding and removing associations.\n\n  value.add = function add(obj) {\n    if (Array.isArray(obj)) {\n      obj.forEach(function(el) {\n        self.addModels.push(el);\n      });\n    } else {\n      self.addModels.push(obj);\n    }\n  };\n\n  value.remove = function remove(obj) {\n    if (Array.isArray(obj)) {\n      obj.forEach(function(el) {\n        self.removeModels.push(el);\n      });\n    } else {\n      self.removeModels.push(obj);\n    }\n  };\n\n  return value;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/core/typecast.js":"/**\n * Module dependencies\n */\n\nvar types = require('../utils/types');\nvar utils = require('../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\nvar _ = require('lodash');\n\n/**\n * Cast Types\n *\n * Will take values and cast they to the correct type based on the\n * type defined in the schema.\n *\n * Especially handy for converting numbers passed as strings to the\n * correct integer type.\n *\n * Should be run before sending values to an adapter.\n */\n\nvar Cast = module.exports = function() {\n  this._types = {};\n\n  return this;\n};\n\n/**\n * Builds an internal _types object that contains each\n * attribute with it's type. This can later be used to\n * transform values into the correct type.\n *\n * @param {Object} attrs\n */\n\nCast.prototype.initialize = function(attrs) {\n  var self = this;\n\n  Object.keys(attrs).forEach(function(key) {\n    self._types[key] = ~types.indexOf(attrs[key].type) ? attrs[key].type : 'string';\n  });\n};\n\n/**\n * Converts a set of values into the proper types\n * based on the Collection's schema.\n *\n * @param {Object} values\n * @return {Object}\n * @api public\n */\n\nCast.prototype.run = function(values) {\n  var self = this;\n\n  if (values === undefined || values === null) {\n    return;\n  }\n\n  Object.keys(values).forEach(function(key) {\n\n    // Set undefined to null\n    if (_.isUndefined(values[key])) values[key] = null;\n    if (!hasOwnProperty(self._types, key) || values[key] === null || !hasOwnProperty(values, key)) {\n      return;\n    }\n\n    // If the value is a plain object, don't attempt to cast it\n    if (_.isPlainObject(values[key])) return;\n\n    // Find the value's type\n    var type = self._types[key];\n\n    // Casting Function\n    switch (type) {\n      case 'string':\n      case 'text':\n        values[key] = self.string(values[key]);\n        break;\n\n      case 'integer':\n        values[key] = self.integer(key, values[key]);\n        break;\n\n      case 'float':\n        values[key] = self.float(values[key]);\n        break;\n\n      case 'date':\n      case 'time':\n      case 'datetime':\n        values[key] = self.date(values[key]);\n        break;\n\n      case 'boolean':\n        values[key] = self.boolean(values[key]);\n        break;\n\n      case 'array':\n        values[key] = self.array(values[key]);\n        break;\n    }\n  });\n\n  return values;\n};\n\n/**\n * Cast String Values\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nCast.prototype.string = function string(str) {\n  return typeof str.toString !== 'undefined' ? str.toString() : '' + str;\n};\n\n/**\n * Cast Integer Values\n *\n * @param {String} key\n * @param {Integer} value\n * @return {Integer}\n * @api private\n */\n\nCast.prototype.integer = function integer(key, value) {\n  var _value;\n\n  // Attempt to see if the value is resembles a MongoID\n  // if so let's not try and cast it and instead return a string representation of\n  // it. Needed for sails-mongo.\n  if (utils.matchMongoId(value)) return value.toString();\n\n  // Attempt to parseInt\n  try {\n    _value = parseInt(value, 10);\n  } catch(e) {\n    return value;\n  }\n\n  return _value;\n};\n\n/**\n * Cast Float Values\n *\n * @param {Float} value\n * @return {Float}\n * @api private\n */\n\nCast.prototype.float = function float(value) {\n  var _value;\n\n  try {\n    _value = parseFloat(value);\n  } catch(e) {\n    return value;\n  }\n\n  return _value;\n};\n\n/**\n * Cast Boolean Values\n *\n * @param {Boolean} value\n * @return {Boolean}\n * @api private\n */\n\nCast.prototype.boolean = function boolean(value) {\n  var parsed;\n\n  if (_.isString(value)) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value;\n  }\n\n  // Nicely cast [0, 1] to true and false\n  try {\n    parsed = parseInt(value, 10);\n  } catch(e) {\n    return false;\n  }\n\n  if (parsed === 0) return false;\n  if (parsed === 1) return true;\n\n  return value;\n};\n\n/**\n * Cast Date Values\n *\n * @param {String|Date} value\n * @return {Date}\n * @api private\n */\n\nCast.prototype.date = function date(value) {\n  var _value;\n  if (value.__proto__ == Date.prototype) {\n    _value = new Date(value.getTime());\n  } else if (typeof value.toDate === 'function') {\n    _value = value.toDate();\n  } else {\n    _value = new Date(Date.parse(value));\n  }\n\n  if (_value.toString() === 'Invalid Date') return value;\n  return _value;\n};\n\n/**\n * Cast Array Values\n *\n * @param {Array|String} value\n * @return {Array}\n * @api private\n */\n\nCast.prototype.array = function array(value) {\n  if (Array.isArray(value)) return value;\n  return [value];\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/core/schema.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar types = require('../utils/types');\nvar utils = require('../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Builds a Schema Object from an attributes\n * object in a model.\n *\n * Loops through an attributes object to build a schema\n * containing attribute name as key and a type for casting\n * in the database. Also includes a default value if supplied.\n *\n * Example:\n *\n * attributes: {\n *   name: 'string',\n *   phone: {\n *     type: 'string',\n *     defaultsTo: '555-555-5555'\n *   }\n * }\n *\n * Returns: {\n *   name: { type: 'string' },\n *   phone: { type: 'string, defaultsTo: '555-555-5555' }\n * }\n *\n * @param {Object} context\n * @return {Object}\n */\n\nvar Schema = module.exports = function(context) {\n  this.context = context || {};\n  this.schema = {};\n\n  return this;\n};\n\n/**\n * Initialize the internal schema object\n *\n * @param {Object} attrs\n * @param {Object} associations\n * @param {Boolean} hasSchema\n */\n\nSchema.prototype.initialize = function(attrs, hasSchema, reservedAttributes) {\n  var self = this;\n\n  // Build normal attributes\n  Object.keys(attrs).forEach(function(key) {\n    if (hasOwnProperty(attrs[key], 'collection')) return;\n    self.schema[key] = self.objectAttribute(key, attrs[key]);\n  });\n\n  // Build Reserved Attributes\n  if (Array.isArray(reservedAttributes)) {\n    reservedAttributes.forEach(function(key) {\n      self.schema[key] = {};\n    });\n  }\n\n  // Set hasSchema to determine if values should be cleansed or not\n  this.hasSchema = typeof hasSchema !== 'undefined' ? hasSchema : true;\n};\n\n/**\n * Handle the building of an Object attribute\n *\n * Cleans any unnecessary attributes such as validation properties off of\n * the internal schema and set's defaults for incorrect values.\n *\n * @param {Object} value\n * @return {Object}\n */\n\nSchema.prototype.objectAttribute = function(attrName, value) {\n  var attr = {};\n\n  for (var key in value) {\n    switch (key) {\n\n      // Set schema[attribute].type\n      case 'type':\n        // Allow validation types in attributes and transform them to strings\n        attr.type = ~types.indexOf(value[key]) ? value[key] : 'string';\n        break;\n\n      // Set schema[attribute].defaultsTo\n      case 'defaultsTo':\n        attr.defaultsTo = value[key];\n        break;\n\n      // Set schema[attribute].primaryKey\n      case 'primaryKey':\n        attr.primaryKey = value[key];\n        attr.unique = true;\n        break;\n\n      // Set schema[attribute].foreignKey\n      case 'foreignKey':\n        attr.foreignKey = value[key];\n        break;\n\n      // Set schema[attribute].references\n      case 'references':\n        attr.references = value[key];\n        break;\n\n      // Set schema[attribute].on\n      case 'on':\n        attr.on = value[key];\n        break;\n\n      // Set schema[attribute].via\n      case 'via':\n        attr.via = value[key];\n        break;\n\n      // Set schema[attribute].autoIncrement\n      case 'autoIncrement':\n        attr.autoIncrement = value[key];\n        attr.type = 'integer';\n        break;\n\n      // Set schema[attribute].unique\n      case 'unique':\n        attr.unique = value[key];\n        break;\n\n      // Set schema[attribute].index\n      case 'index':\n        attr.index = value[key];\n        break;\n\n      // Set schema[attribute].enum\n      case 'enum':\n        attr.enum = value[key];\n        break;\n\n      // Set schema[attribute].size\n      case 'size':\n        attr.size = value[key];\n        break;\n\n      // Set schema[attribute].notNull\n      case 'notNull':\n        attr.notNull = value[key];\n        break;\n\n      // Handle Belongs To Attributes\n      case 'model':\n        var type;\n        var attrs = this.context.waterline.schema[value[key].toLowerCase()].attributes;\n\n        for (var attribute in attrs) {\n          if (hasOwnProperty(attrs[attribute], 'primaryKey') && attrs[attribute].primaryKey) {\n            type = attrs[attribute].type;\n            break;\n          }\n        }\n\n        attr.type = type.toLowerCase();\n        attr.model = value[key].toLowerCase();\n        attr.foreignKey = true;\n        attr.alias = attrName;\n        break;\n    }\n  }\n\n  return attr;\n};\n\n\n/**\n * Clean Values\n *\n * Takes user inputted data and strips out any values not defined in\n * the schema.\n *\n * This is run after all the validations and right before being sent to the\n * adapter. This allows you to add temporary properties when doing validation\n * callbacks and have them stripped before being sent to the database.\n *\n * @param {Object} values to clean\n * @return {Object} clone of values, stripped of any extra properties\n */\n\nSchema.prototype.cleanValues = function(values) {\n\n  var clone = {};\n\n  for (var key in values) {\n\n    // The value can pass through if either the collection does have a schema and the key is in the schema,\n    // or otherwise if the collection is schemaless and the key does not represent an associated collection.\n    if ((this.hasSchema && hasOwnProperty(this.schema, key)) ||\n        (!this.hasSchema && !(hasOwnProperty(this.context._attributes, key) && hasOwnProperty(this.context._attributes[key], 'collection')))) {\n\n      clone[key] = values[key];\n    }\n\n  }\n\n  return clone;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/core/dictionary.js":"var _ = require('lodash');\n\n/**\n * Handle Building an Adapter/Connection dictionary\n *\n * @param {Object} connections\n * @param {Array} ordered\n * @return {Object}\n * @api public\n *\n * Manages a 'dictionary' object of the following structure:\n * {\n *    CONNECTION: {\n *      METHOD: ADAPTER_NAME\n *    }\n * }\n */\nvar Dictionary = module.exports = function(connections, ordered) {\n  this.dictionary = this._build(connections);\n  return this._smash(ordered);\n};\n\n/**\n * Build Dictionary. This maps adapter methods to the effective connection\n * for which the method is pertinent.\n *\n * @param {Object} connections\n * @api private\n */\nDictionary.prototype._build = function _build(connections) {\n  return _.mapValues(connections, function(connection, connectionName) {\n    var adapter = connection._adapter || { };\n\n    return _.mapValues(adapter, function(method) {\n      return connectionName;\n    });\n  });\n};\n\n/**\n * Combine Dictionary into a single level object.\n *\n * Appends methods from other adapters onto the left most connection adapter,\n * but does not override any existing methods defined in the leftmost adapter.\n *\n * @param {Array} ordered\n * @return {Object}\n * @api private\n */\nDictionary.prototype._smash = function _smash(ordered) {\n  var mergeArguments = _.map((ordered || [ ]).reverse(), function(adapterName) {\n    return this.dictionary[adapterName];\n  }, this);\n\n  return _.merge.apply(null, mergeArguments);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/core/validations.js":"/**\n * Handles validation on a model\n *\n * Uses Anchor for validating\n * https://github.com/balderdashy/anchor\n */\n\nvar _ = require('lodash');\nvar anchor = require('anchor');\nvar async = require('async');\nvar utils = require('../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\nvar WLValidationError = require('../error/WLValidationError');\n\n\n/**\n * Build up validations using the Anchor module.\n *\n * @param {String} adapter\n */\n\nvar Validator = module.exports = function(adapter) {\n  this.validations = {};\n};\n\n/**\n * Builds a Validation Object from a normalized attributes\n * object.\n *\n * Loops through an attributes object to build a validation object\n * containing attribute name as key and a series of validations that\n * are run on each model. Skips over type and defaultsTo as they are\n * schema properties.\n *\n * Example:\n *\n * attributes: {\n *   name: {\n *     type: 'string',\n *     length: { min: 2, max: 5 }\n *   }\n *   email: {\n *     type: 'string',\n *     required: true\n *   }\n * }\n *\n * Returns: {\n *   name: { length: { min:2, max: 5 }},\n *   email: { required: true }\n * }\n */\n\nValidator.prototype.initialize = function(attrs, types, defaults) {\n  var self = this;\n\n  defaults = defaults || {};\n\n  this.reservedProperties = ['defaultsTo', 'primaryKey', 'autoIncrement', 'unique', 'index', 'collection', 'dominant', 'through',\n          'columnName', 'foreignKey', 'references', 'on', 'groupKey', 'model', 'via', 'size',\n          'example', 'validationMessage', 'validations', 'populateSettings', 'onKey', 'protected'];\n\n\n  if (defaults.ignoreProperties && Array.isArray(defaults.ignoreProperties)) {\n    this.reservedProperties = this.reservedProperties.concat(defaults.ignoreProperties);\n  }\n\n  // Add custom type definitions to anchor\n  types = types || {};\n  anchor.define(types);\n\n  Object.keys(attrs).forEach(function(attr) {\n    self.validations[attr] = {};\n\n    Object.keys(attrs[attr]).forEach(function(prop) {\n\n      // Ignore null values\n      if (attrs[attr][prop] === null) { return; }\n\n      // If property is reserved don't do anything with it\n      if (self.reservedProperties.indexOf(prop) > -1) { return; }\n\n      // use the Anchor `in` method for enums\n      if (prop === 'enum') {\n        self.validations[attr]['in'] = attrs[attr][prop];\n        return;\n      }\n\n      self.validations[attr][prop] = attrs[attr][prop];\n    });\n  });\n};\n\n\n/**\n * Validator.prototype.validate()\n *\n * Accepts a dictionary of values and validates them against\n * the validation rules expected by this schema (`this.validations`).\n * Validation is performed using Anchor.\n *\n *\n * @param {Dictionary} values\n *        The dictionary of values to validate.\n *\n * @param {Boolean|String|String[]} presentOnly\n *        only validate present values (if `true`) or validate the\n *        specified attribute(s).\n *\n * @param {Function} callback\n *        @param {Error} err - a fatal error, if relevant.\n *        @param {Array} invalidAttributes - an array of errors\n */\n\nValidator.prototype.validate = function(values, presentOnly, cb) {\n  var self = this;\n  var errors = {};\n  var validations = Object.keys(this.validations);\n\n  // Handle optional second arg AND Use present values only, specified values, or all validations\n  /* eslint-disable no-fallthrough */\n  switch (typeof presentOnly) {\n    case 'function':\n      cb = presentOnly;\n      break;\n    case 'string':\n      validations = [presentOnly];\n      break;\n    case 'object':\n      if (Array.isArray(presentOnly)) {\n        validations = presentOnly;\n        break;\n      } // Fall through to the default if the object is not an array\n    default:\n      // Any other truthy value.\n      if (presentOnly) {\n        validations = _.intersection(validations, Object.keys(values));\n      }\n    /* eslint-enable no-fallthrough */\n  }\n\n\n  // Validate all validations in parallel\n  async.each(validations, function _eachValidation(validation, cb) {\n    var curValidation = self.validations[validation];\n\n    // Build Requirements\n    var requirements;\n    try {\n      requirements = anchor(curValidation);\n    }\n    catch (e) {\n      // Handle fatal error:\n      return cb(e);\n    }\n    requirements = _.cloneDeep(requirements);\n\n    // Grab value and set to null if undefined\n    var value = values[validation];\n    if (typeof value == 'undefined') {\n      value = null;\n    }\n\n    // If value is not required and empty then don't\n    // try and validate it\n    if (!curValidation.required) {\n      if (value === null || value === '') {\n        return cb();\n      }\n    }\n\n    // If Boolean and required manually check\n    if (curValidation.required && curValidation.type === 'boolean' && (typeof value !== 'undefined' && value !== null)) {\n      if (value.toString() === 'true' || value.toString() === 'false') {\n        return cb();\n      }\n    }\n\n    // If type is integer and the value matches a mongoID let it validate\n    if (hasOwnProperty(self.validations[validation], 'type') && self.validations[validation].type === 'integer') {\n      if (utils.matchMongoId(value)) {\n        return cb();\n      }\n    }\n\n    // Rule values may be specified as sync or async functions.\n    // Call them and replace the rule value with the function's result\n    // before running validations.\n    async.each(Object.keys(requirements.data), function _eachKey(key, next) {\n      try {\n        if (typeof requirements.data[key] !== 'function') {\n          return next();\n        }\n\n        // Run synchronous function\n        if (requirements.data[key].length < 1) {\n          requirements.data[key] = requirements.data[key].apply(values, []);\n          return next();\n        }\n\n        // Run async function\n        requirements.data[key].call(values, function(result) {\n          requirements.data[key] = result;\n          next();\n        });\n      }\n      catch (e) {\n        return next(e);\n      }\n    }, function afterwards(unexpectedErr) {\n      if (unexpectedErr) {\n        // Handle fatal error\n        return cb(unexpectedErr);\n      }\n\n      // If the value has a dynamic required function and it evaluates to false lets look and see\n      // if the value supplied is null or undefined. If so then we don't need to check anything. This\n      // prevents type errors like `undefined` should be a string.\n      // if required is set to 'false', don't enforce as required rule\n      if (requirements.data.hasOwnProperty('required') && !requirements.data.required) {\n        if (_.isNull(value)) {\n          return cb();\n        }\n      }\n\n      // Now run the validations using Anchor.\n      var validationError;\n      try {\n        validationError = anchor(value).to(requirements.data, values);\n      }\n      catch (e) {\n        // Handle fatal error:\n        return cb(e);\n      }\n\n      // If no validation errors, bail.\n      if (!validationError) {\n        return cb();\n      }\n\n      // Build an array of errors.\n      errors[validation] = [];\n\n      validationError.forEach(function(obj) {\n        if (obj.property) {\n          delete obj.property;\n        }\n        errors[validation].push({ rule: obj.rule, message: obj.message });\n      });\n\n      return cb();\n    });\n\n  }, function allValidationsChecked(err) {\n    // Handle fatal error:\n    if (err) {\n      return cb(err);\n    }\n\n\n    if (Object.keys(errors).length === 0) {\n      return cb();\n    }\n\n    return cb(undefined, errors);\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/error/WLValidationError.js":"/**\n * Module dependencies\n */\n\nvar WLError = require('./WLError');\nvar WLUsageError = require('./WLUsageError');\nvar util = require('util');\nvar _ = require('lodash');\n\n\n/**\n * WLValidationError\n *\n * @extends WLError\n */\nfunction WLValidationError(properties) {\n\n  // Call superclass\n  WLValidationError.super_.call(this, properties);\n\n  // Ensure valid usage\n  if (typeof this.invalidAttributes !== 'object') {\n    return new WLUsageError({\n      reason: 'An `invalidAttributes` object must be passed into the constructor for `WLValidationError`'\n    });\n  }\n  // if ( typeof this.model !== 'string' ) {\n  //   return new WLUsageError({\n  //     reason: 'A `model` string (the collection\\'s `globalId`) must be passed into the constructor for `WLValidationError`'\n  //   });\n  // }\n\n  // Customize the `reason` based on the # of invalid attributes\n  // (`reason` may not be overridden)\n  var isSingular = this.length === 1;\n  this.reason = util.format('%d attribute%s %s invalid',\n    this.length,\n    isSingular ? '' : 's',\n    isSingular ? 'is' : 'are');\n\n  // Always apply the 'E_VALIDATION' error code, even if it was overridden.\n  this.code = 'E_VALIDATION';\n\n  // Status may be overridden.\n  this.status = properties.status || 400;\n\n  // Model should always be set.\n  // (this should be the globalId of model, or \"collection\")\n  this.model = properties.model;\n\n  // Ensure messages exist for each invalidAttribute\n  this.invalidAttributes = _.mapValues(this.invalidAttributes, function(rules, attrName) {\n    return _.map(rules, function(rule) {\n      if (!rule.message) {\n        rule.message = util.format('A record with that `%s` already exists (`%s`).', attrName, rule.value);\n      }\n      return rule;\n    });\n  });\n\n  // Customize the `details`\n  this.details = util.format('Invalid attributes sent to %s:\\n', this.model) +\n  _.reduce(this.messages, function(memo, messages, attrName) {\n    memo += '  ' + attrName + '\\n';\n    memo += _.reduce(messages, function(memo, message) {\n      memo += '    ' + message + '\\n';\n      return memo;\n    }, '');\n    return memo;\n  }, '');\n\n}\nutil.inherits(WLValidationError, WLError);\n\n\n/**\n * `rules`\n *\n * @return {Object[Array[String]]} dictionary of validation rule ids, indexed by attribute\n */\nWLValidationError.prototype.__defineGetter__('rules', function() {\n  return _.mapValues(this.invalidAttributes, function(rules, attrName) {\n    return _.pluck(rules, 'rule');\n  });\n});\n\n\n/**\n * `messages` (aka `errors`)\n *\n * @return {Object[Array[String]]} dictionary of validation messages, indexed by attribute\n */\nWLValidationError.prototype.__defineGetter__('messages', function() {\n  return _.mapValues(this.invalidAttributes, function(rules, attrName) {\n    return _.pluck(rules, 'message');\n  });\n});\nWLValidationError.prototype.__defineGetter__('errors', function() {\n  return this.messages;\n});\n\n\n/**\n * `attributes` (aka `keys`)\n *\n * @return {Array[String]} of invalid attribute names\n */\nWLValidationError.prototype.__defineGetter__('attributes', function() {\n  return _.keys(this.invalidAttributes);\n});\nWLValidationError.prototype.__defineGetter__('keys', function() {\n  return this.attributes;\n});\n\n\n/**\n * `.length`\n *\n * @return {Integer} number of invalid attributes\n */\nWLValidationError.prototype.__defineGetter__('length', function() {\n  return this.attributes.length;\n});\n\n\n/**\n * `.ValidationError`\n * (backwards-compatibility)\n *\n * @return {Object[Array[Object]]} number of invalid attributes\n */\nWLValidationError.prototype.__defineGetter__('ValidationError', function() {\n  //\n  // TODO:\n  // Down the road- emit deprecation event here--\n  // (will log information about new error handling options)\n  //\n  return this.invalidAttributes;\n});\n\n\n/**\n * [toJSON description]\n * @type {[type]}\n */\nWLValidationError.prototype.toJSON =\nWLValidationError.prototype.toPOJO =\nfunction() {\n  return {\n    error: this.code,\n    status: this.status,\n    summary: this.reason,\n    model: this.model,\n    invalidAttributes: this.invalidAttributes\n  };\n};\n\n\nmodule.exports = WLValidationError;\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/error/WLUsageError.js":"/**\n * Module dependencies\n */\n\nvar WLError = require('./WLError');\nvar util = require('util');\n\n\n/**\n * WLUsageError\n *\n * @extends WLError\n */\nfunction WLUsageError(properties) {\n\n  // Call superclass\n  WLUsageError.super_.call(this, properties);\n}\nutil.inherits(WLUsageError, WLError);\n\n\n// Override WLError defaults with WLUsageError properties.\nWLUsageError.prototype.code =\n'E_USAGE';\nWLUsageError.prototype.status =\n0;\nWLUsageError.prototype.reason =\n'Invalid usage';\n\n\nmodule.exports = WLUsageError;\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/core/transformations.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Transformation\n *\n * Allows for a Waterline Collection to have different\n * attributes than what actually exist in an adater's representation.\n *\n * @param {Object} attributes\n * @param {Object} tables\n */\n\nvar Transformation = module.exports = function(attributes, tables) {\n\n  // Hold an internal mapping of keys to transform\n  this._transformations = {};\n\n  // Initialize\n  this.initialize(attributes, tables);\n\n  return this;\n};\n\n/**\n * Initial mapping of transformations.\n *\n * @param {Object} attributes\n * @param {Object} tables\n */\n\nTransformation.prototype.initialize = function(attributes, tables) {\n  var self = this;\n\n  Object.keys(attributes).forEach(function(attr) {\n\n    // Ignore Functions and Strings\n    if (['function', 'string'].indexOf(typeof attributes[attr]) > -1) return;\n\n    // If not an object, ignore\n    if (attributes[attr] !== Object(attributes[attr])) return;\n\n    // Loop through an attribute and check for transformation keys\n    Object.keys(attributes[attr]).forEach(function(key) {\n\n      // Currently just works with `columnName`, `collection`, `groupKey`\n      if (key !== 'columnName') return;\n\n      // Error if value is not a string\n      if (typeof attributes[attr][key] !== 'string') {\n        throw new Error('columnName transformation must be a string');\n      }\n\n      // Set transformation attr to new key\n      if (key === 'columnName') {\n        if (attr === attributes[attr][key]) return;\n        self._transformations[attr] = attributes[attr][key];\n      }\n\n    });\n  });\n};\n\n/**\n * Transforms a set of attributes into a representation used\n * in an adapter.\n *\n * @param {Object} attributes to transform\n * @return {Object}\n */\n\nTransformation.prototype.serialize = function(attributes, behavior) {\n  var self = this;\n  var values = _.clone(attributes);\n\n  behavior = behavior || 'default';\n\n  function recursiveParse(obj) {\n\n    // Return if no object\n    if (!obj) return;\n\n    // Handle array of types for findOrCreateEach\n    if (typeof obj === 'string') {\n      if (hasOwnProperty(self._transformations, obj)) {\n        values = self._transformations[obj];\n        return;\n      }\n\n      return;\n    }\n\n    Object.keys(obj).forEach(function(property) {\n\n      // Just a double check to exit if hasOwnProperty fails\n      if (!hasOwnProperty(obj, property)) return;\n\n      // Schema must be serialized in first level only\n      if (behavior === 'schema') {\n        if (hasOwnProperty(self._transformations, property)) {\n          obj[self._transformations[property]] = _.clone(obj[property]);\n          delete obj[property];\n        }\n        return;\n      }\n\n      // Recursively parse `OR` criteria objects to transform keys\n      if (Array.isArray(obj[property]) && property === 'or') return recursiveParse(obj[property]);\n\n      // If Nested Object call function again passing the property as obj\n      if ((toString.call(obj[property]) !== '[object Date]') && (_.isPlainObject(obj[property]))) {\n\n        // check if object key is in the transformations\n        if (hasOwnProperty(self._transformations, property)) {\n          obj[self._transformations[property]] = _.clone(obj[property]);\n          delete obj[property];\n\n          return recursiveParse(obj[self._transformations[property]]);\n        }\n\n        return recursiveParse(obj[property]);\n      }\n\n      // Check if property is a transformation key\n      if (hasOwnProperty(self._transformations, property)) {\n\n        obj[self._transformations[property]] = obj[property];\n        delete obj[property];\n      }\n    });\n  }\n\n  // Recursivly parse attributes to handle nested criteria\n  recursiveParse(values);\n\n  return values;\n};\n\n/**\n * Transforms a set of attributes received from an adapter\n * into a representation used in a collection.\n *\n * @param {Object} attributes to transform\n * @return {Object}\n */\n\nTransformation.prototype.unserialize = function(attributes) {\n  var self = this;\n  var values = _.clone(attributes);\n\n  // Loop through the attributes and change them\n  Object.keys(this._transformations).forEach(function(key) {\n    var transformed = self._transformations[key];\n\n    if (!hasOwnProperty(attributes, transformed)) return;\n\n    values[key] = attributes[transformed];\n    if (transformed !== key) delete values[transformed];\n  });\n\n  return values;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/index.js":"/**\n * Dependencies\n */\n\nvar _ = require('lodash');\nvar extend = require('../utils/extend');\nvar AdapterBase = require('../adapter');\nvar utils = require('../utils/helpers');\nvar AdapterMixin = require('./adapters');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Query\n */\n\nvar Query = module.exports = function() {\n\n  // Create a reference to an internal Adapter Base\n  this.adapter = new AdapterBase({\n    connections: this.connections,\n    query: this,\n    collection: this.tableName || this.identity,\n    identity: this.identity,\n    dictionary: this.adapterDictionary\n  });\n\n  // Mixin Custom Adapter Functions.\n  AdapterMixin.call(this);\n\n  // Generate Dynamic Finders\n  this.buildDynamicFinders();\n};\n\n\n/**\n * Automigrate\n *\n * @param  {Function} cb\n */\nQuery.prototype.sync = function(cb) {\n  var self = this;\n\n  // If any adapters used in this collection have syncable turned off set migrate to safe.\n  //\n  // I don't think a collection would ever need two adapters where one needs migrations and\n  // the other doesn't but it may be a possibility. The way the auto-migrations work now doesn't\n  // allow for this either way so this should be good. We will probably need to revist this soonish\n  // however and take a pass at getting something working for better migration systems.\n  // - particlebanana\n\n  _.keys(this.connections).forEach(function(connectionName) {\n    var adapter = self.connections[connectionName]._adapter;\n\n    // If not syncable, don't sync\n    if (hop(adapter, 'syncable') && !adapter.syncable) {\n      self.migrate = 'safe';\n    }\n  });\n\n  // Assign synchronization behavior depending on migrate option in collection\n  if (this.migrate && ['drop', 'alter', 'create', 'safe'].indexOf(this.migrate) > -1) {\n\n    // Determine which sync strategy to use\n    var strategyMethodName = 'migrate' + utils.capitalize(this.migrate);\n\n    // Run automigration strategy\n    this.adapter[strategyMethodName](function(err) {\n      if (err) return cb(err);\n      cb();\n    });\n  }\n\n  // Throw Error\n  else cb(new Error('Invalid `migrate` strategy defined for collection. Must be one of the following: drop, alter, create, safe'));\n};\n\n\n_.extend(\n  Query.prototype,\n  require('./validate'),\n  require('./ddl'),\n  require('./dql'),\n  require('./aggregate'),\n  require('./composite'),\n  require('./finders/basic'),\n  require('./finders/helpers'),\n  require('./finders/dynamicFinders'),\n  require('./stream')\n);\n\n// Make Extendable\nQuery.extend = extend;\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/index.js":"/**\n * Base Adapter Definition\n */\n\nvar _ = require('lodash');\n\nvar Adapter = module.exports = function(options) {\n\n  // Ensure the connections are set\n  this.connections = options.connections || {};\n\n  // Ensure the dictionary is built\n  this.dictionary = options.dictionary || {};\n\n  // Set a Query instance to get access to top\n  // level query functions\n  this.query = options.query || {};\n\n  // Set Collection Name\n  this.collection = options.collection || '';\n\n  // Set Model Identity\n  this.identity = options.identity || '';\n\n  return this;\n};\n\n_.extend(\n  Adapter.prototype,\n  require('./dql'),\n  require('./ddl'),\n  require('./compoundQueries'),\n  require('./aggregateQueries'),\n  require('./setupTeardown'),\n  require('./sync'),\n  require('./stream')\n);\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/dql.js":"/**\n * Module Dependencies\n */\n\nvar normalize = require('../utils/normalize');\nvar schema = require('../utils/schema');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\nvar _ = require('lodash');\n\n\n/**\n * DQL Adapter Normalization\n */\nmodule.exports = {\n\n  hasJoin: function() {\n    return hasOwnProperty(this.dictionary, 'join');\n  },\n\n\n  /**\n   * join()\n   *\n   * If `join` is defined in the adapter, Waterline will use it to optimize\n   * the `.populate()` implementation when joining collections within the same\n   * database connection.\n   *\n   * @param  {[type]}   criteria\n   * @param  {Function} cb\n   */\n  join: function(criteria, cb) {\n\n    // Normalize Arguments\n    criteria = normalize.criteria(criteria);\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No join() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'join')) return cb(new Error(err));\n\n    var connName = this.dictionary.join;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'join')) return cb(new Error(err));\n\n    // Parse Join Criteria and set references to any collection tableName properties.\n    // This is done here so that everywhere else in the codebase can use the collection identity.\n    criteria = schema.serializeJoins(criteria, this.query.waterline.schema);\n\n    adapter.join(connName, this.collection, criteria, cb);\n  },\n\n\n  /**\n   * create()\n   *\n   * Create one or more models.\n   *\n   * @param  {[type]}   values [description]\n   * @param  {Function} cb     [description]\n   * @return {[type]}          [description]\n   */\n  create: function(values, cb) {\n\n    var globalId = this.query.globalId;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    if (Array.isArray(values)) return this.createEach.call(this, values, cb);\n\n    // Build Default Error Message\n    var err = 'No create() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'create')) return cb(new Error(err));\n\n    var connName = this.dictionary.create;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'create')) return cb(new Error(err));\n    adapter.create(connName, this.collection, values, normalize.callback(function afterwards(err, createdRecord) {\n      if (err) {\n        if (typeof err === 'object') err.model = globalId;\n        return cb(err);\n      }\n      else return cb(null, createdRecord);\n    }));\n  },\n\n\n  /**\n   * find()\n   *\n   * Find a set of models.\n   *\n   * @param  {[type]}   criteria [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  find: function(criteria, cb) {\n\n    // Normalize Arguments\n    criteria = normalize.criteria(criteria);\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No find() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'find')) return cb(new Error(err));\n\n    var connName = this.dictionary.find;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!adapter.find) return cb(new Error(err));\n    adapter.find(connName, this.collection, criteria, cb);\n  },\n\n\n  /**\n   * findOne()\n   *\n   * Find exactly one model.\n   *\n   * @param  {[type]}   criteria [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  findOne: function(criteria, cb) {\n\n    // make shallow copy of criteria so original does not get modified\n    criteria = _.clone(criteria);\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = '.findOne() requires a criteria. If you want the first record try .find().limit(1)';\n\n    // If no criteria is specified or where is empty return an error\n    if (!criteria || criteria.where === null) return cb(new Error(err));\n\n    // Detects if there is a `findOne` in the adapter. Use it if it exists.\n    if (hasOwnProperty(this.dictionary, 'findOne')) {\n      var connName = this.dictionary.findOne;\n      var adapter = this.connections[connName]._adapter;\n\n      if (adapter.findOne) {\n        // Normalize Arguments\n        criteria = normalize.criteria(criteria);\n        return adapter.findOne(connName, this.collection, criteria, cb);\n      }\n    }\n\n    // Fallback to use `find()` to simulate a `findOne()`\n    // Enforce limit to 1\n    criteria.limit = 1;\n\n    this.find(criteria, function(err, models) {\n      if (!models) return cb(err);\n      if (models.length < 1) return cb(err);\n\n      cb(null, models);\n    });\n  },\n\n  /**\n   * [count description]\n   * @param  {[type]}   criteria [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  count: function(criteria, cb) {\n    var connName;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n    criteria = normalize.criteria(criteria);\n\n    // Build Default Error Message\n    var err = '.count() requires the adapter define either a count method or a find method';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'count')) {\n\n      // If a count method isn't defined make sure a find method is\n      if (!hasOwnProperty(this.dictionary, 'find')) return cb(new Error(err));\n\n      // Use the find method\n      connName = this.dictionary.find;\n    }\n\n    if (!connName) connName = this.dictionary.count;\n    var adapter = this.connections[connName]._adapter;\n\n    if (hasOwnProperty(adapter, 'count')) return adapter.count(connName, this.collection, criteria, cb);\n\n    this.find(criteria, function(err, models) {\n      if (err) return cb(err);\n      var count = models && models.length || 0;\n      cb(err, count);\n    });\n  },\n\n\n  /**\n   * [update description]\n   * @param  {[type]}   criteria [description]\n   * @param  {[type]}   values   [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  update: function(criteria, values, cb) {\n    var globalId = this.query.globalId;\n\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n    criteria = normalize.criteria(criteria);\n\n    if (criteria === false) {\n      return cb(null, []);\n    } else if (!criteria) {\n      return cb(new Error('No criteria or id specified!'));\n    }\n\n    // Build Default Error Message\n    var err = 'No update() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'update')) return cb(new Error(err));\n\n    var connName = this.dictionary.update;\n    var adapter = this.connections[connName]._adapter;\n\n    adapter.update(connName, this.collection, criteria, values, normalize.callback(function afterwards(err, updatedRecords) {\n      if (err) {\n        if (typeof err === 'object') err.model = globalId;\n        return cb(err);\n      }\n      return cb(null, updatedRecords);\n    }));\n  },\n\n\n  /**\n   * [destroy description]\n   * @param  {[type]}   criteria [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  destroy: function(criteria, cb) {\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n    criteria = normalize.criteria(criteria);\n\n    // Build Default Error Message\n    var err = 'No destroy() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'destroy')) return cb(new Error(err));\n\n    var connName = this.dictionary.destroy;\n    var adapter = this.connections[connName]._adapter;\n\n    adapter.destroy(connName, this.collection, criteria, cb);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/normalize.js":"var _ = require('lodash');\nvar util = require('./helpers');\nvar hop = util.object.hasOwnProperty;\nvar switchback = require('switchback');\nvar errorify = require('../error');\nvar WLUsageError = require('../error/WLUsageError');\n\nvar normalize = module.exports = {\n\n  // Expand Primary Key criteria into objects\n  expandPK: function(context, options) {\n\n    // Default to id as primary key\n    var pk = 'id';\n\n    // If autoPK is not used, attempt to find a primary key\n    if (!context.autoPK) {\n      // Check which attribute is used as primary key\n      for (var key in context.attributes) {\n        if (!util.object.hasOwnProperty(context.attributes[key], 'primaryKey')) continue;\n\n        // Check if custom primaryKey value is falsy\n        if (!context.attributes[key].primaryKey) continue;\n\n        // If a custom primary key is defined, use it\n        pk = key;\n        break;\n      }\n    }\n\n    // Check if options is an integer or string and normalize criteria\n    // to object, using the specified primary key field.\n    if (_.isNumber(options) || _.isString(options) || Array.isArray(options)) {\n      // Temporary store the given criteria\n      var pkCriteria = _.clone(options);\n\n      // Make the criteria object, with the primary key\n      options = {};\n      options[pk] = pkCriteria;\n    }\n\n    // If we're querying by primary key, create a coercion function for it\n    // depending on the data type of the key\n    if (options && options[pk]) {\n\n      var coercePK;\n      if(!context.attributes[pk]) {\n        return pk;\n      }\n      \n      if (context.attributes[pk].type == 'integer') {\n        coercePK = function(pk) {return +pk;};\n      } else if (context.attributes[pk].type == 'string') {\n        coercePK = function(pk) {return String(pk).toString();};\n\n      // If the data type is unspecified, return the key as-is\n      } else {\n        coercePK = function(pk) {return pk;};\n      }\n\n      // If the criteria is an array of PKs, coerce them all\n      if (Array.isArray(options[pk])) {\n        options[pk] = options[pk].map(coercePK);\n\n      // Otherwise just coerce the one\n      } else {\n        if (!_.isObject(options[pk])) {\n          options[pk] = coercePK(options[pk]);\n        }\n      }\n\n    }\n\n    return options;\n\n  },\n\n  // Normalize the different ways of specifying criteria into a uniform object\n  criteria: function(origCriteria) {\n    var criteria = _.cloneDeep(origCriteria);\n\n    // If original criteria is already false, keep it that way.\n    if (criteria === false) return criteria;\n\n    if (!criteria) {\n      return {\n        where: null\n      };\n    }\n\n    // Let the calling method normalize array criteria. It could be an IN query\n    // where we need the PK of the collection or a .findOrCreateEach\n    if (Array.isArray(criteria)) return criteria;\n\n    // Empty undefined values from criteria object\n    _.each(criteria, function(val, key) {\n      if (_.isUndefined(val)) criteria[key] = null;\n    });\n\n    // Convert non-objects (ids) into a criteria\n    // TODO: use customizable primary key attribute\n    if (!_.isObject(criteria)) {\n      criteria = {\n        id: +criteria || criteria\n      };\n    }\n\n    if (_.isObject(criteria) && !criteria.where && criteria.where !== null) {\n      criteria = { where: criteria };\n    }\n\n    // Return string to indicate an error\n    if (!_.isObject(criteria)) throw new WLUsageError('Invalid options/criteria :: ' + criteria);\n\n    // If criteria doesn't seem to contain operational keys, assume all the keys are criteria\n    if (!criteria.where && !criteria.joins && !criteria.join && !criteria.limit && !criteria.skip &&\n      !criteria.sort && !criteria.sum && !criteria.average &&\n      !criteria.groupBy && !criteria.min && !criteria.max && !criteria.select) {\n\n      // Delete any residuals and then use the remaining keys as attributes in a criteria query\n      delete criteria.where;\n      delete criteria.joins;\n      delete criteria.join;\n      delete criteria.limit;\n      delete criteria.skip;\n      delete criteria.sort;\n      criteria = {\n        where: criteria\n      };\n\n    // If where is null, turn it into an object\n    } else if (_.isNull(criteria.where)) criteria.where = {};\n\n\n    // Move Limit, Skip, sort outside the where criteria\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'limit')) {\n      criteria.limit = parseInt(_.clone(criteria.where.limit), 10);\n      if (criteria.limit < 0) criteria.limit = 0;\n      delete criteria.where.limit;\n    } else if (hop(criteria, 'limit')) {\n      criteria.limit = parseInt(criteria.limit, 10);\n      if (criteria.limit < 0) criteria.limit = 0;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'skip')) {\n      criteria.skip = parseInt(_.clone(criteria.where.skip), 10);\n      if (criteria.skip < 0) criteria.skip = 0;\n      delete criteria.where.skip;\n    } else if (hop(criteria, 'skip')) {\n      criteria.skip = parseInt(criteria.skip, 10);\n      if (criteria.skip < 0) criteria.skip = 0;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'sort')) {\n      criteria.sort = _.clone(criteria.where.sort);\n      delete criteria.where.sort;\n    }\n\n    // Pull out aggregation keys from where key\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'sum')) {\n      criteria.sum = _.clone(criteria.where.sum);\n      delete criteria.where.sum;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'average')) {\n      criteria.average = _.clone(criteria.where.average);\n      delete criteria.where.average;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'groupBy')) {\n      criteria.groupBy = _.clone(criteria.where.groupBy);\n      delete criteria.where.groupBy;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'min')) {\n      criteria.min = _.clone(criteria.where.min);\n      delete criteria.where.min;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'max')) {\n      criteria.max = _.clone(criteria.where.max);\n      delete criteria.where.max;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'select')) {\n      criteria.select = _.clone(criteria.where.select);\n      delete criteria.where.select;\n    }\n\n    // If WHERE is {}, always change it back to null\n    if (criteria.where && _.keys(criteria.where).length === 0) {\n      criteria.where = null;\n    }\n\n    // If an IN was specified in the top level query and is an empty array, we can return an\n    // empty object without running the query because nothing will match anyway. Let's return\n    // false from here so the query knows to exit out.\n    if (criteria.where) {\n      var falsy = false;\n      Object.keys(criteria.where).forEach(function(key) {\n        if (Array.isArray(criteria.where[key]) && criteria.where[key].length === 0) {\n          falsy = true;\n        }\n      });\n\n      if (falsy) return false;\n    }\n\n    // If an IN was specified inside an OR clause and is an empty array, remove it because nothing will\n    // match it anyway and it can prevent errors in the adapters\n    if (criteria.where && hop(criteria.where, 'or')) {\n\n      // Ensure `or` is an array\n      if (!_.isArray(criteria.where.or)) {\n        throw new WLUsageError('An `or` clause in a query should be specified as an array of subcriteria');\n      }\n\n      var _clone = _.cloneDeep(criteria.where.or);\n      criteria.where.or.forEach(function(clause, i) {\n        Object.keys(clause).forEach(function(key) {\n          if (Array.isArray(clause[key]) && clause[key].length === 0) {\n            _clone.splice(i, 1);\n          }\n        });\n      });\n\n      criteria.where.or = _clone;\n    }\n\n    // Normalize sort criteria\n    if (hop(criteria, 'sort') && criteria.sort !== null) {\n\n      // Split string into attr and sortDirection parts (default to 'asc')\n      if (_.isString(criteria.sort)) {\n        var parts = criteria.sort.split(' ');\n\n        // Set default sort to asc\n        parts[1] = parts[1] ? parts[1].toLowerCase() : 'asc';\n\n        // Expand criteria.sort into object\n        criteria.sort = {};\n        criteria.sort[parts[0]] = parts[1];\n      }\n\n      // normalize ASC/DESC notation\n      Object.keys(criteria.sort).forEach(function(attr) {\n\n        if (_.isString(criteria.sort[attr])) {\n          criteria.sort[attr] = criteria.sort[attr].toLowerCase();\n\n          // Throw error on invalid sort order\n          if (criteria.sort[attr] !== 'asc' && criteria.sort[attr] !== 'desc') {\n            throw new WLUsageError('Invalid sort criteria :: ' + criteria.sort);\n          }\n        }\n\n        if (criteria.sort[attr] === 'asc') criteria.sort[attr] = 1;\n        if (criteria.sort[attr] === 'desc') criteria.sort[attr] = -1;\n      });\n\n      // normalize binary sorting criteria\n      Object.keys(criteria.sort).forEach(function(attr) {\n        if (criteria.sort[attr] === 0) criteria.sort[attr] = -1;\n      });\n\n      // Verify that user either specified a proper object\n      // or provided explicit comparator function\n      if (!_.isObject(criteria.sort) && !_.isFunction(criteria.sort)) {\n        throw new WLUsageError('Invalid sort criteria for ' + attrName + ' :: ' + direction);\n      }\n    }\n\n    return criteria;\n  },\n\n  // Normalize the capitalization and % wildcards in a like query\n  // Returns false if criteria is invalid,\n  // otherwise returns normalized criteria obj.\n  // Enhancer is an optional function to run on each criterion to preprocess the string\n  likeCriteria: function(criteria, attributes, enhancer) {\n\n    // Only accept criteria as an object\n    if (criteria !== Object(criteria)) return false;\n\n    criteria = _.clone(criteria);\n\n    if (!criteria.where) criteria = { where: criteria };\n\n    // Apply enhancer to each\n    if (enhancer) criteria.where = util.objMap(criteria.where, enhancer);\n\n    criteria.where = { like: criteria.where };\n\n    return criteria;\n  },\n\n\n  // Normalize a result set from an adapter\n  resultSet: function(resultSet) {\n\n    // Ensure that any numbers that can be parsed have been\n    return util.pluralize(resultSet, numberizeModel);\n  },\n\n\n  /**\n   * Normalize the different ways of specifying callbacks in built-in Waterline methods.\n   * Switchbacks vs. Callbacks (but not deferred objects/promises)\n   *\n   * @param  {Function|Handlers} cb\n   * @return {Handlers}\n   */\n  callback: function(cb) {\n\n    // Build modified callback:\n    // (only works for functions currently)\n    var wrappedCallback;\n    if (_.isFunction(cb)) {\n      wrappedCallback = function(err) {\n\n        // If no error occurred, immediately trigger the original callback\n        // without messing up the context or arguments:\n        if (!err) {\n          return applyInOriginalCtx(cb, arguments);\n        }\n\n        // If an error argument is present, upgrade it to a WLError\n        // (if it isn't one already)\n        err = errorify(err);\n\n        var modifiedArgs = Array.prototype.slice.call(arguments, 1);\n        modifiedArgs.unshift(err);\n\n        // Trigger callback without messing up the context or arguments:\n        return applyInOriginalCtx(cb, modifiedArgs);\n      };\n    }\n\n\n    //\n    // TODO: Make it clear that switchback support it experimental.\n    //\n    // Push switchback support off until >= v0.11\n    // or at least add a warning about it being a `stage 1: experimental`\n    // feature.\n    //\n\n    if (!_.isFunction(cb)) wrappedCallback = cb;\n    return switchback(wrappedCallback, {\n      invalid: 'error', // Redirect 'invalid' handler to 'error' handler\n      error: function _defaultErrorHandler() {\n        console.error.apply(console, Array.prototype.slice.call(arguments));\n      }\n    });\n\n\n    // ????\n    // TODO: determine support target for 2-way switchback usage\n    // ????\n\n    // Allow callback to be -HANDLED- in different ways\n    // at the app-level.\n    // `cb` may be passed in (at app-level) as either:\n    //    => an object of handlers\n    //    => or a callback function\n    //\n    // If a callback function was provided, it will be\n    // automatically upgraded to a simplerhandler object.\n    // var cb_fromApp = switchback(cb);\n\n    // Allow callback to be -INVOKED- in different ways.\n    // (adapter def)\n    // var cb_fromAdapter = cb_fromApp;\n\n  }\n};\n\n// If any attribute looks like a number, but it's a string\n// cast it to a number\nfunction numberizeModel(model) {\n  return util.objMap(model, numberize);\n}\n\n\n// If specified attr looks like a number, but it's a string, cast it to a number\nfunction numberize(attr) {\n  if (_.isString(attr) && isNumbery(attr) && parseInt(attr, 10) < Math.pow(2, 53)) return +attr;\n  else return attr;\n}\n\n// Returns whether this value can be successfully parsed as a finite number\nfunction isNumbery(value) {\n  return Math.pow(+value, 2) > 0;\n}\n\n// Replace % with %%%\nfunction escapeLikeQuery(likeCriterion) {\n  return likeCriterion.replace(/[^%]%[^%]/g, '%%%');\n}\n\n// Replace %%% with %\nfunction unescapeLikeQuery(likeCriterion) {\n  return likeCriterion.replace(/%%%/g, '%');\n}\n\n\n/**\n * Like _.partial, but accepts an array of arguments instead of\n * comma-seperated args (if _.partial is `call`, this is `apply`.)\n * The biggest difference from `_.partial`, other than the usage,\n * is that this helper actually CALLS the partially applied function.\n *\n * This helper is mainly useful for callbacks.\n *\n * @param  {Function} fn   [description]\n * @param  {[type]}   args [description]\n * @return {[type]}        [description]\n */\n\nfunction applyInOriginalCtx(fn, args) {\n  return (_.partial.apply(null, [fn].concat(Array.prototype.slice.call(args))))();\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/error/index.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('lodash');\nvar WLError = require('./WLError');\nvar WLValidationError = require('./WLValidationError');\n\n\n/**\n * A classifier which normalizes a mystery error into a simple,\n * consistent format.  This ensures that our instance which is\n * \"new\"-ed up belongs to one of a handful of distinct categories\n * and has a predictable method signature and properties.\n *\n * The returned error instance will always be or extend from\n * `WLError` (which extends from `Error`)\n *\n * NOTE:\n * This method should eventually be deprecated in a\n * future version of Waterline.  It exists to help\n * w/ error type negotiation.  In general, Waterline\n * should use WLError, or errors which extend from it\n * to construct error objects of the appropriate type.\n * In other words, no ** new ** errors should need to\n * be wrapped in a call to `errorify` - instead, code\n * necessary to handle any new error conditions should\n * construct a `WLError` directly and return that.\n *\n * @param  {???} err\n * @return {WLError}\n */\nmodule.exports = function errorify(err) {\n\n  // If specified `err` is already a WLError, just return it.\n  if (typeof err === 'object' && err instanceof WLError) return err;\n\n  return duckType(err);\n};\n\n\n/**\n * Determine which type of error we're working with.\n * Err... using hacks.\n *\n * @return {[type]} [description]\n */\nfunction duckType(err) {\n\n  // Validation or constraint violation error (`E_VALIDATION`)\n  //\n  // i.e. detected before talking to adapter, like `minLength`\n  // i.e. constraint violation reported by adapter, like `unique`\n  if (/* _isValidationError(err) || */ _isConstraintViolation(err)) {\n\n    // Dress `unique` rule violations to be consistent with other\n    // validation errors.\n    return new WLValidationError(err);\n  }\n\n  // Unexpected miscellaneous error  (`E_UNKNOWN`)\n  //\n  // (i.e. helmet fire. The database crashed or something. Or there's an adapter\n  //  bug. Or a bug in WL core.)\n  return new WLError({\n    originalError: err\n  });\n}\n\n\n/**\n * @param  {?} err\n * @return {Boolean} whether this is an adapter-level constraint\n * violation (e.g. `unique`)\n */\nfunction _isConstraintViolation(err) {\n\n  // If a proper error code is specified, this error can be classified.\n  if (err && typeof err === 'object' && err.code === 'E_UNIQUE') {\n    return true;\n  }\n\n  // Otherwise, there is not enough information to call this a\n  // constraint violation error and provide proper explanation to\n  // the architect.\n  else return false;\n}\n\n\n// /**\n//  * @param  {?} err\n//  * @return {Boolean} whether this is a validation error (e.g. minLength exceeded for attribute)\n//  */\n// function _isValidationError(err) {\n//   return _.isObject(err) && err.ValidationError;\n// }\n\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/ddl/index.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar normalize = require('../../utils/normalize');\nvar getRelations = require('../../utils/getRelations');\nvar hasOwnProperty = require('../../utils/helpers').object.hasOwnProperty;\n\n\n/**\n * DDL Adapter Normalization\n */\n\nmodule.exports = {\n\n  define: function(cb) {\n    var self = this;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var errMsg = 'No define() method defined in adapter!';\n\n    // Grab attributes from definition\n    var schema = _.clone(this.query._schema.schema) || {};\n\n    // Find any junctionTables that reference this collection\n    var relations = getRelations({\n      schema: self.query.waterline.schema,\n      parentCollection: self.collection\n    });\n\n    //\n    // TODO: if junction tables don't exist, define them\n    // console.log(relations);\n    //\n\n    // Verify that collection doesn't already exist\n    // and then define it and trigger callback\n    this.describe(function(err, existingAttributes) {\n      if (err) return cb(err);\n      if (existingAttributes) return cb(new Error('Trying to define a collection (' + self.collection + ') which already exists.'));\n\n      // Remove hasMany association keys before sending down to adapter\n      Object.keys(schema).forEach(function(key) {\n        if (schema[key].type) return;\n        delete schema[key];\n      });\n\n      // Find the connection to run this on\n      if (!hasOwnProperty(self.dictionary, 'define')) return cb();\n\n      var connName = self.dictionary.define;\n      var adapter = self.connections[connName]._adapter;\n\n      if (!hasOwnProperty(adapter, 'define')) return cb(new Error(errMsg));\n      adapter.define(connName, self.collection, schema, cb);\n    });\n  },\n\n  describe: function(cb) {\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No describe() method defined in adapter!';\n\n    // Find the connection to run this on\n    // NOTE: if `describe` doesn't exist, an error is not being returned.\n    if (!hasOwnProperty(this.dictionary, 'describe')) return cb();\n\n    var connName = this.dictionary.describe;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'describe')) return cb(new Error(err));\n    adapter.describe(connName, this.collection, cb);\n  },\n\n  drop: function(relations, cb) {\n    // Allow relations to be optional\n    if (typeof relations === 'function') {\n      cb = relations;\n      relations = [];\n    }\n\n    relations = [];\n\n    //\n    // TODO:\n    // Use a more normalized strategy to get relations so we can omit the extra argument above.\n    // e.g. getRelations({ schema: self.query.waterline.schema, parentCollection: self.collection });\n    //\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No drop() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'drop')) return cb(new Error(err));\n\n    var connName = this.dictionary.drop;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'drop')) return cb(new Error(err));\n    adapter.drop(connName, this.collection, relations, cb);\n  },\n\n  alter: function(cb) {\n\n    // Normalize arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No alter() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'alter')) return cb(new Error(err));\n\n    var connName = this.dictionary.alter;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'alter')) return cb(new Error(err));\n    adapter.alter(connName, this.collection, cb);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/getRelations.js":"/**\n * getRelations\n *\n * Find any `junctionTables` that reference the parent collection.\n *\n * @param  {[type]} options [description]\n *    @option parentCollection\n *    @option schema\n * @return {[type]}         [relations]\n */\n\nmodule.exports = function getRelations(options) {\n\n  var schema = options.schema;\n  var relations = [];\n\n  Object.keys(schema).forEach(function(collection) {\n    var collectionSchema = schema[collection];\n    if (!collectionSchema.hasOwnProperty('junctionTable')) return;\n\n    Object.keys(collectionSchema.attributes).forEach(function(key) {\n      if (!collectionSchema.attributes[key].hasOwnProperty('foreignKey')) return;\n      if (collectionSchema.attributes[key].references !== options.parentCollection) return;\n      relations.push(collection);\n    });\n  });\n\n  return relations;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/compoundQueries.js":"/**\n * Compound Queries Adapter Normalization\n */\n\nvar _ = require('lodash');\nvar normalize = require('../utils/normalize');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\nmodule.exports = {\n\n  findOrCreate: function(criteria, values, cb) {\n    var self = this;\n    var connName,\n        adapter;\n\n    // If no values were specified, use criteria\n    if (!values) values = criteria.where ? criteria.where : criteria;\n\n    // Normalize Arguments\n    criteria = normalize.criteria(criteria);\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No find() or create() method defined in adapter!';\n\n    // Custom user adapter behavior\n    if (hasOwnProperty(this.dictionary, 'findOrCreate')) {\n      connName = this.dictionary.findOrCreate;\n      adapter = this.connections[connName]._adapter;\n\n      if (hasOwnProperty(adapter, 'findOrCreate')) {\n        return adapter.findOrCreate(connName, this.collection, values, cb);\n      }\n    }\n\n    // Default behavior\n    // WARNING: Not transactional!  (unless your data adapter is)\n    this.findOne(criteria, function(err, result) {\n      if (err) return cb(err);\n      if (result) return cb(null, result[0]);\n\n      self.create(values, cb);\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/aggregateQueries.js":"/**\n * Aggregate Queries Adapter Normalization\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar normalize = require('../utils/normalize');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\nmodule.exports = {\n\n  // If an optimized createEach exists, use it, otherwise use an asynchronous loop with create()\n  createEach: function(valuesList, cb) {\n    var self = this;\n    var connName,\n        adapter;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No createEach() or create() method defined in adapter!';\n\n    // Custom user adapter behavior\n    if (hasOwnProperty(this.dictionary, 'createEach')) {\n      connName = this.dictionary.createEach;\n      adapter = this.connections[connName]._adapter;\n\n      if (hasOwnProperty(adapter, 'createEach')) {\n        return adapter.createEach(connName, this.collection, valuesList, cb);\n      }\n    }\n\n    // Default behavior\n    // WARNING: Not transactional!  (unless your data adapter is)\n    var results = [];\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'create')) return cb(new Error(err));\n\n    connName = this.dictionary.create;\n    adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'create')) return cb(new Error(err));\n\n    async.eachSeries(valuesList, function(values, cb) {\n      adapter.create(connName, self.collection, values, function(err, row) {\n        if (err) return cb(err);\n        results.push(row);\n        cb();\n      });\n    }, function(err) {\n      if (err) return cb(err);\n      cb(null, results);\n    });\n  },\n\n  // If an optimized findOrCreateEach exists, use it, otherwise use an asynchronous loop with create()\n  findOrCreateEach: function(attributesToCheck, valuesList, cb) {\n    var self = this;\n    var connName;\n    var adapter;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    var isObjectArray = false;\n\n    if (_.isObject(attributesToCheck[0])) {\n      if (attributesToCheck.length > 1 &&\n        attributesToCheck.length !== valuesList.length) {\n        return cb(new Error('findOrCreateEach: The two passed arrays have to be of the same length.'));\n      }\n      isObjectArray = true;\n    }\n\n    // Clone sensitive data\n    attributesToCheck = _.clone(attributesToCheck);\n    valuesList = _.clone(valuesList);\n\n    // Custom user adapter behavior\n    if (hasOwnProperty(this.dictionary, 'findOrCreateEach')) {\n      connName = this.dictionary.findOrCreateEach;\n      adapter = this.connections[connName]._adapter;\n\n      if (hasOwnProperty(adapter, 'findOrCreateEach')) {\n        return adapter.findOrCreateEach(connName, this.collection, valuesList, cb);\n      }\n    }\n\n    // Build a list of models\n    var models = [];\n    var i = 0;\n\n    async.eachSeries(valuesList, function(values, cb) {\n      if (!_.isObject(values)) return cb(new Error('findOrCreateEach: Unexpected value in valuesList.'));\n      // Check that each of the criteria keys match:\n      // build a criteria query\n      var criteria = {};\n\n      if (isObjectArray) {\n        if (_.isObject(attributesToCheck[i])) {\n          Object.keys(attributesToCheck[i]).forEach(function(attrName) {\n            criteria[attrName] = values[attrName];\n          });\n          if (attributesToCheck.length > 1) {\n            i++;\n          }\n        } else {\n          return cb(new Error('findOrCreateEach: Element ' + i + ' in attributesToCheck is not an object.'));\n        }\n      } else {\n        attributesToCheck.forEach(function(attrName) {\n          criteria[attrName] = values[attrName];\n        });\n      }\n\n      return self.findOrCreate.call(self, criteria, values, function(err, model) {\n        if (err) return cb(err);\n\n        // Add model to list\n        if (model) models.push(model);\n\n        cb(null, model);\n      });\n    }, function(err) {\n      if (err) return cb(err);\n      cb(null, models);\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/setupTeardown.js":"/**\n * Setup and Teardown Adapter Normalization\n */\n\nmodule.exports = {\n\n  // Teardown is fired once-per-adapter\n  // Should tear down any open connections, etc. for each collection\n  // (i.e. tear down any remaining connections to the underlying data model)\n  // (i.e. flush data to disk before the adapter shuts down)\n  teardown: function(cb) {\n    if (this.adapter.teardown) {\n      return this.adapter.teardown.apply(this, arguments);\n    };\n\n    cb();\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/sync/index.js":"// TODO: probably can eliminate this file\nmodule.exports = {\n  migrateDrop: require('./strategies/drop.js'),\n  migrateAlter: require('./strategies/alter.js'),\n  migrateCreate: require('./strategies/create.js'),\n  migrateSafe: require('./strategies/safe.js')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/sync/strategies/drop.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar getRelations = require('../../../utils/getRelations');\n\n\n/**\n * Drop and recreate collection\n *\n * @param  {Function} cb\n */\n\nmodule.exports = function drop(cb) {\n  var self = this;\n\n  // Refuse to run this migration strategy in production.\n  if (process.env.NODE_ENV === 'production') {\n    return cb(new Error('`migrate: \"drop\"` strategy is not supported in production, please change to `migrate: \"safe\"`.'));\n  }\n\n  // Find any junctionTables that reference this collection\n  // var relations = getRelations({\n  //   schema: self.query.waterline.schema,\n  //   parentCollection: self.collection\n  // });\n\n  // Pass along relations to the drop method\n  // console.log('Dropping ' + self.collection);\n  this.drop(function afterDrop(err, data) {\n    if (err) return cb(err);\n\n    self.define(function() {\n      cb.apply(null, Array.prototype.slice.call(arguments));\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/sync/strategies/alter.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar getRelations = require('../../../utils/getRelations');\n\n\n/**\n * Try and synchronize the underlying physical-layer schema\n * to work with our app's collections. (i.e. models)\n *\n * @param  {Function} cb\n */\nmodule.exports = function(cb) {\n  var self = this;\n\n  // Refuse to run this migration strategy in production.\n  if (process.env.NODE_ENV === 'production') {\n    return cb(new Error('`migrate: \"alter\"` strategy is not supported in production, please change to `migrate: \"safe\"`.'));\n  }\n\n  // Find any junctionTables that reference this collection\n  var relations = getRelations({\n    schema: self.query.waterline.schema,\n    parentCollection: self.collection\n  });\n\n  var backupData;\n\n  // Check that collection exists--\n  self.describe(function afterDescribe(err, attrs) {\n\n    if (err) return cb(err);\n\n    // if it doesn't go ahead and add it and get out\n    if (!attrs) return self.define(cb);\n\n    var collectionName = _.find(self.query.waterline.schema, {tableName: self.collection}).identity;\n\n    // Create a mapping of column names -> attribute names\n    var columnNamesMap = _.reduce(self.query.waterline.schema[collectionName].attributes, function(memo, val, key) {\n      // If the attribute has a custom column name, use it as the key for the mapping\n      if (val.columnName) {\n        memo[val.columnName] = key;\n      // Otherwise just use the attribute name\n      } else {\n        memo[key] = key;\n      }\n      return memo;\n    }, {});\n\n    // Transform column names into attribute names using the columnNamesMap,\n    // removing attributes that no longer exist (they will be dropped)\n    attrs = _.compact(_.keys(attrs).map(function(key) {\n      return columnNamesMap[key];\n    }));\n\n    //\n    // TODO:\n    // Take a look and see if anything important has changed.\n    // If it has (at all), we still have to follow the naive strategy below,\n    // but it will at least save time in the general case.\n    // (because it really sucks to have to wait for all of this to happen\n    //  every time you initialize Waterline.)\n    //\n\n\n    //\n    // OK so we have to fix up the schema and migrate the data...\n    //\n    // ... we'll let Waterline do it for us.\n    //\n    // Load all data from this collection into memory.\n    // If this doesn't work, crash to avoid corrupting any data.\n    // (see `waterline/lib/adapter/ddl/README.md` for more info about this)\n    //\n    // Make sure we only select the existing keys for the schema.\n    // The default \"find all\" will select each attribute in the schema, which\n    // now includes attributes that haven't been added to the table yet, so\n    // on SQL databases the query will fail with \"unknown field\" error.\n    //\n    var hasSchema = self.query.hasSchema;\n\n    // If we have a schema, make sure we only select the existing keys for the schema.\n    // The default \"find all\" will select each attribute in the schema, which\n    // now includes attributes that haven't been added to the table yet, so\n    // on SQL databases the query will fail with \"unknown field\" error.\n    //\n    // If we don't have a schema then we need to select all the values to make\n    // sure we don't lose data in the process.\n    var queryCriteria;\n\n    if (hasSchema) {\n      queryCriteria = {select: attrs};\n    } else {\n      queryCriteria = {};\n    }\n\n    self.find(queryCriteria, function(err, existingData) {\n\n      if (err) {\n        //\n        // TODO:\n        // If this was a memory error, log a more useful error\n        // explaining what happened.\n        //\n        return cb(err);\n      }\n\n      //\n      // From this point forward, we must be very careful.\n      //\n      backupData = _.cloneDeep(existingData, function dealWithBuffers(val) {\n        if (val instanceof Buffer) {\n          return val.slice();\n        }\n      });\n\n\n      // Check to see if there is anything obviously troublesome\n      // that will cause the drop and redefinition of our schemaful\n      // collections to fail.\n      // (i.e. violation of uniqueness constraints)\n      var attrs = self.query.waterline.collections[self.identity]._attributes;\n      var pk = self.query.waterline.collections[self.identity].primaryKey;\n      var attrsAsArray = _.reduce(_.cloneDeep(attrs), function(memo, attrDef, attrName) {\n        attrDef.name = attrName;\n        memo.push(attrDef);\n        return memo;\n      }, []);\n      var uniqueAttrs = _.where(attrsAsArray, {unique: true});\n      async.each(uniqueAttrs, function(uniqueAttr, each_cb) {\n        var uniqueData = _.uniq(_.pluck(existingData, uniqueAttr.name));\n\n        // Remove any unique values who have their values set to undefined or null\n        var cleansedExistingData = _.filter(existingData, function(val) {\n          return [undefined, null].indexOf(val[uniqueAttr.name]) < 0;\n        });\n\n        // Remove any undefined or null values from the unique data\n        var cleansedUniqueData = _.filter(uniqueData, function(val) {\n          return [undefined, null].indexOf(val) < 0;\n        });\n\n        if (cleansedUniqueData.length < cleansedExistingData.length) {\n          // Some existing data violates a new uniqueness constraint\n          var prompt = require('prompt');\n          prompt.start();\n          console.log(\n            'One or more existing records in your database violate ' +\n            'a new uniqueness constraint\\n' +\n            'on `' + uniqueAttr.name + '` ' +\n            'in your `' + self.identity + '` model.');\n          console.log();\n          console.log('Should we automatically remove duplicates?');\n          console.log();\n          console.log('** WARNING: DO NOT TYPE \"y\" IF YOU ARE WORKING WITH PRODUCTION DATA **');\n          // var laptimer = setInterval(function beepbeepbeepbeep(){\n          //   process.stdout.write('\\u0007');\n          // }, 1500);\n          prompt.get(['y/n'], function(err, results) {\n            // clearInterval(laptimer);\n            if (err) return each_cb(err);\n            var wasConfirmedByUser = _.isString(results['y/n']) && results['y/n'].match(/y/);\n            if (wasConfirmedByUser) {\n\n              // Wipe out duplicate records in `backupData` and continue\n              // to perform the automigration\n              var diff = _.difference(existingData, _.uniq(existingData, false, uniqueAttr.name));\n\n              var destroyCriteria = {};\n              destroyCriteria[pk] = _.pluck(diff, pk);\n              // console.log(diff, '\\n', destroyCriteria);\n              backupData = _.remove(backupData, function(datum) {\n                return !_.contains(destroyCriteria[pk], datum[pk]);\n              });\n              return each_cb();\n              // console.log(backupData);\n              // throw new Error();\n              // self.query.waterline.collections[self.collection].destroy(destroyCriteria).exec(each_cb);\n            } else return each_cb(new Error('Auto-migration aborted. Please migrate your data manually and then try this again.'));\n          });\n        } else return each_cb();\n      }, function afterAsyncEach(err) {\n        if (err) return cb(err);\n\n        // Now we'll drop the collection.\n        self.drop(relations, function(err) {\n          if (err) return uhoh(err, backupData, cb);\n\n          // Now we'll redefine the collection.\n          self.define(function(err) {\n            if (err) return uhoh(err, backupData, cb);\n\n            // Now we'll create the `backupData` again,\n            // being careful not to run any lifecycle callbacks\n            // and disable automatic updating of `createdAt` and\n            // `updatedAt` attributes:\n            //\n            // ((((TODO: actually be careful about said things))))\n            //\n            self.createEach(backupData, function(err) {\n              if (err) return uhoh(err, backupData, cb);\n\n              // Done.\n              return cb();\n            });\n\n          }); // </define>\n        }); // </drop>\n      }); // </find>\n    });\n\n\n    //\n    // The old way-- (doesn't always work, and is way more\n    // complex than we should spend time on for now)\n    //\n    //   ||      ||      ||      ||      ||      ||\n    //   \\/      \\/      \\/      \\/      \\/      \\/\n    //\n    // Otherwise, if it *DOES* exist, we'll try and guess what changes need to be made\n    // self.alter(function(err) {\n    //   if (err) return cb(err);\n    //   cb();\n    // });\n\n  });\n};\n\n\n/**\n * uh oh.\n *\n * If we can't persist the data again, we'll log an error message, then\n * stream the data to stdout as JSON to make sure that it gets persisted\n * SOMEWHERE at least.\n *\n * (this is another reason this automigration strategy cannot be used in\n * production currently..)\n *\n * @param  {[type]}   err        [description]\n * @param  {[type]}   backupData [description]\n * @param  {Function} cb         [description]\n * @return {[type]}              [description]\n */\n\nfunction uhoh(err, backupData, cb) {\n\n  console.error('Waterline encountered a fatal error when trying to perform the `alter` auto-migration strategy.');\n  console.error('In a couple of seconds, the data (cached in memory) will be logged to stdout.');\n  console.error('(a failsafe put in place to preserve development data)');\n  console.error();\n  console.error('In the mean time, here\\'s the error:');\n  console.error();\n  console.error(err);\n  console.error();\n  console.error();\n\n  setTimeout(function() {\n    console.error('================================');\n    console.error('Data backup:');\n    console.error('================================');\n    console.error('');\n    console.log(backupData);\n    return cb(err);\n  }, 1200);\n\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/sync/strategies/create.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar hasOwnProperty = require('../../../utils/helpers').object.hasOwnProperty;\n\n\n/**\n * Try and synchronize the underlying physical-layer schema\n * in safely manner by only adding new collections and new attributes\n * to work with our app's collections. (i.e. models)\n *\n * @param  {Function} cb\n */\nmodule.exports = function(cb) {\n  var self = this;\n\n\n  // Check that collection exists\n  self.describe(function afterDescribe(err, attrs) {\n\n    if (err) return cb(err);\n\n    // if it doesn't go ahead and add it and get out\n    if (!attrs) return self.define(cb);\n\n    // Check if an addAttribute adapter method is defined\n    if (!hasOwnProperty(self.dictionary, 'addAttribute')) {\n      return cb();\n    }\n\n    // Find the relevant connections to run this on\n    var connName = self.dictionary.addAttribute;\n    var adapter = self.connections[connName]._adapter;\n\n    // Check if adapter has addAttribute method\n    if (!hasOwnProperty(adapter, 'addAttribute')) {\n      return cb();\n    }\n\n    // The collection we're working with\n    var collectionID = self.collection;\n\n    // Remove hasMany association keys before sending down to adapter\n    var schema = _.clone(self.query._schema.schema) || {};\n    Object.keys(schema).forEach(function(key) {\n      if (schema[key].type) return;\n      delete schema[key];\n    });\n\n    // Iterate through each attribute in the new definition\n    // Used for keeping track of previously undefined attributes\n    // when updating the data stored at the physical layer.\n    var newAttributes = _.reduce(schema, function checkAttribute(newAttributes, attribute, attrName) {\n      if (!attrs[attrName]) {\n        newAttributes[attrName] = attribute;\n      }\n      return newAttributes;\n    }, {});\n\n    // Add new attributes\n    async.eachSeries(_.keys(newAttributes), function(attrName, next) {\n      var attrDef = newAttributes[attrName];\n      adapter.addAttribute(connName, collectionID, attrName, attrDef, next);\n    }, cb);\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/sync/strategies/safe.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\n\n\n/**\n * Do absolutely nothing to the schema of the underlying datastore.\n *\n * @param  {Function} cb\n */\nmodule.exports = function(cb) {\n  cb();\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/adapter/stream.js":"/**\n * Module Dependencies\n */\n\nvar normalize = require('../utils/normalize');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\n/**\n * Stream Normalization\n */\n\nmodule.exports = {\n\n  // stream.write() is used to send data\n  // Must call stream.end() to complete stream\n  stream: function(criteria, stream) {\n\n    // Normalize Arguments\n    criteria = normalize.criteria(criteria);\n\n    // Build Default Error Message\n    var err = 'No stream() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'stream')) return stream.end(new Error(err));\n\n    var connName = this.dictionary.stream;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'stream')) return stream.end(new Error(err));\n    adapter.stream(connName, this.collection, criteria, stream);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/adapters.js":"/**\n * Mixes Custom Non-CRUD Adapter Methods into the prototype.\n */\n\nmodule.exports = function() {\n  var self = this;\n\n  Object.keys(this.connections).forEach(function(conn) {\n\n    var adapter = self.connections[conn]._adapter || {};\n\n    Object.keys(adapter).forEach(function(key) {\n\n      // Ignore the Identity Property\n      if (['identity', 'tableName'].indexOf(key) >= 0) return;\n\n      // Don't override keys that already exists\n      if (self[key]) return;\n\n      // Don't override a property, only functions\n      if (typeof adapter[key] != 'function') {\n        self[key] = adapter[key];\n        return;\n      }\n\n      // Apply the Function with passed in args and set this.identity as\n      // the first argument\n      self[key] = function() {\n\n        var tableName = self.tableName || self.identity;\n\n        // If this is the teardown method, just pass in the connection name,\n        // otherwise pass the connection and the tableName\n        var defaultArgs = key === 'teardown' ? [conn] : [conn, tableName];\n\n        // Concat self.identity with args (must massage arguments into a proper array)\n        // Use a normalized _tableName set in the core module.\n        var args = defaultArgs.concat(Array.prototype.slice.call(arguments));\n        return adapter[key].apply(self, args);\n      };\n    });\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/validate.js":"/**\n * Validation\n *\n * Used in create and update methods validate a model\n * Can also be used independently\n */\n\nvar _ = require('lodash');\nvar WLValidationError = require('../error/WLValidationError');\nvar async = require('async');\n\nmodule.exports = {\n\n  validate: function(values, presentOnly, cb) {\n    var self = this;\n\n    // Handle optional second arg\n    if (typeof presentOnly === 'function') {\n      cb = presentOnly;\n      presentOnly = false;\n    }\n\n    async.series([\n\n      // Run Before Validate Lifecycle Callbacks\n      function(cb) {\n        var runner = function(item, callback) {\n          item.call(self, values, function(err) {\n            if (err) return callback(err);\n            callback();\n          });\n        };\n\n        async.eachSeries(self._callbacks.beforeValidate, runner, function(err) {\n          if (err) return cb(err);\n          cb();\n        });\n      },\n\n      // Run Validation\n      function(cb) {\n        self._validator.validate(values, presentOnly, function _afterValidating(err, invalidAttributes) {\n          // If fatal error occurred, handle it accordingly.\n          if (err) {\n            return cb(err);\n          }\n\n          // Otherwise, check out the invalid attributes that were sent back.\n          //\n          // Create validation error here\n          // (pass in the invalid attributes as well as the collection's globalId)\n          if (invalidAttributes) {\n            return cb(new WLValidationError({\n              invalidAttributes: invalidAttributes,\n              model: self.globalId || self.adapter.identity\n            }));\n          }\n\n          cb();\n        });\n      },\n\n      // Run After Validate Lifecycle Callbacks\n      function(cb) {\n        var runner = function(item, callback) {\n          item(values, function(err) {\n            if (err) return callback(err);\n            callback();\n          });\n        };\n\n        async.eachSeries(self._callbacks.afterValidate, runner, function(err) {\n          if (err) return cb(err);\n          cb();\n        });\n      }\n\n    ], function(err) {\n      if (err) return cb(err);\n      cb();\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/ddl.js":"/**\n * DDL Queries\n */\n\nmodule.exports = {\n\n  /**\n   * Describe a collection\n   */\n\n  describe: function(cb) {\n    this.adapter.describe(cb);\n  },\n\n  /**\n   * Alter a table/set/etc\n   */\n\n  alter: function(attributes, cb) {\n    this.adapter.alter(attributes, cb);\n  },\n\n  /**\n   * Drop a table/set/etc\n   */\n\n  drop: function(cb) {\n    this.adapter.drop(cb);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/dql/index.js":"\n/**\n * Export DQL Methods\n */\n\nmodule.exports = {\n  create: require('./create'),\n  update: require('./update'),\n  destroy: require('./destroy'),\n  count: require('./count'),\n  join: require('./join')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/dql/create.js":"/**\n * Module Dependencies\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar utils = require('../../utils/helpers');\nvar Deferred = require('../deferred');\nvar callbacks = require('../../utils/callbacksRunner');\nvar nestedOperations = require('../../utils/nestedOperations');\nvar hop = utils.object.hasOwnProperty;\n\n\n/**\n * Create a new record\n *\n * @param {Object || Array} values for single model or array of multiple values\n * @param {Function} callback\n * @return Deferred object if no callback\n */\n\nmodule.exports = function(values, cb) {\n\n  var self = this;\n\n  // Handle Deferred where it passes criteria first\n  if (arguments.length === 3) {\n    var args = Array.prototype.slice.call(arguments);\n    cb = args.pop();\n    values = args.pop();\n  }\n\n  // Loop through values and pull out any buffers before cloning\n  var bufferValues = {};\n\n  _.each(_.keys(values), function(key) {\n    if (Buffer.isBuffer(values[key])) {\n      bufferValues[key] = values[key];\n    }\n  });\n\n  values = _.cloneDeep(values) || {};\n\n  // Replace clone keys with the buffer values\n  _.each(_.keys(bufferValues), function(key) {\n    values[key] = bufferValues[key];\n  });\n\n  // Remove all undefined values\n  if (_.isArray(values)) {\n    values = _.remove(values, undefined);\n  }\n\n  // Return Deferred or pass to adapter\n  if (typeof cb !== 'function') {\n    return new Deferred(this, this.create, {}, values);\n  }\n\n\n  // Handle Array of values\n  if (Array.isArray(values)) {\n    return this.createEach(values, cb);\n  }\n\n  // Process Values\n  var valuesObject = processValues.call(this, values);\n\n  // Create any of the belongsTo associations and set the foreign key values\n  createBelongsTo.call(this, valuesObject, function(err) {\n    if (err) return cb(err);\n\n    beforeCallbacks.call(self, valuesObject, function(err) {\n      if (err) return cb(err);\n      createValues.call(self, valuesObject, cb);\n    });\n  });\n};\n\n\n/**\n * Process Values\n *\n * @param {Object} values\n * @return {Object}\n */\n\nfunction processValues(values) {\n\n  // Set Default Values if available\n  for (var key in this.attributes) {\n    if ((!hop(values, key) || values[key] === undefined) && hop(this.attributes[key], 'defaultsTo')) {\n      var defaultsTo = this.attributes[key].defaultsTo;\n      values[key] = typeof defaultsTo === 'function' ? defaultsTo.call(values) : _.clone(defaultsTo);\n    }\n  }\n\n  // Pull out any associations in the values\n  var _values = _.cloneDeep(values);\n  var associations = nestedOperations.valuesParser.call(this, this.identity, this.waterline.schema, values);\n\n  // Replace associated models with their foreign key values if available.\n  // Unless the association has a custom primary key (we want to create the object)\n  values = nestedOperations.reduceAssociations.call(this, this.identity, this.waterline.schema, values, 'create');\n\n  // Cast values to proper types (handle numbers as strings)\n  values = this._cast.run(values);\n\n  return { values: values, originalValues: _values, associations: associations };\n}\n\n/**\n * Create BelongsTo Records\n *\n */\n\nfunction createBelongsTo(valuesObject, cb) {\n  var self = this;\n\n  async.each(valuesObject.associations.models, function(item, next) {\n\n    // Check if value is an object. If not don't try and create it.\n    if (!_.isPlainObject(valuesObject.values[item])) return next();\n\n    // Check for any transformations\n    var attrName = hop(self._transformer._transformations, item) ? self._transformer._transformations[item] : item;\n\n    var attribute = self._schema.schema[attrName];\n    var modelName;\n\n    if (hop(attribute, 'collection')) modelName = attribute.collection;\n    if (hop(attribute, 'model')) modelName = attribute.model;\n    if (!modelName) return next();\n\n    var model = self.waterline.collections[modelName];\n    var pkValue = valuesObject.originalValues[item][model.primaryKey];\n\n    var criteria = {};\n    criteria[model.primaryKey] = pkValue;\n\n    // If a pkValue if found, do a findOrCreate and look for a record matching the pk.\n    var query;\n    if (pkValue) {\n      query = model.findOrCreate(criteria, valuesObject.values[item]);\n    } else {\n      query = model.create(valuesObject.values[item]);\n    }\n\n    query.exec(function(err, val) {\n      if (err) return next(err);\n\n      // attach the new model's pk value to the original value's key\n      var pk = val[model.primaryKey];\n\n      valuesObject.values[item] = pk;\n      next();\n    });\n\n  }, cb);\n}\n\n/**\n * Run Before* Lifecycle Callbacks\n *\n * @param {Object} valuesObject\n * @param {Function} cb\n */\n\nfunction beforeCallbacks(valuesObject, cb) {\n  var self = this;\n\n  async.series([\n\n    // Run Validation with Validation LifeCycle Callbacks\n    function(cb) {\n      callbacks.validate(self, valuesObject.values, false, cb);\n    },\n\n    // Before Create Lifecycle Callback\n    function(cb) {\n      callbacks.beforeCreate(self, valuesObject.values, cb);\n    }\n\n  ], cb);\n\n}\n\n/**\n * Create Parent Record and any associated values\n *\n * @param {Object} valuesObject\n * @param {Function} cb\n */\n\nfunction createValues(valuesObject, cb) {\n  var self = this;\n  var date;\n\n  // Automatically add updatedAt and createdAt (if enabled)\n  if (self.autoCreatedAt) {\n    if (!valuesObject.values[self.autoCreatedAt]) {\n      date = date || new Date();\n      valuesObject.values[self.autoCreatedAt] = date;\n    }\n  }\n\n  if (self.autoUpdatedAt) {\n    if (!valuesObject.values[self.autoUpdatedAt]) {\n      date = date || new Date();\n      valuesObject.values[self.autoUpdatedAt] = date;\n    }\n  }\n\n  // Transform Values\n  valuesObject.values = self._transformer.serialize(valuesObject.values);\n\n  // Clean attributes\n  valuesObject.values = self._schema.cleanValues(valuesObject.values);\n\n  // Pass to adapter here\n  self.adapter.create(valuesObject.values, function(err, values) {\n    if (err) {\n      if (typeof err === 'object') { err.model = self._model.globalId; }\n      return cb(err);\n    }\n\n    // Unserialize values\n    values = self._transformer.unserialize(values);\n\n    // If no associations were used, run after\n    if (valuesObject.associations.collections.length === 0) return after(values);\n\n    var parentModel = new self._model(values);\n    nestedOperations.create.call(self, parentModel, valuesObject.originalValues, valuesObject.associations.collections, function(err) {\n      if (err) return cb(err);\n\n      return after(parentModel.toObject());\n    });\n\n\n    function after(values) {\n\n      // Run After Create Callbacks\n      callbacks.afterCreate(self, values, function(err) {\n        if (err) return cb(err);\n\n        // Return an instance of Model\n        var model = new self._model(values);\n        cb(null, model);\n      });\n    }\n\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/deferred.js":"/**\n * Deferred Object\n *\n * Used for building up a Query\n */\n\nvar util = require('util');\nvar Promise = require('bluebird');\nvar _ = require('lodash');\nvar normalize = require('../utils/normalize');\nvar utils = require('../utils/helpers');\nvar acyclicTraversal = require('../utils/acyclicTraversal');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n// Alias \"catch\" as \"fail\", for backwards compatibility with projects\n// that were created using Q\nPromise.prototype.fail = Promise.prototype.catch;\n\nvar Deferred = module.exports = function(context, method, criteria, values) {\n\n  if (!context) return new Error('Must supply a context to a new Deferred object. Usage: new Deferred(context, method, criteria)');\n  if (!method) return new Error('Must supply a method to a new Deferred object. Usage: new Deferred(context, method, criteria)');\n\n  this._context = context;\n  this._method = method;\n  this._criteria = criteria;\n  this._values = values || null;\n\n  this._deferred = null; // deferred object for promises\n\n  return this;\n};\n\n\n/**\n * Add join clause(s) to the criteria object to populate\n * the specified alias all the way down (or at least until a\n * circular pattern is detected.)\n *\n * @param  {String} keyName  [the initial alias aka named relation]\n * @param  {Object} criteria [optional]\n * @return this\n * @chainable\n *\n * WARNING:\n * This method is not finished yet!!\n */\nDeferred.prototype.populateDeep = function(keyName, criteria) {\n\n  // The identity of the initial model\n  var identity = this._context.identity;\n\n  // The input schema\n  var schema = this._context.waterline.schema;\n\n  // Kick off recursive function to traverse the schema graph.\n  var plan = acyclicTraversal(schema, identity, keyName);\n\n  // TODO: convert populate plan into a join plan\n  // this._criteria.joins = ....\n\n  // TODO: also merge criteria object into query\n\n  return this;\n};\n\n/**\n * Populate all associations of a collection.\n *\n * @return this\n * @chainable\n */\nDeferred.prototype.populateAll = function(criteria) {\n  var self = this;\n  this._context.associations.forEach(function(association) {\n    self.populate(association.alias, criteria);\n  });\n  return this;\n\n};\n\n/**\n * Add a `joins` clause to the criteria object.\n *\n * Used for populating associations.\n *\n * @param {String|Array} key, the key to populate or array of string keys\n * @return this\n * @chainable\n */\n\nDeferred.prototype.populate = function(keyName, criteria) {\n\n  var self = this;\n  var joins = [];\n  var pk = 'id';\n  var attr;\n  var join;\n\n  // Adds support for arrays into keyName so that a list of\n  // populates can be passed\n  if (_.isArray(keyName)) {\n    keyName.forEach(function(populate) {\n      self.populate(populate, criteria);\n    });\n    return this;\n  }\n  \n  // Normalize sub-criteria\n  try {\n    criteria = normalize.criteria(criteria);\n\n    ////////////////////////////////////////////////////////////////////////\n    // TODO:\n    // instead of doing this, target the relevant pieces of code\n    // with weird expectations and teach them a lesson\n    // e.g. `lib/waterline/query/finders/operations.js:665:12`\n    // (delete userCriteria.sort)\n    //\n    // Except make sure `where` exists\n    criteria.where = criteria.where === false ? false : (criteria.where || {});\n    ////////////////////////////////////////////////////////////////////////\n\n  } catch (e) {\n    throw new Error(\n      'Could not parse sub-criteria passed to ' +\n      util.format('`.populate(\"%s\")`', keyName) +\n      '\\nSub-criteria:\\n' + util.inspect(criteria, false, null) +\n      '\\nDetails:\\n' + util.inspect(e, false, null)\n    );\n  }\n\n  try {\n\n    // Set the attr value to the generated schema attribute\n    attr = this._context.waterline.schema[this._context.identity].attributes[keyName];\n\n    // Get the current collection's primary key attribute\n    Object.keys(this._context._attributes).forEach(function(key) {\n      if (hasOwnProperty(self._context._attributes[key], 'primaryKey') && self._context._attributes[key].primaryKey) {\n        pk = self._context._attributes[key].columnName || key;\n      }\n    });\n\n    if (!attr) {\n      throw new Error(\n        'In ' + util.format('`.populate(\"%s\")`', keyName) +\n        ', attempting to populate an attribute that doesn\\'t exist'\n      );\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // (there has been significant progress made towards both of these ///\n    // goals-- contact @mikermcneil if you want to help) /////////////////\n    //////////////////////////////////////////////////////////////////////\n    // TODO:\n    // Create synonym for `.populate()` syntax using criteria object\n    // syntax.  i.e. instead of using `joins` key in criteria object\n    // at the app level.\n    //////////////////////////////////////////////////////////////////////\n    // TODO:\n    // Support Mongoose-style `foo.bar.baz` syntax for nested `populate`s.\n    // (or something comparable.)\n    // One solution would be:\n    // .populate({\n    //   friends: {\n    //     where: { name: 'mike' },\n    //     populate: {\n    //       dentist: {\n    //         where: { name: 'rob' }\n    //       }\n    //     }\n    //   }\n    // }, optionalCriteria )\n    ////////////////////////////////////////////////////////////////////\n\n\n    // Grab the key being populated to check if it is a has many to belongs to\n    // If it's a belongs_to the adapter needs to know that it should replace the foreign key\n    // with the associated value.\n    var parentKey = this._context.waterline.collections[this._context.identity].attributes[keyName];\n\n    // Build the initial join object that will link this collection to either another collection\n    // or to a junction table.\n    join = {\n      parent: this._context.identity,\n      parentKey: attr.columnName || pk,\n      child: attr.references,\n      childKey: attr.on,\n      select: Object.keys(this._context.waterline.schema[attr.references].attributes),\n      alias: keyName,\n      removeParentKey: !!parentKey.model,\n      model: !!hasOwnProperty(parentKey, 'model'),\n      collection: !!hasOwnProperty(parentKey, 'collection')\n    };\n\n    // Build select object to use in the integrator\n    var select = [];\n    Object.keys(this._context.waterline.schema[attr.references].attributes).forEach(function(key) {\n      var obj = self._context.waterline.schema[attr.references].attributes[key];\n      if (!hasOwnProperty(obj, 'columnName')) {\n        select.push(key);\n        return;\n      }\n\n      select.push(obj.columnName);\n    });\n\n    join.select = select;\n\n    var schema = this._context.waterline.schema[attr.references];\n    var reference = null;\n\n    // If linking to a junction table the attributes shouldn't be included in the return value\n    if (schema.junctionTable) {\n      join.select = false;\n      reference = _.find(schema.attributes, function(attribute) {\n        return attribute.references && attribute.columnName !== attr.on;\n      });\n    } else if (schema.throughTable && schema.throughTable[self._context.identity + '.' + keyName]) {\n      join.select = false;\n      reference = schema.attributes[schema.throughTable[self._context.identity + '.' + keyName]];\n    }\n\n    joins.push(join);\n\n    // If a junction table is used add an additional join to get the data\n    if (reference && hasOwnProperty(attr, 'on')) {\n      // Build out the second join object that will link a junction table with the\n      // values being populated\n      var selects = _.map(_.keys(this._context.waterline.schema[reference.references].attributes), function(attr) {\n        var expandedAttr = self._context.waterline.schema[reference.references].attributes[attr];\n        return expandedAttr.columnName || attr;\n      });\n\n      join = {\n        parent: attr.references,\n        parentKey: reference.columnName,\n        child: reference.references,\n        childKey: reference.on,\n        select: selects,\n        alias: keyName,\n        junctionTable: true,\n        removeParentKey: !!parentKey.model,\n        model: false,\n        collection: true\n      };\n\n      joins.push(join);\n    }\n\n    // Append the criteria to the correct join if available\n    if (criteria && joins.length > 1) {\n      joins[1].criteria = criteria;\n    } else if (criteria) {\n      joins[0].criteria = criteria;\n    }\n\n    // Set the criteria joins\n    this._criteria.joins = Array.prototype.concat(this._criteria.joins || [], joins);\n\n    return this;\n  } catch (e) {\n    throw new Error(\n      'Encountered unexpected error while building join instructions for ' +\n      util.format('`.populate(\"%s\")`', keyName) +\n      '\\nDetails:\\n' +\n      util.inspect(e, false, null)\n    );\n  }\n};\n\n/**\n * Add a Where clause to the criteria object\n *\n * @param {Object} criteria to append\n * @return this\n */\n\nDeferred.prototype.where = function(criteria) {\n\n  if (!criteria) return this;\n\n  // If the criteria is an array of objects, wrap it in an \"or\"\n  if (Array.isArray(criteria) && _.all(criteria, function(crit) {return _.isObject(crit);})) {\n    criteria = {or: criteria};\n  }\n\n  // Normalize criteria\n  criteria = normalize.criteria(criteria);\n\n  // Wipe out the existing WHERE clause if the specified criteria ends up `false`\n  // (since neither could match anything)\n  if (criteria === false) {\n    this._criteria = false;\n  }\n\n  if (!criteria || !criteria.where) return this;\n\n  if (!this._criteria) this._criteria = {};\n  var where = this._criteria.where || {};\n\n  // Merge with existing WHERE clause\n  Object.keys(criteria.where).forEach(function(key) {\n    where[key] = criteria.where[key];\n  });\n\n  this._criteria.where = where;\n\n  return this;\n};\n\n/**\n * Add a Limit clause to the criteria object\n *\n * @param {Integer} number to limit\n * @return this\n */\n\nDeferred.prototype.limit = function(limit) {\n  this._criteria.limit = limit;\n\n  return this;\n};\n\n/**\n * Add a Skip clause to the criteria object\n *\n * @param {Integer} number to skip\n * @return this\n */\n\nDeferred.prototype.skip = function(skip) {\n  this._criteria.skip = skip;\n\n  return this;\n};\n\n/**\n * Add a Paginate clause to the criteria object\n *\n * This is syntatical sugar that calls skip and\n * limit from a single function.\n *\n * @param {Object} page and limit\n * @return this\n */\nDeferred.prototype.paginate = function(options) {\n  var defaultLimit = 10;\n\n  if (options === undefined) options = { page: 0, limit: defaultLimit };\n\n  var page = options.page || 0;\n  var limit = options.limit || defaultLimit;\n  var skip = 0;\n\n  if (page > 0 && limit === 0) skip = page - 1;\n  if (page > 0 && limit > 0) skip = (page * limit) - limit;\n\n  this\n  .skip(skip)\n  .limit(limit);\n\n  return this;\n};\n\n/**\n * Add a groupBy clause to the criteria object\n *\n * @param {Array|Arguments} Keys to group by\n * @return this\n */\nDeferred.prototype.groupBy = function() {\n  buildAggregate.call(this, 'groupBy', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n\n/**\n * Add a Sort clause to the criteria object\n *\n * @param {String|Object} key and order\n * @return this\n */\n\nDeferred.prototype.sort = function(criteria) {\n\n  if (!criteria) return this;\n\n  // Normalize criteria\n  criteria = normalize.criteria({ sort: criteria });\n\n  var sort = this._criteria.sort || {};\n\n  Object.keys(criteria.sort).forEach(function(key) {\n    sort[key] = criteria.sort[key];\n  });\n\n  this._criteria.sort = sort;\n\n  return this;\n};\n\n/**\n * Add a Sum clause to the criteria object\n *\n * @param {Array|Arguments} Keys to sum over\n * @return this\n */\nDeferred.prototype.sum = function() {\n  buildAggregate.call(this, 'sum', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n/**\n * Add an Average clause to the criteria object\n *\n * @param {Array|Arguments} Keys to average over\n * @return this\n */\nDeferred.prototype.average = function() {\n  buildAggregate.call(this, 'average', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n/**\n * Add a min clause to the criteria object\n *\n * @param {Array|Arguments} Keys to min over\n * @return this\n */\nDeferred.prototype.min = function() {\n  buildAggregate.call(this, 'min', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n/**\n * Add a min clause to the criteria object\n *\n * @param {Array|Arguments} Keys to min over\n * @return this\n */\nDeferred.prototype.max = function() {\n  buildAggregate.call(this, 'max', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n\n/**\n * Add values to be used in update or create query\n *\n * @param {Object, Array} values\n * @return this\n */\n\nDeferred.prototype.set = function(values) {\n  this._values = values;\n\n  return this;\n};\n\n/**\n * Execute a Query using the method passed into the\n * constuctor.\n *\n * @param {Function} callback\n * @return callback with parameters (err, results)\n */\n\nDeferred.prototype.exec = function(cb) {\n\n  if (!cb) {\n    console.log(new Error('Error: No Callback supplied, you must define a callback.').message);\n    return;\n  }\n\n  // Normalize callback/switchback\n  cb = normalize.callback(cb);\n\n  // Set up arguments + callback\n  var args = [this._criteria, cb];\n  if (this._values) args.splice(1, 0, this._values);\n\n  // Pass control to the adapter with the appropriate arguments.\n  this._method.apply(this._context, args);\n};\n\n/**\n * Executes a Query, and returns a promise\n */\n\nDeferred.prototype.toPromise = function() {\n  if (!this._deferred) {\n    this._deferred = Promise.promisify(this.exec).bind(this)();\n  }\n  return this._deferred;\n};\n\n/**\n * Executes a Query, and returns a promise that applies cb/ec to the\n * result/error.\n */\n\nDeferred.prototype.then = function(cb, ec) {\n  return this.toPromise().then(cb, ec);\n};\n\n/**\n * Applies results to function fn.apply, and returns a promise\n */\n\nDeferred.prototype.spread = function(cb) {\n  return this.toPromise().spread(cb);\n};\n\n/**\n * returns a promise and gets resolved with error\n */\n\nDeferred.prototype.catch = function(cb) {\n  return this.toPromise().catch(cb);\n};\n\n\n/**\n * Alias \"catch\" as \"fail\"\n */\nDeferred.prototype.fail = Deferred.prototype.catch;\n\n/**\n * Build An Aggregate Criteria Option\n *\n * @param {String} key\n * @api private\n */\n\nfunction buildAggregate(key, args) {\n\n  // If passed in a list, set that as the min criteria\n  if (args[0] instanceof Array) {\n    args = args[0];\n  }\n\n  this._criteria[key] = args || {};\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/acyclicTraversal.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\n\n\n/**\n * Traverse the shema to build a populate plan object\n * that will populate every relation, sub-relation, and so on\n * reachable from the initial model and relation at least once\n * (perhaps most notable is that this provides access to most\n * related data without getting caught in loops.)\n *\n * @param  {[type]} schema          [description]\n * @param  {[type]} initialModel    [description]\n * @param  {[type]} initialRelation [description]\n * @return {[type]}                 [description]\n */\nmodule.exports = function acyclicTraversal(schema, initialModel, initialRelation) {\n\n  // Track the edges which have already been traversed\n  var alreadyTraversed = [\n    // {\n    //   relation: initialRelation,\n    //   model: initialModel\n    // }\n  ];\n\n  return traverseSchemaGraph(initialModel, initialRelation);\n\n  /**\n   * Recursive function\n   * @param  {[type]} modelIdentity  [description]\n   * @param  {[type]} nameOfRelation [description]\n   * @return {[type]}                [description]\n   */\n  function traverseSchemaGraph(modelIdentity, nameOfRelation) {\n\n    var currentModel = schema[modelIdentity];\n    var currentAttributes = currentModel.attributes;\n\n    var isRedundant;\n\n    // If this relation has already been traversed, return.\n    // (i.e. `schema.attributes.modelIdentity.nameOfRelation`)\n    isRedundant = _.findWhere(alreadyTraversed, {\n      alias: nameOfRelation,\n      model: modelIdentity\n    });\n\n    if (isRedundant) return;\n\n    // Push this relation onto the `alreadyTraversed` stack.\n    alreadyTraversed.push({\n      alias: nameOfRelation,\n      model: modelIdentity\n    });\n\n\n    var relation = currentAttributes[nameOfRelation];\n    if (!relation) throw new Error('Unknown relation in schema: ' + modelIdentity + '.' + nameOfRelation);\n    var identityOfRelatedModel = relation.model || relation.collection;\n\n    // Get the related model\n    var relatedModel = schema[identityOfRelatedModel];\n\n    // If this relation is a collection with a `via` back-reference,\n    // push it on to the `alreadyTraversed` stack.\n    // (because the information therein is probably redundant)\n    // TODO: evaluate this-- it may or may not be a good idea\n    // (but I think it's a nice touch)\n    if (relation.via) {\n      alreadyTraversed.push({\n        alias: relation.via,\n        model: identityOfRelatedModel\n      });\n    }\n\n    // Lookup ALL the relations OF THE RELATED model.\n    var relations =\n      _(relatedModel.attributes).reduce(function buildSubsetOfAssociations(relations, attrDef, attrName) {\n        if (_.isObject(attrDef) && (attrDef.model || attrDef.collection)) {\n          relations.push(_.merge({\n            alias: attrName,\n            identity: attrDef.model || attrDef.collection,\n            cardinality: attrDef.model ? 'model' : 'collection'\n          }, attrDef));\n          return relations;\n        }\n        return relations;\n      }, []);\n\n    // Return a piece of the result plan by calling `traverseSchemaGraph`\n    // on each of the RELATED model's relations.\n    return _.reduce(relations, function(resultPlanPart, relation) {\n\n      // Recursive step\n      resultPlanPart[relation.alias] = traverseSchemaGraph(identityOfRelatedModel, relation.alias);\n\n      // Trim undefined result plan parts\n      if (resultPlanPart[relation.alias] === undefined) {\n        delete resultPlanPart[relation.alias];\n      }\n\n      return resultPlanPart;\n    }, {});\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/callbacksRunner.js":"/**\n * Module Dependencies\n */\n\nvar async = require('async');\n\n/**\n * Run Lifecycle Callbacks\n */\n\nvar runner = module.exports = {};\n\n\n/**\n * Run Validation Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Boolean} presentOnly\n * @param {Function} cb\n * @api public\n */\n\nrunner.validate = function(context, values, presentOnly, cb) {\n  context.validate(values, presentOnly, cb);\n};\n\n\n/**\n * Run Before Create Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.beforeCreate = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.beforeCreate, fn, cb);\n};\n\n\n/**\n * Run After Create Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.afterCreate = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.afterCreate, fn, cb);\n};\n\n\n/**\n * Run Before Update Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.beforeUpdate = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.beforeUpdate, fn, cb);\n};\n\n\n/**\n * Run After Update Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.afterUpdate = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.afterUpdate, fn, cb);\n};\n\n\n/**\n * Run Before Destroy Callbacks\n *\n * @param {Object} context\n * @param {Object} criteria\n * @param {Function} cb\n * @api public\n */\n\nrunner.beforeDestroy = function(context, criteria, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, criteria, next);\n  };\n\n  async.eachSeries(context._callbacks.beforeDestroy, fn, cb);\n};\n\n\n/**\n * Run After Destroy Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.afterDestroy = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.afterDestroy, fn, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/dql/update.js":"/**\n * Module Dependencies\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar Deferred = require('../deferred');\nvar callbacks = require('../../utils/callbacksRunner');\nvar nestedOperations = require('../../utils/nestedOperations');\nvar hop = utils.object.hasOwnProperty;\n\n\n/**\n * Update all records matching criteria\n *\n * @param {Object} criteria\n * @param {Object} values\n * @param {Function} cb\n * @return Deferred object if no callback\n */\n\nmodule.exports = function(criteria, values, cb) {\n\n  var self = this;\n\n  if (typeof criteria === 'function') {\n    cb = criteria;\n    criteria = null;\n  }\n\n  // Return Deferred or pass to adapter\n  if (typeof cb !== 'function') {\n    return new Deferred(this, this.update, criteria, values);\n  }\n\n  // If there was something defined in the criteria that would return no results, don't even\n  // run the query and just return an empty result set.\n  if (criteria === false) {\n    return cb(null, []);\n  }\n\n  // Ensure proper function signature\n  var usage = utils.capitalize(this.identity) + '.update(criteria, values, callback)';\n  if (!values) return usageError('No updated values specified!', usage, cb);\n\n  // Format Criteria and Values\n  var valuesObject = prepareArguments.call(this, criteria, values);\n\n  // Create any of the belongsTo associations and set the foreign key values\n  createBelongsTo.call(this, valuesObject, function(err) {\n    if (err) return cb(err);\n\n    beforeCallbacks.call(self, valuesObject.values, function(err) {\n      if (err) return cb(err);\n      updateRecords.call(self, valuesObject, cb);\n    });\n  });\n};\n\n\n/**\n * Prepare Arguments\n *\n * @param {Object} criteria\n * @param {Object} values\n * @return {Object}\n */\n\nfunction prepareArguments(criteria, values) {\n\n  // Check if options is an integer or string and normalize criteria\n  // to object, using the specified primary key field.\n  criteria = normalize.expandPK(this, criteria);\n\n  // Normalize criteria\n  criteria = normalize.criteria(criteria);\n\n  // Pull out any associations in the values\n  var _values = _.cloneDeep(values);\n  var associations = nestedOperations.valuesParser.call(this, this.identity, this.waterline.schema, values);\n\n  // Replace associated models with their foreign key values if available.\n  // Unless the association has a custom primary key (we want to create the object)\n  values = nestedOperations.reduceAssociations.call(this, this.identity, this.waterline.schema, values, 'update');\n\n  // Cast values to proper types (handle numbers as strings)\n  values = this._cast.run(values);\n\n  return {\n    criteria: criteria,\n    values: values,\n    originalValues: _values,\n    associations: associations\n  };\n}\n\n/**\n * Create BelongsTo Records\n *\n */\n\nfunction createBelongsTo(valuesObject, cb) {\n  var self = this;\n\n  async.each(valuesObject.associations.models.slice(0), function(item, next) {\n\n    // Check if value is an object. If not don't try and create it.\n    if (!_.isPlainObject(valuesObject.values[item])) return next();\n\n    // Check for any transformations\n    var attrName = hop(self._transformer._transformations, item) ? self._transformer._transformations[item] : item;\n\n    var attribute = self._schema.schema[attrName];\n    var modelName;\n\n    if (hop(attribute, 'collection')) modelName = attribute.collection;\n    if (hop(attribute, 'model')) modelName = attribute.model;\n    if (!modelName) return next();\n\n    var model = self.waterline.collections[modelName];\n    var pkValue = valuesObject.originalValues[item][model.primaryKey];\n\n    var criteria = {};\n\n    var pkField = hop(model._transformer._transformations, model.primaryKey) ? model._transformer._transformations[model.primaryKey] : model.primaryKey;\n\n    criteria[pkField] = pkValue;\n\n    // If a pkValue if found, do a findOrCreate and look for a record matching the pk.\n    var query;\n    if (pkValue) {\n      query = model.findOrCreate(criteria, valuesObject.values[item]);\n    } else {\n      query = model.create(valuesObject.values[item]);\n    }\n\n    query.exec(function(err, val) {\n      if (err) return next(err);\n\n      // attach the new model's pk value to the original value's key\n      var pk = val[model.primaryKey];\n\n      valuesObject.values[item] = pk;\n\n      // now we have pk value attached, remove it from models\n      _.remove(valuesObject.associations.models, function(_item) { return _item == item; });\n      next();\n    });\n\n  }, cb);\n}\n\n/**\n * Run Before* Lifecycle Callbacks\n *\n * @param {Object} values\n * @param {Function} cb\n */\n\nfunction beforeCallbacks(values, cb) {\n  var self = this;\n\n  async.series([\n\n    // Run Validation with Validation LifeCycle Callbacks\n    function(cb) {\n      callbacks.validate(self, values, true, cb);\n    },\n\n    // Before Update Lifecycle Callback\n    function(cb) {\n      callbacks.beforeUpdate(self, values, cb);\n    }\n\n  ], cb);\n}\n\n/**\n * Update Records\n *\n * @param {Object} valuesObjecy\n * @param {Function} cb\n */\n\nfunction updateRecords(valuesObject, cb) {\n  var self = this;\n\n  // Automatically change updatedAt (if enabled)\n  if (this.autoUpdatedAt) {\n    // take into account that the autoUpdateAt attribute may be a string with a different column name\n    valuesObject.values[self.autoUpdatedAt] = new Date();\n  }\n\n  // Transform Values\n  valuesObject.values = this._transformer.serialize(valuesObject.values);\n\n  // Clean attributes\n  valuesObject.values = this._schema.cleanValues(valuesObject.values);\n\n  // Transform Search Criteria\n  valuesObject.criteria = self._transformer.serialize(valuesObject.criteria);\n\n\n  // Pass to adapter\n  self.adapter.update(valuesObject.criteria, valuesObject.values, function(err, values) {\n    if (err) {\n      if (typeof err === 'object') { err.model = self._model.globalId; }\n      return cb(err);\n    }\n\n    // If values is not an array, return an array\n    if (!Array.isArray(values)) values = [values];\n\n    // Unserialize each value\n    var transformedValues = values.map(function(value) {\n      return self._transformer.unserialize(value);\n    });\n\n    // Update any nested associations and run afterUpdate lifecycle callbacks for each parent\n    updatedNestedAssociations.call(self, valuesObject, transformedValues, function(err) {\n      if (err) return cb(err);\n\n      async.each(transformedValues, function(record, callback) {\n        callbacks.afterUpdate(self, record, callback);\n      }, function(err) {\n        if (err) return cb(err);\n\n        var models = transformedValues.map(function(value) {\n          return new self._model(value);\n        });\n\n        cb(null, models);\n      });\n    });\n\n  });\n}\n\n/**\n * Update Nested Associations\n *\n * @param {Object} valuesObject\n * @param {Object} values\n * @param {Function} cb\n */\n\nfunction updatedNestedAssociations(valuesObject, values, cb) {\n\n  var self = this;\n  var associations = valuesObject.associations || {};\n\n  // Only attempt nested updates if values are an object or an array\n  associations.models = _.filter(associations.models, function(model) {\n    var vals = valuesObject.originalValues[model];\n    return _.isPlainObject(vals) || Array.isArray(vals);\n  });\n\n  // If no associations were used, return callback\n  if (associations.collections.length === 0 && associations.models.length === 0) {\n    return cb();\n  }\n\n  // Create an array of model instances for each parent\n  var parents = values.map(function(val) {\n    return new self._model(val);\n  });\n\n  // Update any nested associations found in the values object\n  var args = [parents, valuesObject.originalValues, valuesObject.associations, cb];\n  nestedOperations.update.apply(self, args);\n\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/usageError.js":"/**\n * Create a nicely formatted usage error\n */\n\nmodule.exports = function(err, usage, cb) {\n  var message = err + '\\n==============================================\\nProper usage :: \\n' + usage + '\\n==============================================\\n';\n  if (cb) return cb(message);\n  throw new Error(message);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/dql/destroy.js":"/**\n * Module Dependencies\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar Deferred = require('../deferred');\nvar getRelations = require('../../utils/getRelations');\nvar callbacks = require('../../utils/callbacksRunner');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Destroy a Record\n *\n * @param {Object} criteria to destroy\n * @param {Function} callback\n * @return Deferred object if no callback\n */\n\nmodule.exports = function(criteria, cb) {\n  var self = this;\n  var pk;\n\n  if (typeof criteria === 'function') {\n    cb = criteria;\n    criteria = {};\n  }\n\n  // Check if criteria is an integer or string and normalize criteria\n  // to object, using the specified primary key field.\n  criteria = normalize.expandPK(self, criteria);\n\n  // Normalize criteria\n  criteria = normalize.criteria(criteria);\n\n  // Return Deferred or pass to adapter\n  if (typeof cb !== 'function') {\n    return new Deferred(this, this.destroy, criteria);\n  }\n\n  var usage = utils.capitalize(this.identity) + '.destroy([options], callback)';\n  if (typeof cb !== 'function') return usageError('Invalid callback specified!', usage, cb);\n\n  // If there was something defined in the criteria that would return no results, don't even\n  // run the query and just return an empty result set.\n  if (criteria === false) {\n    return cb(null, []);\n  }\n\n  callbacks.beforeDestroy(self, criteria, function(err) {\n    if (err) return cb(err);\n\n    // Transform Search Criteria\n    criteria = self._transformer.serialize(criteria);\n\n    // Pass to adapter\n    self.adapter.destroy(criteria, function(err, result) {\n      if (err) return cb(err);\n\n      // Look for any m:m associations and destroy the value in the join table\n      var relations = getRelations({\n        schema: self.waterline.schema,\n        parentCollection: self.identity\n      });\n\n      if (relations.length === 0) return after();\n\n      // Find the collection's primary key\n      for (var key in self.attributes) {\n        if (!self.attributes[key].hasOwnProperty('primaryKey')) continue;\n\n        // Check if custom primaryKey value is falsy\n        if (!self.attributes[key].primaryKey) continue;\n\n        if (self.attributes[key].columnName) {\n          pk = self.attributes[key].columnName;\n        } else {\n          pk = key;\n        }\n\n        break;\n      }\n\n      function destroyJoinTableRecords(item, next) {\n        var collection = self.waterline.collections[item];\n        var refKey = [];\n\n        Object.keys(collection._attributes).forEach(function(key) {\n          var attr = collection._attributes[key];\n          if (attr.references !== self.identity) return;\n          refKey.push(key);\n        });\n\n        // If no refKey return, this could leave orphaned join table values but it's better\n        // than crashing.\n        if (!refKey.length) return next();\n\n        // Make sure we don't return any undefined pks\n        var mappedValues = result.reduce(function(memo, vals) {\n          if (vals[pk] !== undefined) {\n            memo.push(vals[pk]);\n          }\n          return memo;\n        }, []);\n\n        var criteria = {};\n\n        if (mappedValues.length > 0) {\n          // Handle reflexive associations by building up an OR clause.\n          if (refKey.length > 1) {\n            var orCriteria = [];\n            _.each(refKey, function(columnName) {\n              var where = {};\n              where[columnName] = mappedValues;\n              orCriteria.push(where);\n            });\n\n            criteria = {\n              or: orCriteria\n            };\n          } else {\n            criteria[_.first(refKey)] = mappedValues;\n          }\n\n          collection.destroy(criteria).exec(next);\n        } else {\n          return next();\n        }\n\n      }\n\n      async.each(relations, destroyJoinTableRecords, function(err) {\n        if (err) return cb(err);\n        after();\n      });\n\n      function after() {\n\n        // If no result was returned, default to empty array\n        if (!result) {\n          result = [];\n        }\n\n        // If values is not an array, return an array\n        if (!Array.isArray(result)) {\n          result = [result];\n        }\n\n        // Unserialize each value\n        var transformedValues = result.map(function(value) {\n          return self._transformer.unserialize(value);\n        });\n\n        callbacks.afterDestroy(self, transformedValues, function(err) {\n          if (err) return cb(err);\n          cb(null, transformedValues);\n        });\n      }\n\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/dql/count.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar Deferred = require('../deferred');\n\n/**\n * Count of Records\n *\n * @param {Object} criteria\n * @param {Object} options\n * @param {Function} callback\n * @return Deferred object if no callback\n */\n\nmodule.exports = function(criteria, options, cb) {\n  var usage = utils.capitalize(this.identity) + '.count([criteria],[options],callback)';\n\n  if (typeof criteria === 'function') {\n    cb = criteria;\n    criteria = null;\n    options = null;\n  }\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  // Return Deferred or pass to adapter\n  if (typeof cb !== 'function') {\n    return new Deferred(this, this.count, criteria);\n  }\n\n  // Normalize criteria and fold in options\n  criteria = normalize.criteria(criteria);\n\n  // If there was something defined in the criteria that would return no results, don't even\n  // run the query and just return 0\n  if (criteria === false) {\n    return cb(null, 0);\n  }\n\n  if (_.isObject(options) && _.isObject(criteria)) {\n    criteria = _.extend({}, criteria, options);\n  }\n\n  if (_.isFunction(criteria) || _.isFunction(options)) {\n    return usageError('Invalid options specified!', usage, cb);\n  }\n\n  // Transform Search Criteria\n  criteria = this._transformer.serialize(criteria);\n\n  // Remove any joins from the count criteria. They won't have any effect on the\n  // number of results found.\n  if (_.isArray(criteria.joins)) {\n    delete criteria.joins;\n  }\n\n  if (criteria.where && _.isArray(criteria.where.joins)) {\n    delete criteria.where.joins;\n  }\n\n  this.adapter.count(criteria, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/dql/join.js":"/**\n * Join\n *\n * Join with another collection\n * (use optimized join in adapter if one was provided)\n */\n\nmodule.exports = function(collection, fk, pk, cb) {\n  this._adapter.join(collection, fk, pk, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/aggregate.js":"/**\n * Aggregate Queries\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar usageError = require('../utils/usageError');\nvar utils = require('../utils/helpers');\nvar normalize = require('../utils/normalize');\nvar callbacks = require('../utils/callbacksRunner');\nvar Deferred = require('./deferred');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\nmodule.exports = {\n\n  /**\n   * Create an Array of records\n   *\n   * @param {Array} array of values to create\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  createEach: function(valuesList, cb) {\n    var self = this;\n\n    // Handle Deferred where it passes criteria first\n    if (arguments.length === 3) {\n      var args = Array.prototype.slice.call(arguments);\n      cb = args.pop();\n      valuesList = args.pop();\n    }\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.createEach, {}, valuesList);\n    }\n\n    // Validate Params\n    var usage = utils.capitalize(this.identity) + '.createEach(valuesList, callback)';\n\n    if (!valuesList) return usageError('No valuesList specified!', usage, cb);\n    if (!Array.isArray(valuesList)) return usageError('Invalid valuesList specified (should be an array!)', usage, cb);\n    if (typeof cb !== 'function') return usageError('Invalid callback specified!', usage, cb);\n\n    var errStr = _validateValues(_.cloneDeep(valuesList));\n    if (errStr) return usageError(errStr, usage, cb);\n\n    // Handle undefined values\n    var filteredValues = _.filter(valuesList, function(value) {\n      return value !== undefined;\n    });\n\n    // Create will take care of cloning values so original isn't mutated\n    async.map(filteredValues, self.create.bind(self), cb);\n  },\n\n  /**\n   * Iterate through a list of objects, trying to find each one\n   * For any that don't exist, create them\n   *\n   * @param {Object} criteria\n   * @param {Array} valuesList\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  findOrCreateEach: function(criteria, valuesList, cb) {\n    var self = this;\n\n    if (typeof valuesList === 'function') {\n      cb = valuesList;\n      valuesList = null;\n    }\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.findOrCreateEach, criteria, valuesList);\n    }\n\n    // Validate Params\n    var usage = utils.capitalize(this.identity) + '.findOrCreateEach(criteria, valuesList, callback)';\n\n    if (typeof cb !== 'function') return usageError('Invalid callback specified!', usage, cb);\n    if (!criteria) return usageError('No criteria specified!', usage, cb);\n    if (!Array.isArray(criteria)) return usageError('No criteria specified!', usage, cb);\n    if (!valuesList) return usageError('No valuesList specified!', usage, cb);\n    if (!Array.isArray(valuesList)) return usageError('Invalid valuesList specified (should be an array!)', usage, cb);\n\n    var errStr = _validateValues(valuesList);\n    if (errStr) return usageError(errStr, usage, cb);\n\n    // Validate each record in the array and if all are valid\n    // pass the array to the adapter's findOrCreateEach method\n    var validateItem = function(item, next) {\n      _validate.call(self, item, next);\n    };\n\n\n    async.each(valuesList, validateItem, function(err) {\n      if (err) return cb(err);\n\n      // Transform Values\n      var transformedValues = [];\n\n      valuesList.forEach(function(value) {\n\n        // Transform values\n        value = self._transformer.serialize(value);\n\n        // Clean attributes\n        value = self._schema.cleanValues(value);\n        transformedValues.push(value);\n      });\n\n      // Set values array to the transformed array\n      valuesList = transformedValues;\n\n      // Transform Search Criteria\n      var transformedCriteria = [];\n\n      criteria.forEach(function(value) {\n        value = self._transformer.serialize(value);\n        transformedCriteria.push(value);\n      });\n\n      // Set criteria array to the transformed array\n      criteria = transformedCriteria;\n\n      // Pass criteria and attributes to adapter definition\n      self.adapter.findOrCreateEach(criteria, valuesList, function(err, values) {\n        if (err) return cb(err);\n\n        // Unserialize Values\n        var unserializedValues = [];\n\n        values.forEach(function(value) {\n          value = self._transformer.unserialize(value);\n          unserializedValues.push(value);\n        });\n\n        // Set values array to the transformed array\n        values = unserializedValues;\n\n        // Run AfterCreate Callbacks\n        async.each(values, function(item, next) {\n          callbacks.afterCreate(self, item, next);\n        }, function(err) {\n          if (err) return cb(err);\n\n          var models = [];\n\n          // Make each result an instance of model\n          values.forEach(function(value) {\n            models.push(new self._model(value));\n          });\n\n          cb(null, models);\n        });\n      });\n    });\n  }\n};\n\n\n/**\n * Validate valuesList\n *\n * @param {Array} valuesList\n * @return {String}\n * @api private\n */\n\nfunction _validateValues(valuesList) {\n  var err;\n\n  for (var i = 0; i < valuesList.length; i++) {\n    if (valuesList[i] !== Object(valuesList[i])) {\n      err = 'Invalid valuesList specified (should be an array of valid values objects!)';\n    }\n  }\n\n  return err;\n}\n\n\n/**\n * Validate values and add in default values\n *\n * @param {Object} record\n * @param {Function} cb\n * @api private\n */\n\nfunction _validate(record, cb) {\n  var self = this;\n\n  // Set Default Values if available\n  for (var key in self.attributes) {\n    if (!record[key] && record[key] !== false && hasOwnProperty(self.attributes[key], 'defaultsTo')) {\n      var defaultsTo = self.attributes[key].defaultsTo;\n      record[key] = typeof defaultsTo === 'function' ? defaultsTo.call(record) : _.clone(defaultsTo);\n    }\n  }\n\n  // Cast values to proper types (handle numbers as strings)\n  record = self._cast.run(record);\n\n  async.series([\n\n    // Run Validation with Validation LifeCycle Callbacks\n    function(next) {\n      callbacks.validate(self, record, true, next);\n    },\n\n    // Before Create Lifecycle Callback\n    function(next) {\n      callbacks.beforeCreate(self, record, next);\n    }\n\n  ], function(err) {\n    if (err) return cb(err);\n\n    // Automatically add updatedAt and createdAt (if enabled)\n    if (self.autoCreatedAt) {\n      record[self.autoCreatedAt] = new Date();\n    }\n\n    if (self.autoUpdatedAt) {\n      record[self.autoUpdatedAt] = new Date();\n    }\n\n    cb();\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/composite.js":"/**\n * Composite Queries\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar usageError = require('../utils/usageError');\nvar utils = require('../utils/helpers');\nvar normalize = require('../utils/normalize');\nvar Deferred = require('./deferred');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\nmodule.exports = {\n\n  /**\n   * Find or Create a New Record\n   *\n   * @param {Object} search criteria\n   * @param {Object} values to create if no record found\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  findOrCreate: function(criteria, values, cb) {\n    var self = this;\n\n    if (typeof values === 'function') {\n      cb = values;\n      values = null;\n    }\n\n    // If no criteria is specified, bail out with a vengeance.\n    var usage = utils.capitalize(this.identity) + '.findOrCreate([criteria], values, callback)';\n    if (typeof cb == 'function' && (!criteria || criteria.length === 0)) {\n      return usageError('No criteria option specified!', usage, cb);\n    }\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n    // If no values were specified, use criteria\n    if (!values) values = criteria.where ? criteria.where : criteria;\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.findOrCreate, criteria, values);\n    }\n\n    // This is actually an implicit call to findOrCreateEach\n    if (Array.isArray(criteria) && Array.isArray(values)) {\n      return this.findOrCreateEach(criteria, values, cb);\n    }\n\n    if (typeof cb !== 'function') return usageError('Invalid callback specified!', usage, cb);\n\n    // Try a find first.\n    this.find(criteria).exec(function(err, results) {\n      if (err) return cb(err);\n\n      if (results && results.length !== 0) {\n\n        // Unserialize values\n        results = self._transformer.unserialize(results[0]);\n\n        // Return an instance of Model\n        var model = new self._model(results);\n        return cb(null, model);\n      }\n\n      // Create a new record if nothing is found.\n      self.create(values).exec(function(err, result) {\n        if (err) return cb(err);\n        return cb(null, result);\n      });\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/finders/basic.js":"/**\n * Basic Finder Queries\n */\n\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar sorter = require('../../utils/sorter');\nvar Deferred = require('../deferred');\nvar Joins = require('./joins');\nvar Operations = require('./operations');\nvar Integrator = require('../integrator');\nvar waterlineCriteria = require('waterline-criteria');\nvar _ = require('lodash');\nvar async = require('async');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\nmodule.exports = {\n\n  /**\n   * Find a single record that meets criteria\n   *\n   * @param {Object} criteria to search\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  findOne: function(criteria, cb) {\n    var self = this;\n\n    if (typeof criteria === 'function') {\n      cb = criteria;\n      criteria = null;\n    }\n\n    // If the criteria is an array of objects, wrap it in an \"or\"\n    if (Array.isArray(criteria) && _.all(criteria, function(crit) {return _.isObject(crit);})) {\n      criteria = {or: criteria};\n    }\n\n    // Check if criteria is an integer or string and normalize criteria\n    // to object, using the specified primary key field.\n    criteria = normalize.expandPK(self, criteria);\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.findOne, criteria);\n    }\n\n    // Transform Search Criteria\n    criteria = self._transformer.serialize(criteria);\n\n    // serialize populated object\n    if (criteria.joins) {\n      criteria.joins.forEach(function(join) {\n        if (join.criteria && join.criteria.where) {\n          var joinCollection = self.waterline.collections[join.child];\n          join.criteria.where = joinCollection._transformer.serialize(join.criteria.where);\n        }\n      });\n    }\n\n    // If there was something defined in the criteria that would return no results, don't even\n    // run the query and just return an empty result set.\n    if (criteria === false || criteria.where === null) {\n      // Build Default Error Message\n      var err = '.findOne() requires a criteria. If you want the first record try .find().limit(1)';\n      return cb(new Error(err));\n    }\n\n    // Build up an operations set\n    var operations = new Operations(self, criteria, 'findOne');\n\n    // Run the operations\n    operations.run(function(err, values) {\n      if (err) return cb(err);\n      if (!values.cache) return cb();\n\n      // If no joins are used grab the only item from the cache and pass to the returnResults\n      // function.\n      if (!criteria.joins) {\n        values = values.cache[self.identity];\n        return returnResults(values);\n      }\n\n      // If the values are already combined, return the results\n      if (values.combined) {\n        return returnResults(values.cache[self.identity]);\n      }\n\n      // Find the primaryKey of the current model so it can be passed down to the integrator.\n      // Use 'id' as a good general default;\n      var primaryKey = 'id';\n\n      Object.keys(self._schema.schema).forEach(function(key) {\n        if (self._schema.schema[key].hasOwnProperty('primaryKey') && self._schema.schema[key].primaryKey) {\n          primaryKey = key;\n        }\n      });\n\n\n      // Perform in-memory joins\n      Integrator(values.cache, criteria.joins, primaryKey, function(err, results) {\n        if (err) return cb(err);\n        if (!results) return cb();\n\n        // We need to run one last check on the results using the criteria. This allows a self\n        // association where we end up with two records in the cache both having each other as\n        // embedded objects and we only want one result. However we need to filter any join criteria\n        // out of the top level where query so that searchs by primary key still work.\n        var tmpCriteria = _.cloneDeep(criteria.where);\n        if (!tmpCriteria) tmpCriteria = {};\n\n        criteria.joins.forEach(function(join) {\n          if (!hasOwnProperty(join, 'alias')) return;\n\n          // Check for `OR` criteria\n          if (hasOwnProperty(tmpCriteria, 'or')) {\n            tmpCriteria.or.forEach(function(search) {\n              if (!hasOwnProperty(search, join.alias)) return;\n              delete search[join.alias];\n            });\n          }\n\n          if (!hasOwnProperty(tmpCriteria, join.alias)) return;\n          delete tmpCriteria[join.alias];\n        });\n\n        // Pass results into Waterline-Criteria\n        var _criteria = { where: tmpCriteria };\n        results = waterlineCriteria('parent', { parent: results }, _criteria).results;\n\n        results.forEach(function(res) {\n\n          // Go Ahead and perform any sorts on the associated data\n          criteria.joins.forEach(function(join) {\n            if (!join.criteria) return;\n            var c = normalize.criteria(join.criteria);\n            if (!c.sort) return;\n\n            var alias = join.alias;\n            res[alias] = sorter(res[alias], c.sort);\n          });\n        });\n\n        returnResults(results);\n      });\n\n      function returnResults(results) {\n\n        if (!results) return cb();\n\n        // Normalize results to an array\n        if (!Array.isArray(results) && results) results = [results];\n\n        // Unserialize each of the results before attempting any join logic on them\n        var unserializedModels = [];\n        results.forEach(function(result) {\n          unserializedModels.push(self._transformer.unserialize(result));\n        });\n\n        var models = [];\n        var joins = criteria.joins ? criteria.joins : [];\n        var data = new Joins(joins, unserializedModels, self.identity, self._schema.schema, self.waterline.collections);\n\n        // If `data.models` is invalid (not an array) return early to avoid getting into trouble.\n        if (!data || !data.models || !data.models.forEach) {\n          return cb(new Error('Values returned from operations set are not an array...'));\n        }\n\n        // Create a model for the top level values\n        data.models.forEach(function(model) {\n          models.push(new self._model(model, data.options));\n        });\n\n        cb(null, models[0]);\n      }\n    });\n  },\n\n  /**\n   * Find All Records that meet criteria\n   *\n   * @param {Object} search criteria\n   * @param {Object} options\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  find: function(criteria, options, cb) {\n    var self = this;\n\n    var usage = utils.capitalize(this.identity) + '.find([criteria],[options]).exec(callback|switchback)';\n\n    if (typeof criteria === 'function') {\n      cb = criteria;\n      criteria = null;\n      options = null;\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    // If the criteria is an array of objects, wrap it in an \"or\"\n    if (Array.isArray(criteria) && _.all(criteria, function(crit) {return _.isObject(crit);})) {\n      criteria = {or: criteria};\n    }\n\n    // Check if criteria is an integer or string and normalize criteria\n    // to object, using the specified primary key field.\n    criteria = normalize.expandPK(self, criteria);\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n\n    // Validate Arguments\n    if (typeof criteria === 'function' || typeof options === 'function') {\n      return usageError('Invalid options specified!', usage, cb);\n    }\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.find, criteria, options);\n    }\n\n    // If there was something defined in the criteria that would return no results, don't even\n    // run the query and just return an empty result set.\n    if (criteria === false) {\n      return cb(null, []);\n    }\n\n    // Fold in options\n    if (options === Object(options) && criteria === Object(criteria)) {\n      criteria = _.extend({}, criteria, options);\n    }\n\n    // Transform Search Criteria\n    if (!self._transformer) {\n      throw new Error('Waterline can not access transformer-- maybe the context of the method is being overridden?');\n    }\n\n    criteria = self._transformer.serialize(criteria);\n\n    // serialize populated object\n    if (criteria.joins) {\n      criteria.joins.forEach(function(join) {\n        if (join.criteria && join.criteria.where) {\n          var joinCollection = self.waterline.collections[join.child];\n          join.criteria.where = joinCollection._transformer.serialize(join.criteria.where);\n        }\n      });\n    }\n\n    // Build up an operations set\n    var operations = new Operations(self, criteria, 'find');\n\n    // Run the operations\n    operations.run(function(err, values) {\n      if (err) return cb(err);\n      if (!values.cache) return cb();\n\n      // If no joins are used grab current collection's item from the cache and pass to the returnResults\n      // function.\n      if (!criteria.joins) {\n        values = values.cache[self.identity];\n        return returnResults(values);\n      }\n\n      // If the values are already combined, return the results\n      if (values.combined) {\n        return returnResults(values.cache[self.identity]);\n      }\n\n      // Find the primaryKey of the current model so it can be passed down to the integrator.\n      // Use 'id' as a good general default;\n      var primaryKey = 'id';\n\n      Object.keys(self._schema.schema).forEach(function(key) {\n        if (self._schema.schema[key].hasOwnProperty('primaryKey') && self._schema.schema[key].primaryKey) {\n          primaryKey = key;\n        }\n      });\n\n      // Perform in-memory joins\n      Integrator(values.cache, criteria.joins, primaryKey, function(err, results) {\n        if (err) return cb(err);\n        if (!results) return cb();\n\n        // We need to run one last check on the results using the criteria. This allows a self\n        // association where we end up with two records in the cache both having each other as\n        // embedded objects and we only want one result. However we need to filter any join criteria\n        // out of the top level where query so that searchs by primary key still work.\n        var tmpCriteria = _.cloneDeep(criteria.where);\n        if (!tmpCriteria) tmpCriteria = {};\n\n        criteria.joins.forEach(function(join) {\n          if (!hasOwnProperty(join, 'alias')) return;\n\n          // Check for `OR` criteria\n          if (hasOwnProperty(tmpCriteria, 'or')) {\n            tmpCriteria.or.forEach(function(search) {\n              if (!hasOwnProperty(search, join.alias)) return;\n              delete search[join.alias];\n            });\n          }\n\n          if (!hasOwnProperty(tmpCriteria, join.alias)) return;\n          delete tmpCriteria[join.alias];\n        });\n\n        // Pass results into Waterline-Criteria\n        var _criteria = { where: tmpCriteria };\n        results = waterlineCriteria('parent', { parent: results }, _criteria).results;\n\n        // Serialize values coming from an in-memory join before modelizing\n        var _results = [];\n        results.forEach(function(res) {\n\n          // Go Ahead and perform any sorts on the associated data\n          criteria.joins.forEach(function(join) {\n            if (!join.criteria) return;\n            var c = normalize.criteria(join.criteria);\n            var alias = join.alias;\n            if (c.sort) {\n              res[alias] = sorter(res[alias], c.sort);\n            }\n\n            // If a junction table was used we need to do limit and skip in-memory\n            // This is where it gets nasty, paginated stuff here is a pain and needs work\n            // Hopefully we can get a chance to re-do it in WL2 and not have this. Basically\n            // if you need paginated populates try and have all the tables in the query on the\n            // same connection so it can be done in a nice single query.\n            if (!join.junctionTable) return;\n\n            if (c.skip) {\n              res[alias].splice(0, c.skip);\n            }\n\n            if (c.limit) {\n              res[alias] = _.take(res[alias], c.limit);\n            }\n          });\n        });\n\n        returnResults(results);\n      });\n\n      function returnResults(results) {\n\n        if (!results) return cb(null, []);\n\n        // Normalize results to an array\n        if (!Array.isArray(results) && results) results = [results];\n\n        // Unserialize each of the results before attempting any join logic on them\n        var unserializedModels = [];\n\n        if (results) {\n          results.forEach(function(result) {\n            unserializedModels.push(self._transformer.unserialize(result));\n          });\n        }\n\n        var models = [];\n        var joins = criteria.joins ? criteria.joins : [];\n        var data = new Joins(joins, unserializedModels, self.identity, self._schema.schema, self.waterline.collections);\n\n        // NOTE:\n        // If a \"belongsTo\" (i.e. HAS_FK) association is null, should it be transformed into\n        // an empty array here?  That is not what is happening currently, and it can cause\n        // unexpected problems when implementing the native join method as an adapter implementor.\n        // ~Mike June 22, 2014\n\n        // If `data.models` is invalid (not an array) return early to avoid getting into trouble.\n        if (!data || !data.models || !data.models.forEach) {\n          return cb(new Error('Values returned from operations set are not an array...'));\n        }\n\n        // Create a model for the top level values\n        data.models.forEach(function(model) {\n          models.push(new self._model(model, data.options));\n        });\n\n\n        cb(null, models);\n      }\n\n    });\n  },\n\n  where: function() {\n    this.find.apply(this, Array.prototype.slice.call(arguments));\n  },\n\n  select: function() {\n    this.find.apply(this, Array.prototype.slice.call(arguments));\n  },\n\n\n  /**\n   * findAll\n   * [[ Deprecated! ]]\n   *\n   * @param  {Object}   criteria\n   * @param  {Object}   options\n   * @param  {Function} cb\n   */\n  findAll: function(criteria, options, cb) {\n    if (typeof criteria === 'function') {\n      cb = criteria;\n      criteria = null;\n      options = null;\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.findAll, criteria);\n    }\n\n    cb(new Error('In Waterline >= 0.9, findAll() has been deprecated in favor of find().' +\n                '\\nPlease visit the migration guide at http://sailsjs.org for help upgrading.'));\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/sorter.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\n\n/**\n * Sort `data` (tuples) using `sortCriteria` (comparator)\n *\n * Based on method described here:\n * http://stackoverflow.com/a/4760279/909625\n *\n * @param  { Object[] } data         [tuples]\n * @param  { Object }   sortCriteria [mongo-style comparator object]\n * @return { Object[] }\n */\n\nmodule.exports = function sortData(data, sortCriteria) {\n\n  function dynamicSort(property) {\n    var sortOrder = 1;\n    if (property[0] === '-') {\n      sortOrder = -1;\n      property = property.substr(1);\n    }\n\n    return function(a, b) {\n      var result = (a[property] < b[property]) ? -1 : (a[property] > b[property]) ? 1 : 0;\n      return result * sortOrder;\n    };\n  }\n\n  function dynamicSortMultiple() {\n    var props = arguments;\n    return function(obj1, obj2) {\n      var i = 0;\n      var result = 0;\n      var numberOfProperties = props.length;\n\n      while (result === 0 && i < numberOfProperties) {\n        result = dynamicSort(props[i])(obj1, obj2);\n        i++;\n      }\n      return result;\n    };\n  }\n\n  // build sort criteria in the format ['firstName', '-lastName']\n  var sortArray = [];\n  _.each(_.keys(sortCriteria), function(key) {\n    if (sortCriteria[key] === -1) sortArray.push('-' + key);\n    else sortArray.push(key);\n  });\n\n  data.sort(dynamicSortMultiple.apply(null, sortArray));\n  return data;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/finders/joins.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('../../utils/helpers');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Logic For Handling Joins inside a Query Results Object\n */\n\nvar Joins = module.exports = function(joins, values, identity, schema, collections) {\n\n  this.identity = identity;\n\n  // Hold Joins specified in the criteria\n  this.joins = joins || [];\n\n  // Hold the result values\n  this.values = values || [];\n\n  // Hold the overall schema\n  this.schema = schema || {};\n\n  // Hold all the Waterline collections so we can make models\n  this.collections = collections || {};\n\n  // Build up modelOptions\n  this.modelOptions();\n\n  // Modelize values\n  this.models = this.makeModels();\n\n  return this;\n};\n\n/**\n * Build up Join Options that will be passed down to a Model instance.\n *\n * @api private\n */\n\nJoins.prototype.modelOptions = function modelOptions() {\n\n  var self = this;\n  var joins;\n\n  // Build Model Options, determines what associations to render in toObject\n  this.options = {\n    showJoins: !!this.joins\n  };\n\n  // If no joins were used, just return\n  if (!this.joins) return;\n\n  // Map out join names to pass down to the model instance\n  joins = this.joins.filter(function(join) {\n\n    // If the value is not being selected, don't add it to the array\n    if (!join.select) return false;\n\n    return join;\n  });\n\n  // Map out join key names and attach to the options object.\n  // For normal assoiciations, use the child table name that is being joined. For many-to-many\n  // associations the child table name won't work so grab the alias used and use that for the\n  // join name. It will be the one that is transformed.\n  this.options.joins = joins.map(function(join) {\n    var child = [];\n    // If a junctionTable was not used, return the child table\n    if (!join.junctionTable) return join.child;\n\n    // Find the original alias for the join\n    self.joins.forEach(function(j) {\n      if (j.child !== join.parent) return;\n      child.push(j.alias);\n    });\n\n    // If a child was found, return it otherwise just return the original child join\n    if (child) return child;\n    return join.child;\n  });\n\n  // Flatten joins\n  this.options.joins = _.uniq(_.flatten(this.options.joins));\n};\n\n/**\n * Transform Values into instantiated Models.\n *\n * @return {Array}\n * @api private\n */\n\nJoins.prototype.makeModels = function makeModels() {\n\n  var self = this;\n  var models = [];\n  var model;\n\n  // If values are invalid (not an array), return them early.\n  if (!this.values || !this.values.forEach) return this.values;\n\n  // Make each result an instance of model\n  this.values.forEach(function(value) {\n    model = self.modelize(value);\n    models.push(model);\n  });\n\n  return models;\n};\n\n/**\n * Handle a single Result and inspect it's values for anything\n * that needs to become a Model instance.\n *\n * @param {Object} value\n * @return {Object}\n * @api private\n */\n\nJoins.prototype.modelize = function modelize(value) {\n  var self = this;\n\n  // Look at each key in the object and see if it was used in a join\n  Object.keys(value).forEach(function(key) {\n\n    var joinKey = false;\n    var attr,\n        usedInJoin;\n\n    // If showJoins wasn't set or no joins were found there is nothing to modelize\n    if (!self.options.showJoins || !self.options.joins) return;\n\n    // Look at the schema for an attribute and check if it's a foreign key\n    // or a virtual hasMany collection attribute\n\n    // Check if there is a transformation on this attribute\n    var transformer = self.collections[self.identity]._transformer._transformations;\n    if (hop(transformer, key)) {\n      attr = self.schema[transformer[key]];\n    } else {\n      attr = self.schema[key];\n    }\n\n    // If an attribute was found but it's not a model, this means it's a normal\n    // key/value attribute and not an association so there is no need to modelize it.\n    if (attr && !attr.hasOwnProperty('model')) return;\n\n    // If the attribute has a `model` property, the joinKey is the collection of the model\n    if (attr && attr.hasOwnProperty('model')) joinKey = attr.model;\n\n    // If the attribute is a foreign key but it was not populated, just leave the foreign key\n    // as it is and don't try and modelize it.\n    if (joinKey && self.options.joins.indexOf(joinKey) < 0) return;\n\n    // Check if the key was used in a join\n    usedInJoin = self.checkForJoin(key);\n\n    // If the attribute wasn't used in the join, don't turn it into a model instance.\n    // NOTE: Not sure if this is correct or not?\n    if (!usedInJoin.used) return;\n\n    // If the attribute is an array of child values, for each one make a model out of it.\n    if (Array.isArray(value[key])) {\n\n      var records = [];\n\n      value[key].forEach(function(val) {\n        var collection,\n            model;\n\n        // If there is a joinKey this means it's a belongsTo association so the collection\n        // containing the proper model will be the name of the joinKey model.\n        if (joinKey) {\n          collection = self.collections[joinKey];\n          val = collection._transformer.unserialize(val);\n          model = new collection._model(val, { showJoins: false });\n          return records.push(model);\n        }\n\n        // Otherwise look at the join used and determine which key should be used to get\n        // the proper model from the collections.\n        collection = self.collections[usedInJoin.join.child];\n        val = collection._transformer.unserialize(val);\n        model = new collection._model(val, { showJoins: false });\n        return records.push(model);\n      });\n\n      // Set the value to the array of model values\n      value[key] = records;\n      return;\n    }\n\n    // If the value isn't an array it's a populated foreign key so modelize it and attach\n    // it directly on the attribute\n    collection = self.collections[joinKey];\n    value[key] = collection._transformer.unserialize(value[key]);\n    value[key] = new collection._model(value[key], { showJoins: false });\n  });\n\n  return value;\n};\n\n/**\n * Test if an attribute was used in a join.\n * Requires generating a key to test against an attribute because the model process\n * will be run before any transformations have taken place.\n *\n * @param {String} key\n * @return {Object}\n * @api private\n */\n\nJoins.prototype.checkForJoin = function checkForJoin(key) {\n\n  var generatedKey;\n  var usedInJoin = false;\n  var relatedJoin;\n\n  // Loop through each join and see if the given key matches a join used\n  this.joins.forEach(function(join) {\n    if (join.alias !== key) return;\n    usedInJoin = true;\n    relatedJoin = join;\n  });\n\n  return { used: usedInJoin, join: relatedJoin };\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/finders/operations.js":"\n/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Builds up a set of operations to perform based on search criteria.\n *\n * This allows the ability to do cross-adapter joins as well as fake joins\n * on adapters that haven't implemented the join interface yet.\n */\n\nvar Operations = module.exports = function(context, criteria, parent) {\n\n  // Build up a cache\n  this.cache = {};\n\n  // Set context\n  this.context = context;\n\n  // Set criteria\n  this.criteria = criteria;\n\n  // Set parent\n  this.parent = parent;\n\n  // Hold a default value for pre-combined results (native joins)\n  this.preCombined = false;\n\n  // Seed the Cache\n  this._seedCache();\n\n  // Build Up Operations\n  this.operations = this._buildOperations();\n\n  return this;\n};\n\n\n/*\n ***********************************************************************************\n * PUBLIC METHODS\n ***********************************************************************************/\n\n\n/**\n * Run Operations\n *\n * Execute a set of generated operations returning an array of results that can\n * joined in-memory to build out a valid results set.\n *\n * @param {Function} cb\n * @api public\n */\n\nOperations.prototype.run = function run(cb) {\n\n  var self = this;\n\n  // Grab the parent operation, it will always be the very first operation\n  var parentOp = this.operations.shift();\n\n  // Run The Parent Operation\n  this._runOperation(parentOp.collection, parentOp.method, parentOp.criteria, function(err, results) {\n\n    if (err) return cb(err);\n\n    // Set the cache values\n    self.cache[parentOp.collection] = results;\n\n    // If results are empty, or we're already combined, nothing else to so do return\n    if (!results || self.preCombined) return cb(null, { combined: true, cache: self.cache });\n\n    // Run child operations and populate the cache\n    self._execChildOpts(results, function(err) {\n      if (err) return cb(err);\n      cb(null, { combined: self.preCombined, cache: self.cache });\n    });\n\n  });\n\n};\n\n\n/*\n ***********************************************************************************\n * PRIVATE METHODS\n ***********************************************************************************/\n\n\n/**\n * Seed Cache with empty values.\n *\n * For each Waterline Collection set an empty array of values into the cache.\n *\n * @api private\n */\n\nOperations.prototype._seedCache = function _seedCache() {\n  var self = this;\n\n  // Fill the cache with empty values for each collection\n  Object.keys(this.context.waterline.schema).forEach(function(key) {\n    self.cache[key] = [];\n  });\n};\n\n/**\n * Build up the operations needed to perform the query based on criteria.\n *\n * @return {Array}\n * @api private\n */\n\nOperations.prototype._buildOperations = function _buildOperations() {\n\n  var self = this;\n  var operations = [];\n\n  // Check if joins were used, if not only a single operation is needed on a single connection\n  if (!hasOwnProperty(this.criteria, 'joins')) {\n\n    // Grab the collection\n    var collection = this.context.waterline.collections[this.context.identity];\n\n    // Find the name of the connection to run the query on using the dictionary\n    var connectionName = collection.adapterDictionary[this.parent];\n    if (!connectionName) connectionName = collection.adapterDictionary.find;\n\n    operations.push({\n      connection: connectionName,\n      collection: this.context.identity,\n      method: this.parent,\n      criteria: this.criteria\n    });\n\n    return operations;\n  }\n\n  // Joins were used in this operation. Lets grab the connections needed for these queries. It may\n  // only be a single connection in a simple case or it could be multiple connections in some cases.\n  var connections = this._getConnections();\n\n  // Now that all the connections are created, build up operations needed to accomplish the end\n  // goal of getting all the results no matter which connection they are on. To do this,\n  // figure out if a connection supports joins and if so pass down a criteria object containing\n  // join instructions. If joins are not supported by a connection, build a series of operations\n  // to achieve the end result.\n  operations = this._stageOperations(connections);\n\n  return operations;\n};\n\n/**\n * Stage Operation Sets\n *\n * @param {Object} connections\n * @api private\n */\n\nOperations.prototype._stageOperations = function _stageOperations(connections) {\n\n  var self = this;\n  var operations = [];\n\n  // Build the parent operation and set it as the first operation in the array\n  operations = operations.concat(this._createParentOperation(connections));\n\n  // Parent Connection Name\n  var parentConnection = this.context.adapterDictionary[this.parent];\n\n  // Parent Operation\n  var parentOperation = operations[0];\n\n  // For each additional connection build operations\n  Object.keys(connections).forEach(function(connection) {\n\n    // Ignore the connection used for the parent operation if a join can be used on it.\n    // This means all of the operations for the query can take place on a single connection\n    // using a single query.\n    if (connection === parentConnection && parentOperation.method === 'join') return;\n\n    // Operations are needed that will be run after the parent operation has been completed.\n    // If there are more than a single join, set the parent join and build up children operations.\n    // This occurs in a many-to-many relationship when a join table is needed.\n\n    // Criteria is omitted until after the parent operation has been run so that an IN query can\n    // be formed on child operations.\n\n    var localOpts = [];\n\n    connections[connection].joins.forEach(function(join, idx) {\n\n      var optCollection = self.context.waterline.collections[join.child];\n      var optConnectionName = optCollection.adapterDictionary['find'];\n\n      var operation = {\n        connection: optConnectionName,\n        collection: join.child,\n        method: 'find',\n        join: join\n      };\n\n      // If this is the first join, it can't have any parents\n      if (idx === 0) {\n        localOpts.push(operation);\n        return;\n      }\n\n      // Look into the previous operations and see if this is a child of any of them\n      var child = false;\n      localOpts.forEach(function(localOpt) {\n        if (localOpt.join.child != join.parent) return;\n        localOpt.child = operation;\n        child = true;\n      });\n\n      if (child) return;\n      localOpts.push(operation);\n    });\n\n    operations = operations.concat(localOpts);\n  });\n\n  return operations;\n};\n\n/**\n * Create The Parent Operation\n *\n * @param {Object} connections\n * @return {Object}\n * @api private\n */\n\nOperations.prototype._createParentOperation = function _createParentOperation(connections) {\n\n  var nativeJoin = this.context.adapter.hasJoin();\n  var operation,\n      connectionName,\n      connection;\n\n  // If the parent supports native joins, check if all the joins on the connection can be\n  // run on the same connection and if so just send the entire criteria down to the connection.\n  if (nativeJoin) {\n\n    connectionName = this.context.adapterDictionary.join;\n    connection = connections[connectionName];\n\n    // Hold any joins that can't be run natively on this connection\n    var unsupportedJoins = false;\n\n    // Pull out any unsupported joins\n    connection.joins.forEach(function(join) {\n      if (connection.collections.indexOf(join.child) > -1) return;\n      unsupportedJoins = true;\n    });\n\n    // If all the joins were supported then go ahead and build an operation.\n    if (!unsupportedJoins) {\n      operation = [{\n        connection: connectionName,\n        collection: this.context.identity,\n        method: 'join',\n        criteria: this.criteria\n      }];\n\n      // Set the preCombined flag\n      this.preCombined = true;\n\n      return operation;\n    }\n  }\n\n  // Remove the joins from the criteria object, this will be an in-memory join\n  var tmpCriteria = _.cloneDeep(this.criteria);\n  delete tmpCriteria.joins;\n\n  connectionName = this.context.adapterDictionary[this.parent];\n\n  // If findOne was used, use the same connection `find` is on.\n  if (this.parent === 'findOne' && !connectionName) {\n    connectionName = this.context.adapterDictionary.find;\n  }\n\n  connection = connections[connectionName];\n\n  operation = [{\n    connection: connectionName,\n    collection: this.context.identity,\n    method: this.parent,\n    criteria: tmpCriteria\n  }];\n\n  return operation;\n};\n\n\n/**\n * Get the connections used in this query and the join logic for each piece.\n *\n * @return {Object}\n * @api private\n */\n\nOperations.prototype._getConnections = function _getConnections() {\n\n  var self = this;\n  var connections = {};\n\n  // Default structure for connection objects\n  var defaultConnection = {\n    collections: [],\n    children: [],\n    joins: []\n  };\n\n  // For each join build a connection item to build up an entire collection/connection registry\n  // for this query. Using this, queries should be able to be seperated into discrete queries\n  // which can be run on connections in parallel.\n  this.criteria.joins.forEach(function(join) {\n    var connection;\n    var parentConnection;\n    var childConnection;\n\n    function getConnection(collName) {\n      var collection = self.context.waterline.collections[collName];\n      var connectionName = collection.adapterDictionary['find'];\n      connections[connectionName] = connections[connectionName] || _.cloneDeep(defaultConnection);\n      return connections[connectionName];\n    }\n\n    // If this join is a junctionTable, find the parent operation and add it to that connections\n    // children instead of creating a new operation on another connection. This allows cross-connection\n    // many-to-many joins to be used where the join relies on the results of the parent operation\n    // being run first.\n\n    if (join.junctionTable) {\n\n      // Find the previous join\n      var parentJoin = _.find(self.criteria.joins, function(otherJoin) {\n        return otherJoin.child == join.parent;\n      });\n\n      // Grab the parent join connection\n      var parentJoinConnection = getConnection(parentJoin.parent);\n\n      // Find the connection the parent and child collections belongs to\n      parentConnection = getConnection(join.parent);\n      childConnection = getConnection(join.child);\n\n      // Update the registry\n      parentConnection.collections.push(join.parent);\n      childConnection.collections.push(join.child);\n      parentConnection.children.push(join.parent);\n\n      // Ensure the arrays are made up only of unique values\n      parentConnection.collections = _.uniq(parentConnection.collections);\n      childConnection.collections = _.uniq(childConnection.collections);\n      parentConnection.children = _.uniq(parentConnection.children);\n\n      // Add the join to the correct joins array. We want it to be on the same\n      // connection as the operation before so the timing is correct.\n      parentJoinConnection.joins = parentJoinConnection.joins.concat(join);\n\n    // Build up the connection registry like normal\n    } else {\n      parentConnection = getConnection(join.parent);\n      childConnection = getConnection(join.child);\n\n      parentConnection.collections.push(join.parent);\n      childConnection.collections.push(join.child);\n      parentConnection.joins = parentConnection.joins.concat(join);\n    }\n\n  });\n  return connections;\n};\n\n\n/**\n * Run An Operation\n *\n * Performs an operation and runs a supplied callback.\n *\n * @param {Object} collectionName\n * @param {String} method\n * @param {Object} criteria\n * @param {Function} cb\n *\n * @api private\n */\n\nOperations.prototype._runOperation = function _runOperation(collectionName, method, criteria, cb) {\n\n  // Ensure the collection exist\n  if (!hasOwnProperty(this.context.waterline.collections, collectionName)) {\n    return cb(new Error('Invalid Collection specfied in operation.'));\n  }\n\n  // Find the connection object to run the operation\n  var collection = this.context.waterline.collections[collectionName];\n\n  // Run the operation\n  collection.adapter[method](criteria, cb);\n\n};\n\n/**\n * Execute Child Operations\n *\n * If joins are used and an adapter doesn't support them, there will be child operations that will\n * need to be run. Parse each child operation and run them along with any tree joins and return\n * an array of children results that can be combined with the parent results.\n *\n * @param {Array} parentResults\n * @param {Function} cb\n */\n\nOperations.prototype._execChildOpts = function _execChildOpts(parentResults, cb) {\n\n  var self = this;\n\n  // Build up a set of child operations that will need to be run\n  // based on the results returned from the parent operation.\n  this._buildChildOpts(parentResults, function(err, opts) {\n    if (err) return cb(err);\n\n    // Run the generated operations in parallel\n    async.each(opts, function(item, next) {\n      self._collectChildResults(item, next);\n    }, cb);\n  });\n\n};\n\n/**\n * Build Child Operations\n *\n * Using the results of a parent operation, build up a set of operations that contain criteria\n * based on what is returned from a parent operation. These can be arrays containing more than\n * one operation for each child, which will happen when \"join tables\" would be used.\n *\n * Each set should be able to be run in parallel.\n *\n * @param {Array} parentResults\n * @param {Function} cb\n * @return {Array}\n * @api private\n */\n\nOperations.prototype._buildChildOpts = function _buildChildOpts(parentResults, cb) {\n\n  var self = this;\n  var opts = [];\n\n  // Build up operations that can be run in parallel using the results of the parent operation\n  async.each(this.operations, function(item, next) {\n\n    var localOpts = [];\n    var parents = [];\n    var idx = 0;\n\n    // Go through all the parent records and build up an array of keys to look in. This\n    // will be used in an IN query to grab all the records needed for the \"join\".\n    parentResults.forEach(function(result) {\n\n      if (!hasOwnProperty(result, item.join.parentKey)) return;\n      if (result[item.join.parentKey] === null || typeof result[item.join.parentKey] === undefined) return;\n      parents.push(result[item.join.parentKey]);\n\n    });\n\n    // If no parents match the join criteria, don't build up an operation\n    if (parents.length === 0) return next();\n\n    // Build up criteria that will be used inside an IN query\n    var criteria = {};\n    criteria[item.join.childKey] = parents;\n\n    var _tmpCriteria = {};\n\n    // Check if the join contains any criteria\n    if (item.join.criteria) {\n      var userCriteria = _.cloneDeep(item.join.criteria);\n      _tmpCriteria = _.cloneDeep(userCriteria);\n      _tmpCriteria = normalize.criteria(_tmpCriteria);\n\n      // Ensure `where` criteria is properly formatted\n      if (hasOwnProperty(userCriteria, 'where')) {\n        if (userCriteria.where === undefined) {\n          delete userCriteria.where;\n        } else {\n\n          // If an array of primary keys was passed in, normalize the criteria\n          if (Array.isArray(userCriteria.where)) {\n            var pk = self.context.waterline.collections[item.join.child].primaryKey;\n            var obj = {};\n            obj[pk] = _.clone(userCriteria.where);\n            userCriteria.where = obj;\n          }\n\n          userCriteria = userCriteria.where;\n        }\n      }\n\n\n      criteria = _.merge(userCriteria, criteria);\n    }\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n\n    // If criteria contains a skip or limit option, an operation will be needed for each parent.\n    if (hasOwnProperty(_tmpCriteria, 'skip') || hasOwnProperty(_tmpCriteria, 'limit')) {\n      parents.forEach(function(parent) {\n\n        var tmpCriteria = _.cloneDeep(criteria);\n        tmpCriteria.where[item.join.childKey] = parent;\n\n        // Mixin the user defined skip and limit\n        if (hasOwnProperty(_tmpCriteria, 'skip')) tmpCriteria.skip = _tmpCriteria.skip;\n        if (hasOwnProperty(_tmpCriteria, 'limit')) tmpCriteria.limit = _tmpCriteria.limit;\n\n        // Build a simple operation to run with criteria from the parent results.\n        // Give it an ID so that children operations can reference it if needed.\n        localOpts.push({\n          id: idx,\n          collection: item.collection,\n          method: item.method,\n          criteria: tmpCriteria,\n          join: item.join\n        });\n\n      });\n    } else {\n\n      // Build a simple operation to run with criteria from the parent results.\n      // Give it an ID so that children operations can reference it if needed.\n      localOpts.push({\n        id: idx,\n        collection: item.collection,\n        method: item.method,\n        criteria: criteria,\n        join: item.join\n      });\n\n    }\n\n    // If there are child records, add the opt but don't add the criteria\n    if (!item.child) {\n      opts.push(localOpts);\n      return next();\n    }\n\n    localOpts.push({\n      collection: item.child.collection,\n      method: item.child.method,\n      parent: idx,\n      join: item.child.join\n    });\n\n    // Add the local opt to the opts array\n    opts.push(localOpts);\n\n    next();\n  }, function(err) {\n    cb(err, opts);\n  });\n};\n\n/**\n * Collect Child Operation Results\n *\n * Run a set of child operations and return the results in a namespaced array\n * that can later be used to do an in-memory join.\n *\n * @param {Array} opts\n * @param {Function} cb\n * @api private\n */\n\nOperations.prototype._collectChildResults = function _collectChildResults(opts, cb) {\n\n  var self = this;\n  var intermediateResults = [];\n  var i = 0;\n\n  if (!opts || opts.length === 0) return cb(null, {});\n\n  // Run the operations and any child operations in series so that each can access the\n  // results of the previous operation.\n  async.eachSeries(opts, function(opt, next) {\n    self._runChildOperations(intermediateResults, opt, function(err, values) {\n      if (err) return next(err);\n\n      // If there are multiple operations and we are on the first one lets put the results\n      // into an intermediate results array\n      if (opts.length > 1 && i === 0) {\n        intermediateResults = intermediateResults.concat(values);\n      }\n\n      // Add values to the cache key\n      self.cache[opt.collection] = self.cache[opt.collection] || [];\n      self.cache[opt.collection] = self.cache[opt.collection].concat(values);\n\n      // Ensure the values are unique\n      var pk = self._findCollectionPK(opt.collection);\n      self.cache[opt.collection] = _.uniq(self.cache[opt.collection], pk);\n\n      i++;\n      next();\n    });\n  }, cb);\n\n};\n\n/**\n * Run A Child Operation\n *\n * Executes a child operation and appends the results as a namespaced object to the\n * main operation results object.\n *\n * @param {Object} optResults\n * @param {Object} opt\n * @param {Function} callback\n * @api private\n */\n\nOperations.prototype._runChildOperations = function _runChildOperations(intermediateResults, opt, cb) {\n  var self = this;\n\n  // Check if value has a parent, if so a join table was used and we need to build up dictionary\n  // values that can be used to join the parent and the children together.\n\n  // If the operation doesn't have a parent operation run it\n  if (!hasOwnProperty(opt, 'parent')) {\n    return self._runOperation(opt.collection, opt.method, opt.criteria, function(err, values) {\n      if (err) return cb(err);\n      cb(null, values);\n    });\n  }\n\n  // If the operation has a parent, look into the optResults and build up a criteria\n  // object using the results of a previous operation\n  var parents = [];\n\n  // Normalize to array\n  var res = _.cloneDeep(intermediateResults);\n\n  // Build criteria that can be used with an `in` query\n  res.forEach(function(result) {\n    parents.push(result[opt.join.parentKey]);\n  });\n\n  var criteria = {};\n  criteria[opt.join.childKey] = parents;\n\n  // Check if the join contains any criteria\n  if (opt.join.criteria) {\n    var userCriteria = _.cloneDeep(opt.join.criteria);\n\n    // Ensure `where` criteria is properly formatted\n    if (hasOwnProperty(userCriteria, 'where')) {\n      if (userCriteria.where === undefined) {\n        delete userCriteria.where;\n      } else {\n        userCriteria = userCriteria.where;\n      }\n    }\n\n    delete userCriteria.sort;\n    criteria = _.extend(criteria, userCriteria);\n  }\n\n  criteria = normalize.criteria({ where: criteria });\n\n  // Empty the cache for the join table so we can only add values used\n  var cacheCopy = _.cloneDeep(self.cache[opt.join.parent]);\n  self.cache[opt.join.parent] = [];\n\n  self._runOperation(opt.collection, opt.method, criteria, function(err, values) {\n    if (err) return cb(err);\n\n    // Build up the new join table result\n    values.forEach(function(val) {\n      cacheCopy.forEach(function(copy) {\n        if (copy[opt.join.parentKey] === val[opt.join.childKey]) self.cache[opt.join.parent].push(copy);\n      });\n    });\n\n    // Ensure the values are unique\n    var pk = self._findCollectionPK(opt.join.parent);\n    self.cache[opt.join.parent] = _.uniq(self.cache[opt.join.parent], pk);\n\n    cb(null, values);\n  });\n};\n\n/**\n * Find A Collection's Primary Key\n *\n * @param {String} collectionName\n * @api private\n * @return {String}\n */\n\nOperations.prototype._findCollectionPK = function _findCollectionPK(collectionName) {\n  var pk;\n\n  for (var attribute in this.context.waterline.collections[collectionName]._attributes) {\n    var attr = this.context.waterline.collections[collectionName]._attributes[attribute];\n    if (hasOwnProperty(attr, 'primaryKey') && attr.primaryKey) {\n      pk = attr.columnName || attribute;\n      break;\n    }\n  }\n\n  return pk || null;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/integrator/index.js":"/**\n * Module dependencies\n */\nvar anchor = require('anchor');\nvar _ = require('lodash');\nvar leftOuterJoin = require('./leftOuterJoin');\nvar innerJoin = require('./innerJoin');\nvar populate = require('./populate');\n\n\n/**\n * Query Integrator\n *\n * Combines the results from multiple child queries into\n * the final return format using an in-memory join.\n * Final step in fulfilling a `.find()` with one or more\n * `populate(alias[n])` modifiers.\n *\n *    > Why is this asynchronous?\n *    >\n *    > While this function isn't doing anything strictly\n *    > asynchronous, it still expects a callback to enable\n *    > future use of `process[setImmediate|nextTick]()` as\n *    > an optimization.\n *\n * @param  {Object}   cache\n * @param  {Array}    joinInstructions      - see JOIN_INSTRUCTIONS.md\n * @callback  {Function} cb(err, results)\n *           @param {Error}\n *           @param {Array}  [results, complete w/ populations]\n *\n * @throws {Error} on invalid input\n * @asynchronous\n */\nmodule.exports = function integrate(cache, joinInstructions, primaryKey, cb) {\n\n  // Ensure valid usage\n  var invalid = false;\n  invalid = invalid || anchor(cache).to({ type: 'object' });\n  invalid = invalid || anchor(joinInstructions).to({ type: 'array' });\n  invalid = invalid || anchor(joinInstructions[0]).to({ type: 'object' });\n  invalid = invalid || anchor(joinInstructions[0].parent).to({ type: 'string' });\n  invalid = invalid || anchor(cache[joinInstructions[0].parent]).to({ type: 'object' });\n  invalid = invalid || typeof primaryKey !== 'string';\n  invalid = invalid || typeof cb !== 'function';\n  if (invalid) return cb(invalid);\n\n\n  // Constant: String prepended to child attribute keys for use in namespacing.\n  var CHILD_ATTR_PREFIX = '.';\n  var GRANDCHILD_ATTR_PREFIX = '..';\n\n\n  // We'll reuse the cached data from the `parent` table modifying it in-place\n  // and returning it as our result set. (`results`)\n  var results = cache[ joinInstructions[0].parent ];\n\n  // Group the joinInstructions array by alias, then interate over each one\n  // s.t. `instructions` in our lambda function contains a list of join instructions\n  // for the particular `populate` on the specified key (i.e. alias).\n  //\n  // Below, `results` are mutated inline.\n  _.each(_.groupBy(joinInstructions, 'alias'),\n    function eachAssociation(instructions, alias) {\n\n      var parentPK, fkToParent, fkToChild, childPK;\n\n      // N..N Association\n      if (instructions.length === 2) {\n\n        // Name keys explicitly\n        // (makes it easier to see what's going on)\n        parentPK = instructions[0].parentKey;\n        fkToParent = instructions[0].childKey;\n        fkToChild = instructions[1].parentKey;\n        childPK = instructions[1].childKey;\n\n        // console.log('\\n\\n------------:: n..m leftOuterJoin ::--------\\n',\n        //   leftOuterJoin({\n        //     left: cache[instructions[0].parent],\n        //     right: cache[instructions[0].child],\n        //     leftKey: parentPK,\n        //     rightKey: fkToParent\n        //   })\n        // );\n        // console.log('------------:: / ::--------\\n');\n\n        // console.log('\\n\\n------------:: n..m childRows ::--------\\n',innerJoin({\n        //   left: leftOuterJoin({\n        //     left: cache[instructions[0].parent],\n        //     right: cache[instructions[0].child],\n        //     leftKey: parentPK,\n        //     rightKey: fkToParent\n        //   }),\n        //   right: cache[instructions[1].child],\n        //   leftKey: CHILD_ATTR_PREFIX+fkToChild,\n        //   rightKey: childPK,\n        //   childNamespace: GRANDCHILD_ATTR_PREFIX\n        // }));\n        // console.log('------------:: / ::--------\\n');\n\n        // Calculate and sanitize join data,\n        // then shove it into the parent results under `alias`\n        populate({\n          parentRows: results,\n          alias: alias,\n\n          childRows: innerJoin({\n            left: leftOuterJoin({\n              left: cache[instructions[0].parent],\n              right: cache[instructions[0].child],\n              leftKey: parentPK,\n              rightKey: fkToParent\n            }),\n            right: cache[instructions[1].child],\n            leftKey: CHILD_ATTR_PREFIX + fkToChild,\n            rightKey: childPK,\n            childNamespace: GRANDCHILD_ATTR_PREFIX\n          }),\n\n          parentPK: parentPK,   // e.g. `id` (of message)\n          fkToChild: CHILD_ATTR_PREFIX + fkToChild, // e.g. `user_id` (of join table)\n          childPK: GRANDCHILD_ATTR_PREFIX + childPK,      // e.g. `id` (of user)\n\n          childNamespace: GRANDCHILD_ATTR_PREFIX\n        });\n\n      // 1 ..N Association\n      } else if (instructions.length === 1) {\n\n        // Name keys explicitly\n        // (makes it easier to see what's going on)\n        parentPK = primaryKey;\n        fkToParent = parentPK;\n        fkToChild = instructions[0].parentKey;\n        childPK = instructions[0].childKey;\n\n        // Determine if this is a \"hasOne\" or a \"belongsToMany\"\n        // if the parent's primary key is the same as the fkToChild, it must be belongsToMany\n        if (parentPK === fkToChild) {\n          // In belongsToMany case, fkToChild needs prefix because it's actually the\n          // console.log('belongsToMany');\n          fkToChild = CHILD_ATTR_PREFIX + fkToChild;\n        // \"hasOne\" case\n        } else {\n          // console.log('hasOne');\n        }\n\n        // var childRows = innerJoin({\n        //   left: cache[instructions[0].parent],\n        //   right: cache[instructions[0].child],\n        //   leftKey: instructions[0].parentKey,\n        //   rightKey: instructions[0].childKey\n        // });\n\n        // console.log('1..N JOIN--------------\\n',instructions,'\\n^^^^^^^^^^^^^^^^^^^^^^');\n        // console.log('1..N KEYS--------------\\n',{\n        //   parentPK: parentPK,\n        //   fkToParent: fkToParent,\n        //   fkToChild: fkToChild,\n        //   childPK: childPK,\n        // },'\\n^^^^^^^^^^^^^^^^^^^^^^');\n        // console.log('1..N CHILD ROWS--------\\n',childRows);\n\n        // Calculate and sanitize join data,\n        // then shove it into the parent results under `alias`\n        populate({\n          parentRows: results,\n          alias: alias,\n\n          childRows: innerJoin({\n            left: cache[instructions[0].parent],\n            right: cache[instructions[0].child],\n            leftKey: instructions[0].parentKey,\n            rightKey: instructions[0].childKey\n          }),\n\n          parentPK: fkToParent,  // e.g. `id` (of message)\n          fkToChild: fkToChild,  // e.g. `from`\n          childPK: childPK,      // e.g. `id` (of user)\n\n          childNamespace: CHILD_ATTR_PREFIX\n        });\n\n        // If the alias isn't the same as the parent_key AND removeParentKey is set to true\n        // in the instructions this means that we are turning a FK into an embedded record and a\n        // columnName was used. We need to move the values attached to the alias property to\n        // the parent key value. If we don't then when we run the transformer everything would get crazy.\n        if (alias !== instructions[0].parentKey && instructions[0].removeParentKey === true) {\n\n          results = _.map(results, function(result) {\n            result[instructions[0].parentKey] = result[alias];\n            delete result[alias];\n            return result;\n          });\n\n        }\n      }\n\n    }\n  );\n\n\n  // And call the callback\n  // (the final joined data is in the cache -- also referenced by `results`)\n  return cb(null, results);\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/integrator/leftOuterJoin.js":"/**\n * Module dependencies\n */\nvar join = require('./_join');\n\n\n/**\n * Left outer join\n *\n * Return a result set with data from child and parent\n * merged on childKey===parentKey, where t.e. at least one\n * entry for each row of parent (unmatched columns in child are null).\n *\n * @option {Array} parent       [rows from the \"lefthand table\"]\n * @option {Array} child        [rows from the \"righthand table\"]\n * @option {String} parentKey   [primary key of the \"lefthand table\"]\n * @option {String} childKey    [foreign key from the \"righthand table\" to the \"lefthand table\"]\n * @return {Array}              [a new array of joined row data]\n *\n * @throws {Error} on invalid input\n * @synchronous\n */\nmodule.exports = function leftOuterJoin(options) {\n  options.outer = 'left';\n  return join(options);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/integrator/_join.js":"/**\n * Module dependencies\n */\nvar anchor = require('anchor');\nvar _ = require('lodash');\nvar partialJoin = require('./_partialJoin');\n\n\n/**\n * _join\n *\n * @api private\n *\n * Helper method- can perform and inner -OR- outer join.\n *\n * @option {String|Boolean} outer    [whether to do an outer join, and if so the direction (\"left\"|\"right\")]\n * @option {Array} parent            [rows from the \"lefthand table\"]\n * @option {Array} child             [rows from the \"righthand table\"]\n * @option {String} parentKey        [primary key of the \"lefthand table\"]\n * @option {String} childKey         [foreign key from the \"righthand table\" to the \"lefthand table\"]\n * @option {String} childNamespace   [string prepended to child attribute keys (default='.')]\n *\n * @return {Array} new joined row data\n *\n * @throws {Error} on invalid input\n *\n * @synchronous\n */\nmodule.exports = function _join(options) {\n\n\n  // Usage\n  var invalid = false;\n  invalid = invalid || anchor(options).to({\n    type: 'object'\n  });\n\n  // Tolerate `right` and `left` usage\n  _.defaults(options, {\n    parent: options.left,\n    child: options.right,\n    parentKey: options.leftKey,\n    childKey: options.rightKey,\n    childNamespace: options.childNamespace || '.'\n  });\n\n  invalid = invalid || anchor(options.parent).to({\n    type: 'array'\n  });\n  invalid = invalid || anchor(options.child).to({\n    type: 'array'\n  });\n  invalid = invalid || anchor(options.parentKey).to({\n    type: 'string'\n  });\n  invalid = invalid || anchor(options.childKey).to({\n    type: 'string'\n  });\n\n  invalid = invalid || (options.outer === 'right' ?\n    new Error('Right joins not supported yet.') : false);\n\n  if (invalid) throw invalid;\n\n\n  var resultSet = _.reduce(options.parent, function eachParentRow(memo, parentRow) {\n\n    // For each childRow whose childKey matches\n    // this parentRow's parentKey...\n    var foundMatch = _.reduce(options.child, function eachChildRow(hasFoundMatchYet, childRow) {\n\n      var newRow = partialJoin({\n        parentRow: parentRow,\n        childRow: childRow,\n        parentKey: options.parentKey,\n        childKey: options.childKey,\n        childNamespace: options.childNamespace\n      });\n\n      // console.log('PARENT ROW: ', parentRow);\n      // console.log('CHILD ROW: ', childRow);\n      // console.log('JOIN ROW: ', newRow);\n\n      // Save the new row for the join result if it exists\n      // and mark the match as found\n      if (newRow) {\n        memo.push(newRow);\n        return true;\n      }\n      return hasFoundMatchYet;\n    }, false);\n\n    // If this is a left outer join and we didn't find a match\n    // for this parentRow, add it to the result set anyways\n    if (!foundMatch && options.outer === 'left') {\n      memo.push(_.cloneDeep(parentRow));\n    }\n\n    return memo;\n  }, []);\n\n  // console.log('JOIN RESULT SET::', resultSet);\n  return resultSet;\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/integrator/_partialJoin.js":"/**\n * Module dependencies\n */\nvar assert = require('assert');\nvar _ = require('lodash');\n\n\n/**\n * _partialJoin\n *\n * @api private\n *\n * Check whether two rows match on the specified keys,\n * and if they do, merge `parentRow` into a copy of `childRow`\n * and return it (omit `childRow`'s key, since it === `parentRow`'s).\n *\n * Hypothetically, this function could be operated by a stream,\n * but in the case of a left outer join, at least, the final\n * result set cannot be accurately known until both the complete\n * contents of both the `left` and `right` data set have been checked.\n *\n * An optimization from polynomial to logarithmic computational\n * complexity could potentially be achieved by taking advantage\n * of the known L[k..l] and R[m..n] values as each new L[i] or R[j]\n * arrives from a stream, but a comparably-sized cache would have to\n * be maintained, so we'd still be stuck with polynomial memory usage.\n * i.e. O( |R|*|L| )  This could be resolved by batching-- e.g. grab the\n * first 3000 parent and child rows, join matches together, discard\n * the unneeded data, and repeat.\n *\n * Anyways, worth investigating, since this is a hot code path for\n * cross-adapter joins.\n *\n *\n * Usage:\n *\n * partialJoin({\n *   parentRow: { id: 5, name: 'Lucy', email: 'lucy@fakemail.org' }\n *   childRow:  { owner_id: 5, name: 'Rover', breed: 'Australian Shepherd' }\n *   parentKey: 'id'\n *   childKey:  'owner_id',\n *   childNamespace:  '.'\n * })\n *\n * @param  {Object} options\n * @return {Object|False}   If false, don't save the join row.\n * @synchronous\n */\nmodule.exports = function partialJoin(options) {\n\n  // Usage\n  var invalid = false;\n  invalid = invalid || !_.isObject(options);\n  invalid = invalid || !_.isString(options.parentKey);\n  invalid = invalid || !_.isString(options.childKey);\n  invalid = invalid || !_.isObject(options.parentRow);\n  invalid = invalid || !_.isObject(options.childRow);\n  assert(!invalid);\n\n  var CHILD_ATTR_PREFIX = (options.childNamespace || '.');\n\n  // If the rows aren't a match, bail out\n  if (\n    options.childRow[options.childKey] !==\n    options.parentRow[options.parentKey]\n    ) {\n    return false;\n  }\n\n  // deep clone the childRow, then delete `childKey` in the copy.\n  var newJoinRow = _.cloneDeep(options.childRow);\n  // console.log('deleting childKEy :: ',options.childKey);\n  // var _childKeyValue = newJoinRow[options.childKey];\n  // delete newJoinRow[options.childKey];\n\n  // namespace the remaining attributes in childRow\n  var namespacedJoinRow = {};\n  _.each(newJoinRow, function(value, key) {\n    var namespacedKey = CHILD_ATTR_PREFIX + key;\n    namespacedJoinRow[namespacedKey] = value;\n  });\n\n\n  // Merge namespaced values from current parentRow into the copy.\n  _.merge(namespacedJoinRow, options.parentRow);\n\n\n  // Return the newly joined row.\n  return namespacedJoinRow;\n};\n\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/integrator/innerJoin.js":"/**\n * Module dependencies\n */\nvar join = require('./_join');\n\n\n/**\n * Inner join\n *\n * Return a result set with data from child and parent\n * merged on childKey===parentKey, where t.e. exactly one\n * entry for each match.\n *\n * @option {Array} parent    [rows from the \"lefthand table\"]\n * @option {Array} child   [rows from the \"righthand table\"]\n * @option {String} parentKey     [primary key of the \"lefthand table\"]\n * @option {String} childKey     [foreign key from the \"righthand table\" to the \"lefthand table\"]\n * @return {Array}          [a new array of joined row data]\n *\n * @throws {Error} on invalid input\n * @synchronous\n */\nmodule.exports = function leftOuterJoin(options) {\n  options.outer = false;\n  return join(options);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/integrator/populate.js":"/**\n * Module dependencies\n */\nvar _ = require('lodash');\n\n\n/**\n * populate()\n *\n * Destructive mapping of `parentRows` to include a new key, `alias`,\n * which is an ordered array of child rows.\n *\n * @option [{Object}] parentRows    - the parent rows the joined rows will be folded into\n * @option {String} alias           - the alias of the association\n * @option [{Object}] childRows     - the unfolded result set from the joins\n *\n * @option {String} parentPK        - the primary key of the parent table (optional- only needed for M..N associations)\n * @option {String} fkToChild       - the foreign key associating a row with the child table\n * @option {String} childPK         - the primary key of the child table\n *\n * @option [{String}] childNamespace- attributes to keep\n *\n * @return {*Object} reference to `parentRows`\n */\nmodule.exports = function populate(options) {\n\n  var parentRows = options.parentRows;\n  var alias = options.alias;\n  var childRows = options.childRows;\n\n  var parentPK = options.parentPK;\n  var childPK = options.childPK;\n  var fkToChild = options.fkToChild;\n  var fkToParent = parentPK;// At least for all use cases currently, `fkToParent` <=> `parentPK`\n\n  var childNamespace = options.childNamespace || '';\n\n  return _.map(parentRows, function _insertJoinedResults(parentRow) {\n\n    // Gather the subset of child rows associated with the current parent row\n    var associatedChildRows = _.where(childRows,\n      // { (parentPK): (parentRow[(parentPK)]) }, e.g. { id: 3 }\n      _cons(fkToParent, parentRow[parentPK])\n    );\n\n    // Clone the `associatedChildRows` to avoid mutating the original\n    // `childRows` in the cache.\n    associatedChildRows = _.cloneDeep(associatedChildRows);\n\n    // Stuff the sanitized associated child rows into the parent row.\n    parentRow[alias] =\n    _.reduce(associatedChildRows, function(memo, childRow) {\n\n      // Ignore child rows without an appropriate foreign key\n      // to an instance in the REAL child collection.\n      if (!childRow[childNamespace + childPK] && !childRow[childPK]) return memo;\n\n      // Rename childRow's [fkToChild] key to [childPK]\n      // (so that it will have the proper primary key attribute for its collection)\n      var childPKValue = childRow[fkToChild];\n      childRow[childPK] = childPKValue;\n\n      // Determine if we have any double nested attributes.\n      // These would come from m:m joins\n      var doubleNested = _.find(childRow, function(name, key) {\n        return _.startsWith(key, '..');\n      });\n\n      // Grab all the keys that start with a dot or double dot depending on\n      // the status of doubleNested\n      childRow = _.pick(childRow, function(name, key) {\n        if (doubleNested) {\n          return _.startsWith(key, '..');\n        } else {\n          return _.startsWith(key, '.');\n        }\n      });\n\n      var _origChildRow = childRow;\n\n      // Strip off childNamespace prefix\n      childRow = {};\n      var PREFIX_REGEXP = new RegExp('^' + childNamespace + '');\n      _.each(_origChildRow, function(attrValue, attrName) {\n        var unprefixedKey = attrName.replace(PREFIX_REGEXP, '');\n        childRow[unprefixedKey] = attrValue;\n      });\n\n      // Build the set of rows to stuff into our parent row.\n      memo.push(childRow);\n      return memo;\n    }, []);\n\n    return parentRow;\n  });\n};\n\n\n/**\n * Dumb little helper because I hate naming anonymous objects just to use them once.\n *\n * @return {Object} [a tuple]\n * @api private\n */\nfunction _cons(key, value) {\n  var obj = {};\n  obj[key] = value;\n  return obj;\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/index.js":"module.exports = require('./lib');","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/lib/index.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar util = require('util');\nvar path = require('path');\n\n\nmodule.exports = _.extend(\n\n  // Provide all-in-one top-level function\n  require('./query'),\n\n  // but also expose direct access\n  // to all filters and projections.\n  {\n    where: require('./filters/where'),\n    limit: require('./filters/limit'),\n    skip: require('./filters/skip'),\n    sort: require('./sort'),\n\n    // Projections and aggregations are not-yet-officially supported:\n    groupBy: require('./projections/groupBy'),\n    select: require('./projections/select')\n\n    // Joins are currently supported by Waterline core:\n    // , populate : require('./projections/populate')\n    // , leftJoin : require('./projections/leftJoin')\n    // , join     : require('./projections/join')\n    // , rightJoin : require('./projections/rightJoin')\n\n  });\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/node_modules/lodash/dist/lodash.js":"/**\n * @license\n * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern -o ./dist/lodash.js`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre ES5 environments */\n  var undefined;\n\n  /** Used to pool arrays and objects used internally */\n  var arrayPool = [],\n      objectPool = [];\n\n  /** Used to generate unique IDs */\n  var idCounter = 0;\n\n  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */\n  var keyPrefix = +new Date + '';\n\n  /** Used as the size when optimizations are enabled for large arrays */\n  var largeArraySize = 75;\n\n  /** Used as the max size of the `arrayPool` and `objectPool` */\n  var maxPoolSize = 40;\n\n  /** Used to detect and test whitespace */\n  var whitespace = (\n    // whitespace\n    ' \\t\\x0B\\f\\xA0\\ufeff' +\n\n    // line terminators\n    '\\n\\r\\u2028\\u2029' +\n\n    // unicode category \"Zs\" space separators\n    '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n  );\n\n  /** Used to match empty string literals in compiled template source */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /**\n   * Used to match ES6 template delimiters\n   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match regexp flags from their coerced string values */\n  var reFlags = /\\w*$/;\n\n  /** Used to detected named functions */\n  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n  /** Used to match \"interpolate\" template delimiters */\n  var reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match leading whitespace and zeros to be removed */\n  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');\n\n  /** Used to ensure capturing order of template delimiters */\n  var reNoMatch = /($^)/;\n\n  /** Used to detect functions containing a `this` reference */\n  var reThis = /\\bthis\\b/;\n\n  /** Used to match unescaped characters in compiled string literals */\n  var reUnescapedString = /['\\n\\r\\t\\u2028\\u2029\\\\]/g;\n\n  /** Used to assign default `context` object properties */\n  var contextProps = [\n    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',\n    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',\n    'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify */\n  var templateCounter = 0;\n\n  /** `Object#toString` result shortcuts */\n  var argsClass = '[object Arguments]',\n      arrayClass = '[object Array]',\n      boolClass = '[object Boolean]',\n      dateClass = '[object Date]',\n      funcClass = '[object Function]',\n      numberClass = '[object Number]',\n      objectClass = '[object Object]',\n      regexpClass = '[object RegExp]',\n      stringClass = '[object String]';\n\n  /** Used to identify object classifications that `_.clone` supports */\n  var cloneableClasses = {};\n  cloneableClasses[funcClass] = false;\n  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =\n  cloneableClasses[boolClass] = cloneableClasses[dateClass] =\n  cloneableClasses[numberClass] = cloneableClasses[objectClass] =\n  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;\n\n  /** Used as an internal `_.debounce` options object */\n  var debounceOptions = {\n    'leading': false,\n    'maxWait': 0,\n    'trailing': false\n  };\n\n  /** Used as the property descriptor for `__bindData__` */\n  var descriptor = {\n    'configurable': false,\n    'enumerable': false,\n    'value': null,\n    'writable': false\n  };\n\n  /** Used to determine if values are of the language type Object */\n  var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\t': 't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Used as a reference to the global object */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Detect free variable `exports` */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module` */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports` */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n  var freeGlobal = objectTypes[typeof global] && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches\n   * or `fromIndex` constraints.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value or `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    var index = (fromIndex || 0) - 1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * An implementation of `_.contains` for cache objects that mimics the return\n   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.\n   *\n   * @private\n   * @param {Object} cache The cache object to inspect.\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `0` if `value` is found, else `-1`.\n   */\n  function cacheIndexOf(cache, value) {\n    var type = typeof value;\n    cache = cache.cache;\n\n    if (type == 'boolean' || value == null) {\n      return cache[value] ? 0 : -1;\n    }\n    if (type != 'number' && type != 'string') {\n      type = 'object';\n    }\n    var key = type == 'number' ? value : keyPrefix + value;\n    cache = (cache = cache[type]) && cache[key];\n\n    return type == 'object'\n      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)\n      : (cache ? 0 : -1);\n  }\n\n  /**\n   * Adds a given value to the corresponding cache object.\n   *\n   * @private\n   * @param {*} value The value to add to the cache.\n   */\n  function cachePush(value) {\n    var cache = this.cache,\n        type = typeof value;\n\n    if (type == 'boolean' || value == null) {\n      cache[value] = true;\n    } else {\n      if (type != 'number' && type != 'string') {\n        type = 'object';\n      }\n      var key = type == 'number' ? value : keyPrefix + value,\n          typeCache = cache[type] || (cache[type] = {});\n\n      if (type == 'object') {\n        (typeCache[key] || (typeCache[key] = [])).push(value);\n      } else {\n        typeCache[key] = true;\n      }\n    }\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default callback when a given\n   * collection is a string value.\n   *\n   * @private\n   * @param {string} value The character to inspect.\n   * @returns {number} Returns the code unit of given character.\n   */\n  function charAtCallback(value) {\n    return value.charCodeAt(0);\n  }\n\n  /**\n   * Used by `sortBy` to compare transformed `collection` elements, stable sorting\n   * them in ascending order.\n   *\n   * @private\n   * @param {Object} a The object to compare to `b`.\n   * @param {Object} b The object to compare to `a`.\n   * @returns {number} Returns the sort order indicator of `1` or `-1`.\n   */\n  function compareAscending(a, b) {\n    var ac = a.criteria,\n        bc = b.criteria,\n        index = -1,\n        length = ac.length;\n\n    while (++index < length) {\n      var value = ac[index],\n          other = bc[index];\n\n      if (value !== other) {\n        if (value > other || typeof value == 'undefined') {\n          return 1;\n        }\n        if (value < other || typeof other == 'undefined') {\n          return -1;\n        }\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to return the same value for\n    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See http://code.google.com/p/v8/issues/detail?id=90\n    return a.index - b.index;\n  }\n\n  /**\n   * Creates a cache object to optimize linear searches of large arrays.\n   *\n   * @private\n   * @param {Array} [array=[]] The array to search.\n   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.\n   */\n  function createCache(array) {\n    var index = -1,\n        length = array.length,\n        first = array[0],\n        mid = array[(length / 2) | 0],\n        last = array[length - 1];\n\n    if (first && typeof first == 'object' &&\n        mid && typeof mid == 'object' && last && typeof last == 'object') {\n      return false;\n    }\n    var cache = getObject();\n    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;\n\n    var result = getObject();\n    result.array = array;\n    result.cache = cache;\n    result.push = cachePush;\n\n    while (++index < length) {\n      result.push(array[index]);\n    }\n    return result;\n  }\n\n  /**\n   * Used by `template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {string} match The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(match) {\n    return '\\\\' + stringEscapes[match];\n  }\n\n  /**\n   * Gets an array from the array pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Array} The array from the pool.\n   */\n  function getArray() {\n    return arrayPool.pop() || [];\n  }\n\n  /**\n   * Gets an object from the object pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Object} The object from the pool.\n   */\n  function getObject() {\n    return objectPool.pop() || {\n      'array': null,\n      'cache': null,\n      'criteria': null,\n      'false': false,\n      'index': 0,\n      'null': false,\n      'number': null,\n      'object': null,\n      'push': null,\n      'string': null,\n      'true': false,\n      'undefined': false,\n      'value': null\n    };\n  }\n\n  /**\n   * Releases the given array back to the array pool.\n   *\n   * @private\n   * @param {Array} [array] The array to release.\n   */\n  function releaseArray(array) {\n    array.length = 0;\n    if (arrayPool.length < maxPoolSize) {\n      arrayPool.push(array);\n    }\n  }\n\n  /**\n   * Releases the given object back to the object pool.\n   *\n   * @private\n   * @param {Object} [object] The object to release.\n   */\n  function releaseObject(object) {\n    var cache = object.cache;\n    if (cache) {\n      releaseObject(cache);\n    }\n    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;\n    if (objectPool.length < maxPoolSize) {\n      objectPool.push(object);\n    }\n  }\n\n  /**\n   * Slices the `collection` from the `start` index up to, but not including,\n   * the `end` index.\n   *\n   * Note: This function is used instead of `Array#slice` to support node lists\n   * in IE < 9 and to ensure dense arrays are returned.\n   *\n   * @private\n   * @param {Array|Object|string} collection The collection to slice.\n   * @param {number} start The start index.\n   * @param {number} end The end index.\n   * @returns {Array} Returns the new array.\n   */\n  function slice(array, start, end) {\n    start || (start = 0);\n    if (typeof end == 'undefined') {\n      end = array ? array.length : 0;\n    }\n    var index = -1,\n        length = end - start || 0,\n        result = Array(length < 0 ? 0 : length);\n\n    while (++index < length) {\n      result[index] = array[start + index];\n    }\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new `lodash` function using the given context object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns the `lodash` function.\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See http://es5.github.io/#x11.1.5.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references */\n    var Array = context.Array,\n        Boolean = context.Boolean,\n        Date = context.Date,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /**\n     * Used for `Array` method references.\n     *\n     * Normally `Array.prototype` would suffice, however, using an array literal\n     * avoids issues in Narwhal.\n     */\n    var arrayRef = [];\n\n    /** Used for native method references */\n    var objectProto = Object.prototype;\n\n    /** Used to restore the original `_` reference in `noConflict` */\n    var oldDash = context._;\n\n    /** Used to resolve the internal [[Class]] of values */\n    var toString = objectProto.toString;\n\n    /** Used to detect if a method is native */\n    var reNative = RegExp('^' +\n      String(toString)\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n        .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n    );\n\n    /** Native method shortcuts */\n    var ceil = Math.ceil,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        fnToString = Function.prototype.toString,\n        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n        hasOwnProperty = objectProto.hasOwnProperty,\n        push = arrayRef.push,\n        setTimeout = context.setTimeout,\n        splice = arrayRef.splice,\n        unshift = arrayRef.unshift;\n\n    /** Used to set meta data on functions */\n    var defineProperty = (function() {\n      // IE 8 only accepts DOM elements\n      try {\n        var o = {},\n            func = isNative(func = Object.defineProperty) && func,\n            result = func(o, o, o) && func;\n      } catch(e) { }\n      return result;\n    }());\n\n    /* Native method shortcuts for methods with the same name as other `lodash` methods */\n    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n        nativeIsFinite = context.isFinite,\n        nativeIsNaN = context.isNaN,\n        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used to lookup a built-in constructor by [[Class]] */\n    var ctorByClass = {};\n    ctorByClass[arrayClass] = Array;\n    ctorByClass[boolClass] = Boolean;\n    ctorByClass[dateClass] = Date;\n    ctorByClass[funcClass] = Function;\n    ctorByClass[objectClass] = Object;\n    ctorByClass[numberClass] = Number;\n    ctorByClass[regexpClass] = RegExp;\n    ctorByClass[stringClass] = String;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps the given value to enable intuitive\n     * method chaining.\n     *\n     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n     * and `unshift`\n     *\n     * Chaining is supported in custom builds as long as the `value` method is\n     * implicitly or explicitly included in the build.\n     *\n     * The chainable wrapper functions are:\n     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,\n     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,\n     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,\n     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,\n     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,\n     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,\n     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,\n     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,\n     * and `zip`\n     *\n     * The non-chainable wrapper functions are:\n     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,\n     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,\n     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,\n     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,\n     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,\n     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,\n     * `template`, `unescape`, `uniqueId`, and `value`\n     *\n     * The wrapper functions `first` and `last` return wrapped values when `n` is\n     * provided, otherwise they return unwrapped values.\n     *\n     * Explicit chaining can be enabled by using the `_.chain` method.\n     *\n     * @name _\n     * @constructor\n     * @category Chaining\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns a `lodash` instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(num) {\n     *   return num * num;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor\n      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))\n       ? value\n       : new lodashWrapper(value);\n    }\n\n    /**\n     * A fast path for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @param {boolean} chainAll A flag to enable chaining for all methods\n     * @returns {Object} Returns a `lodash` instance.\n     */\n    function lodashWrapper(value, chainAll) {\n      this.__chain__ = !!chainAll;\n      this.__wrapped__ = value;\n    }\n    // ensure `new lodashWrapper` is an instance of `lodash`\n    lodashWrapper.prototype = lodash.prototype;\n\n    /**\n     * An object used to flag environments features.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    /**\n     * Detect if functions can be decompiled by `Function#toString`\n     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);\n\n    /**\n     * Detect if `Function#name` is supported (all but IE).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcNames = typeof Function.name == 'string';\n\n    /**\n     * By default, the template delimiters used by Lo-Dash are similar to those in\n     * embedded Ruby (ERB). Change the following template settings to use alternative\n     * delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': /<%-([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': /<%([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The base implementation of `_.bind` that creates the bound function and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new bound function.\n     */\n    function baseBind(bindData) {\n      var func = bindData[0],\n          partialArgs = bindData[2],\n          thisArg = bindData[4];\n\n      function bound() {\n        // `Function#bind` spec\n        // http://es5.github.io/#x15.3.4.5\n        if (partialArgs) {\n          // avoid `arguments` object deoptimizations by using `slice` instead\n          // of `Array.prototype.slice.call` and not assigning `arguments` to a\n          // variable as a ternary expression\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        // mimic the constructor's `return` behavior\n        // http://es5.github.io/#x13.2.2\n        if (this instanceof bound) {\n          // ensure `new bound` is an instance of `func`\n          var thisBinding = baseCreate(func.prototype),\n              result = func.apply(thisBinding, args || arguments);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisArg, args || arguments);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.clone` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, callback, stackA, stackB) {\n      if (callback) {\n        var result = callback(value);\n        if (typeof result != 'undefined') {\n          return result;\n        }\n      }\n      // inspect [[Class]]\n      var isObj = isObject(value);\n      if (isObj) {\n        var className = toString.call(value);\n        if (!cloneableClasses[className]) {\n          return value;\n        }\n        var ctor = ctorByClass[className];\n        switch (className) {\n          case boolClass:\n          case dateClass:\n            return new ctor(+value);\n\n          case numberClass:\n          case stringClass:\n            return new ctor(value);\n\n          case regexpClass:\n            result = ctor(value.source, reFlags.exec(value));\n            result.lastIndex = value.lastIndex;\n            return result;\n        }\n      } else {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isDeep) {\n        // check for circular references and return corresponding clone\n        var initedStack = !stackA;\n        stackA || (stackA = getArray());\n        stackB || (stackB = getArray());\n\n        var length = stackA.length;\n        while (length--) {\n          if (stackA[length] == value) {\n            return stackB[length];\n          }\n        }\n        result = isArr ? ctor(value.length) : {};\n      }\n      else {\n        result = isArr ? slice(value) : assign({}, value);\n      }\n      // add array properties assigned by `RegExp#exec`\n      if (isArr) {\n        if (hasOwnProperty.call(value, 'index')) {\n          result.index = value.index;\n        }\n        if (hasOwnProperty.call(value, 'input')) {\n          result.input = value.input;\n        }\n      }\n      // exit for shallow clone\n      if (!isDeep) {\n        return result;\n      }\n      // add the source value to the stack of traversed objects\n      // and associate it with its clone\n      stackA.push(value);\n      stackB.push(result);\n\n      // recursively populate clone (susceptible to call stack limits)\n      (isArr ? forEach : forOwn)(value, function(objValue, key) {\n        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);\n      });\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    function baseCreate(prototype, properties) {\n      return isObject(prototype) ? nativeCreate(prototype) : {};\n    }\n    // fallback for browsers without `Object.create`\n    if (!nativeCreate) {\n      baseCreate = (function() {\n        function Object() {}\n        return function(prototype) {\n          if (isObject(prototype)) {\n            Object.prototype = prototype;\n            var result = new Object;\n            Object.prototype = null;\n          }\n          return result || context.Object();\n        };\n      }());\n    }\n\n    /**\n     * The base implementation of `_.createCallback` without support for creating\n     * \"_.pluck\" or \"_.where\" style callbacks.\n     *\n     * @private\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     */\n    function baseCreateCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      // exit early for no `thisArg` or already bound by `Function#bind`\n      if (typeof thisArg == 'undefined' || !('prototype' in func)) {\n        return func;\n      }\n      var bindData = func.__bindData__;\n      if (typeof bindData == 'undefined') {\n        if (support.funcNames) {\n          bindData = !func.name;\n        }\n        bindData = bindData || !support.funcDecomp;\n        if (!bindData) {\n          var source = fnToString.call(func);\n          if (!support.funcNames) {\n            bindData = !reFuncName.test(source);\n          }\n          if (!bindData) {\n            // checks if `func` references the `this` keyword and stores the result\n            bindData = reThis.test(source);\n            setBindData(func, bindData);\n          }\n        }\n      }\n      // exit early if there are no `this` references or `func` is bound\n      if (bindData === false || (bindData !== true && bindData[1] & 1)) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 2: return function(a, b) {\n          return func.call(thisArg, a, b);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n      }\n      return bind(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `createWrapper` that creates the wrapper and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new function.\n     */\n    function baseCreateWrapper(bindData) {\n      var func = bindData[0],\n          bitmask = bindData[1],\n          partialArgs = bindData[2],\n          partialRightArgs = bindData[3],\n          thisArg = bindData[4],\n          arity = bindData[5];\n\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          key = func;\n\n      function bound() {\n        var thisBinding = isBind ? thisArg : this;\n        if (partialArgs) {\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        if (partialRightArgs || isCurry) {\n          args || (args = slice(arguments));\n          if (partialRightArgs) {\n            push.apply(args, partialRightArgs);\n          }\n          if (isCurry && args.length < arity) {\n            bitmask |= 16 & ~32;\n            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);\n          }\n        }\n        args || (args = arguments);\n        if (isBindKey) {\n          func = thisBinding[key];\n        }\n        if (this instanceof bound) {\n          thisBinding = baseCreate(func.prototype);\n          var result = func.apply(thisBinding, args);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisBinding, args);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.difference` that accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {Array} [values] The array of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          isLarge = length >= largeArraySize && indexOf === baseIndexOf,\n          result = [];\n\n      if (isLarge) {\n        var cache = createCache(values);\n        if (cache) {\n          indexOf = cacheIndexOf;\n          values = cache;\n        } else {\n          isLarge = false;\n        }\n      }\n      while (++index < length) {\n        var value = array[index];\n        if (indexOf(values, value) < 0) {\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseObject(values);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` without support for callback\n     * shorthands or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.\n     * @param {number} [fromIndex=0] The index to start from.\n     * @returns {Array} Returns a new flattened array.\n     */\n    function baseFlatten(array, isShallow, isStrict, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n\n        if (value && typeof value == 'object' && typeof value.length == 'number'\n            && (isArray(value) || isArguments(value))) {\n          // recursively flatten arrays (susceptible to call stack limits)\n          if (!isShallow) {\n            value = baseFlatten(value, isShallow, isStrict);\n          }\n          var valIndex = -1,\n              valLength = value.length,\n              resIndex = result.length;\n\n          result.length += valLength;\n          while (++valIndex < valLength) {\n            result[resIndex++] = value[valIndex];\n          }\n        } else if (!isStrict) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isEqual`, without support for `thisArg` binding,\n     * that allows partial \"_.where\" style comparisons.\n     *\n     * @private\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `a` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `b` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {\n      // used to indicate that when comparing objects, `a` has at least the properties of `b`\n      if (callback) {\n        var result = callback(a, b);\n        if (typeof result != 'undefined') {\n          return !!result;\n        }\n      }\n      // exit early for identical values\n      if (a === b) {\n        // treat `+0` vs. `-0` as not equal\n        return a !== 0 || (1 / a == 1 / b);\n      }\n      var type = typeof a,\n          otherType = typeof b;\n\n      // exit early for unlike primitive values\n      if (a === a &&\n          !(a && objectTypes[type]) &&\n          !(b && objectTypes[otherType])) {\n        return false;\n      }\n      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior\n      // http://es5.github.io/#x15.3.4.4\n      if (a == null || b == null) {\n        return a === b;\n      }\n      // compare [[Class]] names\n      var className = toString.call(a),\n          otherClass = toString.call(b);\n\n      if (className == argsClass) {\n        className = objectClass;\n      }\n      if (otherClass == argsClass) {\n        otherClass = objectClass;\n      }\n      if (className != otherClass) {\n        return false;\n      }\n      switch (className) {\n        case boolClass:\n        case dateClass:\n          // coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal\n          return +a == +b;\n\n        case numberClass:\n          // treat `NaN` vs. `NaN` as equal\n          return (a != +a)\n            ? b != +b\n            // but treat `+0` vs. `-0` as not equal\n            : (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n        case regexpClass:\n        case stringClass:\n          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)\n          // treat string primitives and their corresponding object instances as equal\n          return a == String(b);\n      }\n      var isArr = className == arrayClass;\n      if (!isArr) {\n        // unwrap any `lodash` wrapped values\n        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),\n            bWrapped = hasOwnProperty.call(b, '__wrapped__');\n\n        if (aWrapped || bWrapped) {\n          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);\n        }\n        // exit for functions and DOM nodes\n        if (className != objectClass) {\n          return false;\n        }\n        // in older versions of Opera, `arguments` objects have `Array` constructors\n        var ctorA = a.constructor,\n            ctorB = b.constructor;\n\n        // non `Object` object instances with different constructors are not equal\n        if (ctorA != ctorB &&\n              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&\n              ('constructor' in a && 'constructor' in b)\n            ) {\n          return false;\n        }\n      }\n      // assume cyclic structures are equal\n      // the algorithm for detecting cyclic structures is adapted from ES 5.1\n      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)\n      var initedStack = !stackA;\n      stackA || (stackA = getArray());\n      stackB || (stackB = getArray());\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == a) {\n          return stackB[length] == b;\n        }\n      }\n      var size = 0;\n      result = true;\n\n      // add `a` and `b` to the stack of traversed objects\n      stackA.push(a);\n      stackB.push(b);\n\n      // recursively compare objects and arrays (susceptible to call stack limits)\n      if (isArr) {\n        // compare lengths to determine if a deep comparison is necessary\n        length = a.length;\n        size = b.length;\n        result = size == length;\n\n        if (result || isWhere) {\n          // deep compare the contents, ignoring non-numeric properties\n          while (size--) {\n            var index = length,\n                value = b[size];\n\n            if (isWhere) {\n              while (index--) {\n                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {\n                  break;\n                }\n              }\n            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {\n              break;\n            }\n          }\n        }\n      }\n      else {\n        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`\n        // which, in this case, is more costly\n        forIn(b, function(value, key, b) {\n          if (hasOwnProperty.call(b, key)) {\n            // count the number of properties.\n            size++;\n            // deep compare each property value.\n            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));\n          }\n        });\n\n        if (result && !isWhere) {\n          // ensure both objects have the same number of properties\n          forIn(a, function(value, key, a) {\n            if (hasOwnProperty.call(a, key)) {\n              // `size` will be `-1` if `a` has more properties than `b`\n              return (result = --size > -1);\n            }\n          });\n        }\n      }\n      stackA.pop();\n      stackB.pop();\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.merge` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     */\n    function baseMerge(object, source, callback, stackA, stackB) {\n      (isArray(source) ? forEach : forOwn)(source, function(source, key) {\n        var found,\n            isArr,\n            result = source,\n            value = object[key];\n\n        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {\n          // avoid merging previously merged cyclic sources\n          var stackLength = stackA.length;\n          while (stackLength--) {\n            if ((found = stackA[stackLength] == source)) {\n              value = stackB[stackLength];\n              break;\n            }\n          }\n          if (!found) {\n            var isShallow;\n            if (callback) {\n              result = callback(value, source);\n              if ((isShallow = typeof result != 'undefined')) {\n                value = result;\n              }\n            }\n            if (!isShallow) {\n              value = isArr\n                ? (isArray(value) ? value : [])\n                : (isPlainObject(value) ? value : {});\n            }\n            // add `source` and associated `value` to the stack of traversed objects\n            stackA.push(source);\n            stackB.push(value);\n\n            // recursively merge objects and arrays (susceptible to call stack limits)\n            if (!isShallow) {\n              baseMerge(value, source, callback, stackA, stackB);\n            }\n          }\n        }\n        else {\n          if (callback) {\n            result = callback(value, source);\n            if (typeof result == 'undefined') {\n              result = source;\n            }\n          }\n          if (typeof result != 'undefined') {\n            value = result;\n          }\n        }\n        object[key] = value;\n      });\n    }\n\n    /**\n     * The base implementation of `_.random` without argument juggling or support\n     * for returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns a random number.\n     */\n    function baseRandom(min, max) {\n      return min + floor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function} [callback] The function called per iteration.\n     * @returns {Array} Returns a duplicate-value-free array.\n     */\n    function baseUniq(array, isSorted, callback) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          result = [];\n\n      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,\n          seen = (callback || isLarge) ? getArray() : result;\n\n      if (isLarge) {\n        var cache = createCache(seen);\n        indexOf = cacheIndexOf;\n        seen = cache;\n      }\n      while (++index < length) {\n        var value = array[index],\n            computed = callback ? callback(value, index, array) : value;\n\n        if (isSorted\n              ? !index || seen[seen.length - 1] !== computed\n              : indexOf(seen, computed) < 0\n            ) {\n          if (callback || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseArray(seen.array);\n        releaseObject(seen);\n      } else if (callback) {\n        releaseArray(seen);\n      }\n      return result;\n    }\n\n    /**\n     * Creates a function that aggregates a collection, creating an object composed\n     * of keys generated from the results of running each element of the collection\n     * through a callback. The given `setter` function sets the keys and values\n     * of the composed object.\n     *\n     * @private\n     * @param {Function} setter The setter function.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter) {\n      return function(collection, callback, thisArg) {\n        var result = {};\n        callback = lodash.createCallback(callback, thisArg, 3);\n\n        var index = -1,\n            length = collection ? collection.length : 0;\n\n        if (typeof length == 'number') {\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, callback(value, index, collection), collection);\n          }\n        } else {\n          forOwn(collection, function(value, key, collection) {\n            setter(result, value, callback(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, either curries or invokes `func`\n     * with an optional `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of method flags to compose.\n     *  The bitmask may be composed of the following flags:\n     *  1 - `_.bind`\n     *  2 - `_.bindKey`\n     *  4 - `_.curry`\n     *  8 - `_.curry` (bound)\n     *  16 - `_.partial`\n     *  32 - `_.partialRight`\n     * @param {Array} [partialArgs] An array of arguments to prepend to those\n     *  provided to the new function.\n     * @param {Array} [partialRightArgs] An array of arguments to append to those\n     *  provided to the new function.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new function.\n     */\n    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          isPartial = bitmask & 16,\n          isPartialRight = bitmask & 32;\n\n      if (!isBindKey && !isFunction(func)) {\n        throw new TypeError;\n      }\n      if (isPartial && !partialArgs.length) {\n        bitmask &= ~16;\n        isPartial = partialArgs = false;\n      }\n      if (isPartialRight && !partialRightArgs.length) {\n        bitmask &= ~32;\n        isPartialRight = partialRightArgs = false;\n      }\n      var bindData = func && func.__bindData__;\n      if (bindData && bindData !== true) {\n        // clone `bindData`\n        bindData = slice(bindData);\n        if (bindData[2]) {\n          bindData[2] = slice(bindData[2]);\n        }\n        if (bindData[3]) {\n          bindData[3] = slice(bindData[3]);\n        }\n        // set `thisBinding` is not previously bound\n        if (isBind && !(bindData[1] & 1)) {\n          bindData[4] = thisArg;\n        }\n        // set if previously bound but not currently (subsequent curried functions)\n        if (!isBind && bindData[1] & 1) {\n          bitmask |= 8;\n        }\n        // set curried arity if not yet set\n        if (isCurry && !(bindData[1] & 4)) {\n          bindData[5] = arity;\n        }\n        // append partial left arguments\n        if (isPartial) {\n          push.apply(bindData[2] || (bindData[2] = []), partialArgs);\n        }\n        // append partial right arguments\n        if (isPartialRight) {\n          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);\n        }\n        // merge flags\n        bindData[1] |= bitmask;\n        return createWrapper.apply(null, bindData);\n      }\n      // fast path for `_.bind`\n      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;\n      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);\n    }\n\n    /**\n     * Used by `escape` to convert characters to HTML entities.\n     *\n     * @private\n     * @param {string} match The matched character to escape.\n     * @returns {string} Returns the escaped character.\n     */\n    function escapeHtmlChar(match) {\n      return htmlEscapes[match];\n    }\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized, this method returns the custom method, otherwise it returns\n     * the `baseIndexOf` function.\n     *\n     * @private\n     * @returns {Function} Returns the \"indexOf\" function.\n     */\n    function getIndexOf() {\n      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.\n     */\n    function isNative(value) {\n      return typeof value == 'function' && reNative.test(value);\n    }\n\n    /**\n     * Sets `this` binding data on a given function.\n     *\n     * @private\n     * @param {Function} func The function to set data on.\n     * @param {Array} value The data array to set.\n     */\n    var setBindData = !defineProperty ? noop : function(func, value) {\n      descriptor.value = value;\n      defineProperty(func, '__bindData__', descriptor);\n      descriptor.value = null;\n    };\n\n    /**\n     * A fallback implementation of `isPlainObject` which checks if a given value\n     * is an object created by the `Object` constructor, assuming objects created\n     * by the `Object` constructor have no inherited enumerable properties and that\n     * there are no `Object.prototype` extensions.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     */\n    function shimIsPlainObject(value) {\n      var ctor,\n          result;\n\n      // avoid non Object objects, `arguments` objects, and DOM elements\n      if (!(value && toString.call(value) == objectClass) ||\n          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {\n        return false;\n      }\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      forIn(value, function(value, key) {\n        result = key;\n      });\n      return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * Used by `unescape` to convert HTML entities to characters.\n     *\n     * @private\n     * @param {string} match The matched character to unescape.\n     * @returns {string} Returns the unescaped character.\n     */\n    function unescapeHtmlChar(match) {\n      return htmlUnescapes[match];\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Checks if `value` is an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.\n     * @example\n     *\n     * (function() { return _.isArguments(arguments); })(1, 2, 3);\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == argsClass || false;\n    }\n\n    /**\n     * Checks if `value` is an array.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.\n     * @example\n     *\n     * (function() { return _.isArray(arguments); })();\n     * // => false\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     */\n    var isArray = nativeIsArray || function(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == arrayClass || false;\n    };\n\n    /**\n     * A fallback implementation of `Object.keys` which produces an array of the\n     * given object's own enumerable property names.\n     *\n     * @private\n     * @type Function\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     */\n    var shimKeys = function(object) {\n      var index, iterable = object, result = [];\n      if (!iterable) return result;\n      if (!(objectTypes[typeof object])) return result;\n        for (index in iterable) {\n          if (hasOwnProperty.call(iterable, index)) {\n            result.push(index);\n          }\n        }\n      return result\n    };\n\n    /**\n     * Creates an array composed of the own enumerable property names of an object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     * @example\n     *\n     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      if (!isObject(object)) {\n        return [];\n      }\n      return nativeKeys(object);\n    };\n\n    /**\n     * Used to convert characters to HTML entities:\n     *\n     * Though the `>` character is escaped for symmetry, characters like `>` and `/`\n     * don't require escaping in HTML and have no special meaning unless they're part\n     * of a tag or an unquoted attribute value.\n     * http://mathiasbynens.be/notes/ambiguous-ampersands (under \"semi-related fun fact\")\n     */\n    var htmlEscapes = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n\n    /** Used to convert HTML entities to characters */\n    var htmlUnescapes = invert(htmlEscapes);\n\n    /** Used to match HTML entities and HTML characters */\n    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),\n        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources will overwrite property assignments of previous\n     * sources. If a callback is provided it will be executed to produce the\n     * assigned values. The callback is bound to `thisArg` and invoked with two\n     * arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @alias extend\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize assigning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });\n     * // => { 'name': 'fred', 'employer': 'slate' }\n     *\n     * var defaults = _.partialRight(_.assign, function(a, b) {\n     *   return typeof a == 'undefined' ? b : a;\n     * });\n     *\n     * var object = { 'name': 'barney' };\n     * defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var assign = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n        callback = args[--argsLength];\n      }\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also\n     * be cloned, otherwise they will be assigned by reference. If a callback\n     * is provided it will be executed to produce the cloned values. If the\n     * callback returns `undefined` cloning will be handled by the method instead.\n     * The callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var shallow = _.clone(characters);\n     * shallow[0] === characters[0];\n     * // => true\n     *\n     * var deep = _.clone(characters, true);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * _.mixin({\n     *   'clone': _.partialRight(_.clone, function(value) {\n     *     return _.isElement(value) ? value.cloneNode(false) : undefined;\n     *   })\n     * });\n     *\n     * var clone = _.clone(document.body);\n     * clone.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, callback, thisArg) {\n      // allows working with \"Collections\" methods without using their `index`\n      // and `collection` arguments for `isDeep` and `callback`\n      if (typeof isDeep != 'boolean' && isDeep != null) {\n        thisArg = callback;\n        callback = isDeep;\n        isDeep = false;\n      }\n      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates a deep clone of `value`. If a callback is provided it will be\n     * executed to produce the cloned values. If the callback returns `undefined`\n     * cloning will be handled by the method instead. The callback is bound to\n     * `thisArg` and invoked with one argument; (value).\n     *\n     * Note: This method is loosely based on the structured clone algorithm. Functions\n     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and\n     * objects created by constructors other than `Object` are cloned to plain `Object` objects.\n     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var deep = _.cloneDeep(characters);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'node': element\n     * };\n     *\n     * var clone = _.cloneDeep(view, function(value) {\n     *   return _.isElement(value) ? value.cloneNode(true) : undefined;\n     * });\n     *\n     * clone.node == view.node;\n     * // => false\n     */\n    function cloneDeep(value, callback, thisArg) {\n      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties ? assign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional defaults of the same property will be ignored.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param- {Object} [guard] Allows working with `_.reduce` without using its\n     *  `key` and `object` arguments as sources.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var object = { 'name': 'barney' };\n     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var defaults = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (typeof result[index] == 'undefined') result[index] = iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * This method is like `_.findIndex` except that it returns the key of the\n     * first element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': false },\n     *   'fred': {    'age': 40, 'blocked': true },\n     *   'pebbles': { 'age': 1,  'blocked': false }\n     * };\n     *\n     * _.findKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (property order is not guaranteed across environments)\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findKey(characters, { 'age': 1 });\n     * // => 'pebbles'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findKey(characters, 'blocked');\n     * // => 'fred'\n     */\n    function findKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwn(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': true },\n     *   'fred': {    'age': 40, 'blocked': false },\n     *   'pebbles': { 'age': 1,  'blocked': true }\n     * };\n     *\n     * _.findLastKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles`, assuming `_.findKey` returns `barney`\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastKey(characters, { 'age': 40 });\n     * // => 'fred'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastKey(characters, 'blocked');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwnRight(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object,\n     * executing the callback for each property. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, key, object). Callbacks may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forIn(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)\n     */\n    var forIn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        for (index in iterable) {\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forIn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forInRight(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'\n     */\n    function forInRight(object, callback, thisArg) {\n      var pairs = [];\n\n      forIn(object, function(value, key) {\n        pairs.push(key, value);\n      });\n\n      var length = pairs.length;\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(pairs[length--], pairs[length], object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Iterates over own enumerable properties of an object, executing the callback\n     * for each property. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, key, object). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n     */\n    var forOwn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'\n     */\n    function forOwnRight(object, callback, thisArg) {\n      var props = keys(object),\n          length = props.length;\n\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        var key = props[length];\n        if (callback(object[key], key, object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Creates a sorted array of property names of all enumerable properties,\n     * own and inherited, of `object` that have function values.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names that have function values.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]\n     */\n    function functions(object) {\n      var result = [];\n      forIn(object, function(value, key) {\n        if (isFunction(value)) {\n          result.push(key);\n        }\n      });\n      return result.sort();\n    }\n\n    /**\n     * Checks if the specified property name exists as a direct property of `object`,\n     * instead of an inherited property.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to check.\n     * @returns {boolean} Returns `true` if key is a direct property, else `false`.\n     * @example\n     *\n     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n     * // => true\n     */\n    function has(object, key) {\n      return object ? hasOwnProperty.call(object, key) : false;\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of the given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the created inverted object.\n     * @example\n     *\n     * _.invert({ 'first': 'fred', 'second': 'barney' });\n     * // => { 'fred': 'first', 'barney': 'second' }\n     */\n    function invert(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        result[object[key]] = key;\n      }\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a boolean value.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.\n     * @example\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        value && typeof value == 'object' && toString.call(value) == boolClass || false;\n    }\n\n    /**\n     * Checks if `value` is a date.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     */\n    function isDate(value) {\n      return value && typeof value == 'object' && toString.call(value) == dateClass || false;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     */\n    function isElement(value) {\n      return value && value.nodeType === 1 || false;\n    }\n\n    /**\n     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a\n     * length of `0` and objects with no own enumerable properties are considered\n     * \"empty\".\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({});\n     * // => true\n     *\n     * _.isEmpty('');\n     * // => true\n     */\n    function isEmpty(value) {\n      var result = true;\n      if (!value) {\n        return result;\n      }\n      var className = toString.call(value),\n          length = value.length;\n\n      if ((className == arrayClass || className == stringClass || className == argsClass ) ||\n          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {\n        return !length;\n      }\n      forOwn(value, function() {\n        return (result = false);\n      });\n      return result;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent to each other. If a callback is provided it will be executed\n     * to compare values. If the callback returns `undefined` comparisons will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (a, b).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var copy = { 'name': 'fred' };\n     *\n     * object == copy;\n     * // => false\n     *\n     * _.isEqual(object, copy);\n     * // => true\n     *\n     * var words = ['hello', 'goodbye'];\n     * var otherWords = ['hi', 'goodbye'];\n     *\n     * _.isEqual(words, otherWords, function(a, b) {\n     *   var reGreet = /^(?:hello|hi)$/i,\n     *       aGreet = _.isString(a) && reGreet.test(a),\n     *       bGreet = _.isString(b) && reGreet.test(b);\n     *\n     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;\n     * });\n     * // => true\n     */\n    function isEqual(a, b, callback, thisArg) {\n      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));\n    }\n\n    /**\n     * Checks if `value` is, or can be coerced to, a finite number.\n     *\n     * Note: This is not the same as native `isFinite` which will return true for\n     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.\n     * @example\n     *\n     * _.isFinite(-101);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => true\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite('');\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));\n    }\n\n    /**\n     * Checks if `value` is a function.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     */\n    function isFunction(value) {\n      return typeof value == 'function';\n    }\n\n    /**\n     * Checks if `value` is the language type of Object.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // check if the value is the ECMAScript language type of Object\n      // http://es5.github.io/#x8\n      // and avoid a V8 bug\n      // http://code.google.com/p/v8/issues/detail?id=2291\n      return !!(value && objectTypes[typeof value]);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * Note: This is not the same as native `isNaN` which will return `true` for\n     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // `NaN` as a primitive is the only value that is not equal to itself\n      // (perform the [[Class]] check first to avoid errors with some host objects in IE)\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(undefined);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is a number.\n     *\n     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4 * 5);\n     * // => true\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        value && typeof value == 'object' && toString.call(value) == numberClass || false;\n    }\n\n    /**\n     * Checks if `value` is an object created by the `Object` constructor.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * _.isPlainObject(new Shape);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     */\n    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n      if (!(value && toString.call(value) == objectClass)) {\n        return false;\n      }\n      var valueOf = value.valueOf,\n          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n      return objProto\n        ? (value == objProto || getPrototypeOf(value) == objProto)\n        : shimIsPlainObject(value);\n    };\n\n    /**\n     * Checks if `value` is a regular expression.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.\n     * @example\n     *\n     * _.isRegExp(/fred/);\n     * // => true\n     */\n    function isRegExp(value) {\n      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;\n    }\n\n    /**\n     * Checks if `value` is a string.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('fred');\n     * // => true\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        value && typeof value == 'object' && toString.call(value) == stringClass || false;\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     */\n    function isUndefined(value) {\n      return typeof value == 'undefined';\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new object with values of the results of each `callback` execution.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     *\n     * var characters = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.mapValues(characters, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 }\n     */\n    function mapValues(object, callback, thisArg) {\n      var result = {};\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      forOwn(object, function(value, key, object) {\n        result[key] = callback(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * will overwrite property assignments of previous sources. If a callback is\n     * provided it will be executed to produce the merged values of the destination\n     * and source properties. If the callback returns `undefined` merging will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var names = {\n     *   'characters': [\n     *     { 'name': 'barney' },\n     *     { 'name': 'fred' }\n     *   ]\n     * };\n     *\n     * var ages = {\n     *   'characters': [\n     *     { 'age': 36 },\n     *     { 'age': 40 }\n     *   ]\n     * };\n     *\n     * _.merge(names, ages);\n     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }\n     *\n     * var food = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var otherFood = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(food, otherFood, function(a, b) {\n     *   return _.isArray(a) ? a.concat(b) : undefined;\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }\n     */\n    function merge(object) {\n      var args = arguments,\n          length = 2;\n\n      if (!isObject(object)) {\n        return object;\n      }\n      // allows working with `_.reduce` and `_.reduceRight` without using\n      // their `index` and `collection` arguments\n      if (typeof args[2] != 'number') {\n        length = args.length;\n      }\n      if (length > 3 && typeof args[length - 2] == 'function') {\n        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);\n      } else if (length > 2 && typeof args[length - 1] == 'function') {\n        callback = args[--length];\n      }\n      var sources = slice(arguments, 1, length),\n          index = -1,\n          stackA = getArray(),\n          stackB = getArray();\n\n      while (++index < length) {\n        baseMerge(object, sources[index], callback, stackA, stackB);\n      }\n      releaseArray(stackA);\n      releaseArray(stackB);\n      return object;\n    }\n\n    /**\n     * Creates a shallow clone of `object` excluding the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` omitting the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The properties to omit or the\n     *  function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object without the omitted properties.\n     * @example\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');\n     * // => { 'name': 'fred' }\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {\n     *   return typeof value == 'number';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function omit(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var props = [];\n        forIn(object, function(value, key) {\n          props.push(key);\n        });\n        props = baseDifference(props, baseFlatten(arguments, true, false, 1));\n\n        var index = -1,\n            length = props.length;\n\n        while (++index < length) {\n          var key = props[index];\n          result[key] = object[key];\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (!callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates a two dimensional array of an object's key-value pairs,\n     * i.e. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)\n     */\n    function pairs(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a shallow clone of `object` composed of the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` picking the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The function called per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object composed of the picked properties.\n     * @example\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');\n     * // => { 'name': 'fred' }\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {\n     *   return key.charAt(0) != '_';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function pick(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var index = -1,\n            props = baseFlatten(arguments, true, false, 1),\n            length = isObject(object) ? props.length : 0;\n\n        while (++index < length) {\n          var key = props[index];\n          if (key in object) {\n            result[key] = object[key];\n          }\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * An alternative to `_.reduce` this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable properties through a callback, with each callback execution\n     * potentially mutating the `accumulator` object. The callback is bound to\n     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).\n     * Callbacks may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {\n     *   num *= num;\n     *   if (num % 2) {\n     *     return result.push(num) < 3;\n     *   }\n     * });\n     * // => [1, 9, 25]\n     *\n     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     * });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function transform(object, callback, accumulator, thisArg) {\n      var isArr = isArray(object);\n      if (accumulator == null) {\n        if (isArr) {\n          accumulator = [];\n        } else {\n          var ctor = object && object.constructor,\n              proto = ctor && ctor.prototype;\n\n          accumulator = baseCreate(proto);\n        }\n      }\n      if (callback) {\n        callback = lodash.createCallback(callback, thisArg, 4);\n        (isArr ? forEach : forOwn)(object, function(value, index, object) {\n          return callback(accumulator, value, index, object);\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * Creates an array composed of the own enumerable property values of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property values.\n     * @example\n     *\n     * _.values({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => [1, 2, 3] (property order is not guaranteed across environments)\n     */\n    function values(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements from the specified indexes, or keys, of the\n     * `collection`. Indexes may be specified as individual arguments or as arrays\n     * of indexes.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`\n     *   to retrieve, specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns a new array of elements corresponding to the\n     *  provided indexes.\n     * @example\n     *\n     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);\n     * // => ['a', 'c', 'e']\n     *\n     * _.at(['fred', 'barney', 'pebbles'], 0, 2);\n     * // => ['fred', 'pebbles']\n     */\n    function at(collection) {\n      var args = arguments,\n          index = -1,\n          props = baseFlatten(args, true, false, 1),\n          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,\n          result = Array(length);\n\n      while(++index < length) {\n        result[index] = collection[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * Checks if a given value is present in a collection using strict equality\n     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the\n     * offset from the end of the collection.\n     *\n     * @static\n     * @memberOf _\n     * @alias include\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {*} target The value to check for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.\n     * @example\n     *\n     * _.contains([1, 2, 3], 1);\n     * // => true\n     *\n     * _.contains([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.contains('pebbles', 'eb');\n     * // => true\n     */\n    function contains(collection, target, fromIndex) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = collection ? collection.length : 0,\n          result = false;\n\n      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;\n      if (isArray(collection)) {\n        result = indexOf(collection, target, fromIndex) > -1;\n      } else if (typeof length == 'number') {\n        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;\n      } else {\n        forOwn(collection, function(value) {\n          if (++index >= fromIndex) {\n            return !(result = value === target);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through the callback. The corresponding value\n     * of each key is the number of times the key was returned by the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);\n    });\n\n    /**\n     * Checks if the given callback returns truey value for **all** elements of\n     * a collection. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if all elements passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes']);\n     * // => false\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.every(characters, 'age');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.every(characters, { 'age': 36 });\n     * // => false\n     */\n    function every(collection, callback, thisArg) {\n      var result = true;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (!(result = !!callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return (result = !!callback(value, index, collection));\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning an array of all elements\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that passed the callback check.\n     * @example\n     *\n     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [2, 4, 6]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.filter(characters, 'blocked');\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.filter(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     */\n    function filter(collection, callback, thisArg) {\n      var result = [];\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning the first element that\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect, findWhere\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.find(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => { 'name': 'barney', 'age': 36, 'blocked': false }\n     *\n     * // using \"_.where\" callback shorthand\n     * _.find(characters, { 'age': 1 });\n     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.find(characters, 'blocked');\n     * // => { 'name': 'fred', 'age': 40, 'blocked': true }\n     */\n    function find(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            return value;\n          }\n        }\n      } else {\n        var result;\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result = value;\n            return false;\n          }\n        });\n        return result;\n      }\n    }\n\n    /**\n     * This method is like `_.find` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(num) {\n     *   return num % 2 == 1;\n     * });\n     * // => 3\n     */\n    function findLast(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forEachRight(collection, function(value, index, collection) {\n        if (callback(value, index, collection)) {\n          result = value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, executing the callback for each\n     * element. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * Note: As with other \"Collections\" methods, objects with a `length` property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');\n     * // => logs each number and returns '1,2,3'\n     *\n     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });\n     * // => logs each number and returns the object (property order is not guaranteed across environments)\n     */\n    function forEach(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (callback(collection[index], index, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, callback);\n      }\n      return collection;\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');\n     * // => logs each number from right to left and returns '3,2,1'\n     */\n    function forEachRight(collection, callback, thisArg) {\n      var length = collection ? collection.length : 0;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (length--) {\n          if (callback(collection[length], length, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        var props = keys(collection);\n        length = props.length;\n        forOwn(collection, function(value, key, collection) {\n          key = props ? props[--length] : --length;\n          return callback(collection[key], key, collection);\n        });\n      }\n      return collection;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of a collection through the callback. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of the collection through the given callback. The corresponding\n     * value of each key is the last element responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keys = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keys, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method named by `methodName` on each element in the `collection`\n     * returning an array of the results of each invoked method. Additional arguments\n     * will be provided to each invoked method. If `methodName` is a function it\n     * will be invoked for, and `this` bound to, each element in the `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|string} methodName The name of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [arg] Arguments to invoke the method with.\n     * @returns {Array} Returns a new array of the results of each invoked method.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    function invoke(collection, methodName) {\n      var args = slice(arguments, 2),\n          index = -1,\n          isFunc = typeof methodName == 'function',\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an array of values by running each element in the collection\n     * through the callback. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of the results of each `callback` execution.\n     * @example\n     *\n     * _.map([1, 2, 3], function(num) { return num * 3; });\n     * // => [3, 6, 9]\n     *\n     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });\n     * // => [3, 6, 9] (property order is not guaranteed across environments)\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        var result = Array(length);\n        while (++index < length) {\n          result[index] = callback(collection[index], index, collection);\n        }\n      } else {\n        result = [];\n        forOwn(collection, function(value, key, collection) {\n          result[++index] = callback(value, key, collection);\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the maximum value of a collection. If the collection is empty or\n     * falsey `-Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'fred', 'age': 40 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.max(characters, 'age');\n     * // => { 'name': 'fred', 'age': 40 };\n     */\n    function max(collection, callback, thisArg) {\n      var computed = -Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value > result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current > computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the minimum value of a collection. If the collection is empty or\n     * falsey `Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'barney', 'age': 36 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.min(characters, 'age');\n     * // => { 'name': 'barney', 'age': 36 };\n     */\n    function min(collection, callback, thisArg) {\n      var computed = Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value < result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current < computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the value of a specified property from all elements in the collection.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {string} property The name of the property to pluck.\n     * @returns {Array} Returns a new array of property values.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    var pluck = map;\n\n    /**\n     * Reduces a collection to a value which is the accumulated result of running\n     * each element in the collection through the callback, where each successive\n     * callback execution consumes the return value of the previous execution. If\n     * `accumulator` is not provided the first element of the collection will be\n     * used as the initial `accumulator` value. The callback is bound to `thisArg`\n     * and invoked with four arguments; (accumulator, value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var sum = _.reduce([1, 2, 3], function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function reduce(collection, callback, accumulator, thisArg) {\n      if (!collection) return accumulator;\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n\n      var index = -1,\n          length = collection.length;\n\n      if (typeof length == 'number') {\n        if (noaccum) {\n          accumulator = collection[++index];\n        }\n        while (++index < length) {\n          accumulator = callback(accumulator, collection[index], index, collection);\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          accumulator = noaccum\n            ? (noaccum = false, value)\n            : callback(accumulator, value, index, collection)\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var list = [[0, 1], [2, 3], [4, 5]];\n     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, callback, accumulator, thisArg) {\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n      forEachRight(collection, function(value, index, collection) {\n        accumulator = noaccum\n          ? (noaccum = false, value)\n          : callback(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The opposite of `_.filter` this method returns the elements of a\n     * collection that the callback does **not** return truey for.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that failed the callback check.\n     * @example\n     *\n     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [1, 3, 5]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.reject(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.reject(characters, { 'age': 36 });\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     */\n    function reject(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n      return filter(collection, function(value, index, collection) {\n        return !callback(value, index, collection);\n      });\n    }\n\n    /**\n     * Retrieves a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Allows working with functions like `_.map`\n     *  without using their `index` arguments as `n`.\n     * @returns {Array} Returns the random sample(s) of `collection`.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (collection && typeof collection.length != 'number') {\n        collection = values(collection);\n      }\n      if (n == null || guard) {\n        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(nativeMax(0, n), result.length);\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the Fisher-Yates\n     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns a new shuffled collection.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4, 5, 6]);\n     * // => [4, 1, 6, 3, 5, 2]\n     */\n    function shuffle(collection) {\n      var index = -1,\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        var rand = baseRandom(0, ++index);\n        result[index] = result[rand];\n        result[rand] = value;\n      });\n      return result;\n    }\n\n    /**\n     * Gets the size of the `collection` by returning `collection.length` for arrays\n     * and array-like objects or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns `collection.length` or number of own enumerable properties.\n     * @example\n     *\n     * _.size([1, 2]);\n     * // => 2\n     *\n     * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => 3\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? collection.length : 0;\n      return typeof length == 'number' ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if the callback returns a truey value for **any** element of a\n     * collection. The function returns as soon as it finds a passing value and\n     * does not iterate over the entire collection. The callback is bound to\n     * `thisArg` and invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if any element passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.some(characters, 'blocked');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.some(characters, { 'age': 1 });\n     * // => false\n     */\n    function some(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if ((result = callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return !(result = callback(value, index, collection));\n        });\n      }\n      return !!result;\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through the callback. This method\n     * performs a stable sort, that is, it will preserve the original sort order\n     * of equal elements. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an array of property names is provided for `callback` the collection\n     * will be sorted by each property value.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of sorted elements.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);\n     * // => [3, 1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'barney',  'age': 26 },\n     *   { 'name': 'fred',    'age': 30 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(_.sortBy(characters, 'age'), _.values);\n     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]\n     *\n     * // sorting by multiple properties\n     * _.map(_.sortBy(characters, ['name', 'age']), _.values);\n     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]\n     */\n    function sortBy(collection, callback, thisArg) {\n      var index = -1,\n          isArr = isArray(callback),\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      if (!isArr) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      forEach(collection, function(value, key, collection) {\n        var object = result[++index] = getObject();\n        if (isArr) {\n          object.criteria = map(callback, function(key) { return value[key]; });\n        } else {\n          (object.criteria = getArray())[0] = callback(value, key, collection);\n        }\n        object.index = index;\n        object.value = value;\n      });\n\n      length = result.length;\n      result.sort(compareAscending);\n      while (length--) {\n        var object = result[length];\n        result[length] = object.value;\n        if (!isArr) {\n          releaseArray(object.criteria);\n        }\n        releaseObject(object);\n      }\n      return result;\n    }\n\n    /**\n     * Converts the `collection` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to convert.\n     * @returns {Array} Returns the new converted array.\n     * @example\n     *\n     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n     * // => [2, 3, 4]\n     */\n    function toArray(collection) {\n      if (collection && typeof collection.length == 'number') {\n        return slice(collection);\n      }\n      return values(collection);\n    }\n\n    /**\n     * Performs a deep comparison of each element in a `collection` to the given\n     * `properties` object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Object} props The object of property values to filter by.\n     * @returns {Array} Returns a new array of elements that have the given properties.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.where(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]\n     *\n     * _.where(characters, { 'pets': ['dino'] });\n     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]\n     */\n    var where = filter;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are all falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all values of the provided arrays using strict\n     * equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);\n     * // => [1, 3, 4]\n     */\n    function difference(array) {\n      return baseDifference(array, baseFlatten(arguments, true, true, 1));\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.findIndex(characters, function(chr) {\n     *   return chr.age < 20;\n     * });\n     * // => 2\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findIndex(characters, 'blocked');\n     * // => 1\n     */\n    function findIndex(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        if (callback(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': true },\n     *   { 'name': 'fred',    'age': 40, 'blocked': false },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }\n     * ];\n     *\n     * _.findLastIndex(characters, function(chr) {\n     *   return chr.age > 30;\n     * });\n     * // => 1\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastIndex(characters, 'blocked');\n     * // => 2\n     */\n    function findLastIndex(array, callback, thisArg) {\n      var length = array ? array.length : 0;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(array[length], length, array)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Gets the first element or first `n` elements of an array. If a callback\n     * is provided elements at the beginning of the array are returned as long\n     * as the callback returns truey. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head, take\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the first element(s) of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.first([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.first(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function first(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = -1;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[0] : undefined;\n        }\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, n), length));\n    }\n\n    /**\n     * Flattens a nested array (the nesting can be to any depth). If `isShallow`\n     * is truey, the array will only be flattened a single level. If a callback\n     * is provided each element of the array is passed through the callback before\n     * flattening. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2], [3, [[4]]]]);\n     * // => [1, 2, 3, 4];\n     *\n     * _.flatten([1, [2], [3, [[4]]]], true);\n     * // => [1, 2, 3, [[4]]];\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.flatten(characters, 'pets');\n     * // => ['hoppy', 'baby puss', 'dino']\n     */\n    function flatten(array, isShallow, callback, thisArg) {\n      // juggle arguments\n      if (typeof isShallow != 'boolean' && isShallow != null) {\n        thisArg = callback;\n        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;\n        isShallow = false;\n      }\n      if (callback != null) {\n        array = map(array, callback, thisArg);\n      }\n      return baseFlatten(array, isShallow);\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found using\n     * strict equality for comparisons, i.e. `===`. If the array is already sorted\n     * providing `true` for `fromIndex` will run a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 1\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 4\n     *\n     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      if (typeof fromIndex == 'number') {\n        var length = array ? array.length : 0;\n        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);\n      } else if (fromIndex) {\n        var index = sortedIndex(array, value);\n        return array[index] === value ? index : -1;\n      }\n      return baseIndexOf(array, value, fromIndex);\n    }\n\n    /**\n     * Gets all but the last element or last `n` elements of an array. If a\n     * callback is provided elements at the end of the array are excluded from\n     * the result as long as the callback returns truey. The callback is bound\n     * to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.initial([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.initial([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [1]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.initial(characters, 'blocked');\n     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function initial(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : callback || n;\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));\n    }\n\n    /**\n     * Creates an array of unique values present in all provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of shared values.\n     * @example\n     *\n     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2]\n     */\n    function intersection() {\n      var args = [],\n          argsIndex = -1,\n          argsLength = arguments.length,\n          caches = getArray(),\n          indexOf = getIndexOf(),\n          trustIndexOf = indexOf === baseIndexOf,\n          seen = getArray();\n\n      while (++argsIndex < argsLength) {\n        var value = arguments[argsIndex];\n        if (isArray(value) || isArguments(value)) {\n          args.push(value);\n          caches.push(trustIndexOf && value.length >= largeArraySize &&\n            createCache(argsIndex ? args[argsIndex] : seen));\n        }\n      }\n      var array = args[0],\n          index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      outer:\n      while (++index < length) {\n        var cache = caches[0];\n        value = array[index];\n\n        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {\n          argsIndex = argsLength;\n          (cache || seen).push(value);\n          while (--argsIndex) {\n            cache = caches[argsIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n      }\n      while (argsLength--) {\n        cache = caches[argsLength];\n        if (cache) {\n          releaseObject(cache);\n        }\n      }\n      releaseArray(caches);\n      releaseArray(seen);\n      return result;\n    }\n\n    /**\n     * Gets the last element or last `n` elements of an array. If a callback is\n     * provided elements at the end of the array are returned as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the last element(s) of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     *\n     * _.last([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.last([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.last(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.last(characters, { 'employer': 'na' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function last(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[length - 1] : undefined;\n        }\n      }\n      return slice(array, nativeMax(0, length - n));\n    }\n\n    /**\n     * Gets the index at which the last occurrence of `value` is found using strict\n     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used\n     * as the offset from the end of the collection.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 4\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var index = array ? array.length : 0;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from the given array using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {...*} [value] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull(array) {\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = args.length,\n          length = array ? array.length : 0;\n\n      while (++argsIndex < argsLength) {\n        var index = -1,\n            value = args[argsIndex];\n        while (++index < length) {\n          if (array[index] === value) {\n            splice.call(array, index--, 1);\n            length--;\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to but not including `end`. If `start` is less than `stop` a\n     * zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns a new range array.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      start = +start || 0;\n      step = typeof step == 'number' ? step : (+step || 1);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      }\n      // use `Array(length)` so engines like Chakra and V8 avoid slower modes\n      // http://youtu.be/XAqIpGU8ZZk#t=17m25s\n      var index = -1,\n          length = nativeMax(0, ceil((end - start) / (step || 1))),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Removes all elements from an array that the callback returns truey for\n     * and returns an array of removed elements. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4, 5, 6];\n     * var evens = _.remove(array, function(num) { return num % 2 == 0; });\n     *\n     * console.log(array);\n     * // => [1, 3, 5]\n     *\n     * console.log(evens);\n     * // => [2, 4, 6]\n     */\n    function remove(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (callback(value, index, array)) {\n          result.push(value);\n          splice.call(array, index--, 1);\n          length--;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The opposite of `_.initial` this method gets all but the first element or\n     * first `n` elements of an array. If a callback function is provided elements\n     * at the beginning of the array are excluded from the result as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias drop, tail\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.rest([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.rest([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.rest(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.rest(characters, { 'employer': 'slate' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function rest(array, callback, thisArg) {\n      if (typeof callback != 'number' && callback != null) {\n        var n = 0,\n            index = -1,\n            length = array ? array.length : 0;\n\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);\n      }\n      return slice(array, n);\n    }\n\n    /**\n     * Uses a binary search to determine the smallest index at which a value\n     * should be inserted into a given sorted array in order to maintain the sort\n     * order of the array. If a callback is provided it will be executed for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([20, 30, 50], 40);\n     * // => 2\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 2\n     *\n     * var dict = {\n     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }\n     * };\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return dict.wordToNumber[word];\n     * });\n     * // => 2\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return this.wordToNumber[word];\n     * }, dict);\n     * // => 2\n     */\n    function sortedIndex(array, value, callback, thisArg) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      // explicitly reference `identity` for better inlining in Firefox\n      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;\n      value = callback(value);\n\n      while (low < high) {\n        var mid = (low + high) >>> 1;\n        (callback(array[mid]) < value)\n          ? low = mid + 1\n          : high = mid;\n      }\n      return low;\n    }\n\n    /**\n     * Creates an array of unique values, in order, of the provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of combined values.\n     * @example\n     *\n     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2, 3, 5, 4]\n     */\n    function union() {\n      return baseUniq(baseFlatten(arguments, true, true));\n    }\n\n    /**\n     * Creates a duplicate-value-free version of an array using strict equality\n     * for comparisons, i.e. `===`. If the array is sorted, providing\n     * `true` for `isSorted` will use a faster algorithm. If a callback is provided\n     * each element of `array` is passed through the callback before uniqueness\n     * is computed. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([1, 2, 1, 3, 1]);\n     * // => [1, 2, 3]\n     *\n     * _.uniq([1, 1, 2, 2, 3], true);\n     * // => [1, 2, 3]\n     *\n     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });\n     * // => ['A', 'b', 'C']\n     *\n     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);\n     * // => [1, 2.5, 3]\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, callback, thisArg) {\n      // juggle arguments\n      if (typeof isSorted != 'boolean' && isSorted != null) {\n        thisArg = callback;\n        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;\n        isSorted = false;\n      }\n      if (callback != null) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      return baseUniq(array, isSorted, callback);\n    }\n\n    /**\n     * Creates an array excluding all provided values using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to filter.\n     * @param {...*} [value] The values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n     * // => [2, 3, 4]\n     */\n    function without(array) {\n      return baseDifference(array, slice(arguments, 1));\n    }\n\n    /**\n     * Creates an array that is the symmetric difference of the provided arrays.\n     * See http://en.wikipedia.org/wiki/Symmetric_difference.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of values.\n     * @example\n     *\n     * _.xor([1, 2, 3], [5, 2, 1, 4]);\n     * // => [3, 5, 4]\n     *\n     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);\n     * // => [1, 4, 5]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArray(array) || isArguments(array)) {\n          var result = result\n            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))\n            : array;\n        }\n      }\n      return result || [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second\n     * elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @alias unzip\n     * @category Arrays\n     * @param {...Array} [array] Arrays to process.\n     * @returns {Array} Returns a new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    function zip() {\n      var array = arguments.length > 1 ? arguments : arguments[0],\n          index = -1,\n          length = array ? max(pluck(array, 'length')) : 0,\n          result = Array(length < 0 ? 0 : length);\n\n      while (++index < length) {\n        result[index] = pluck(array, index);\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed from arrays of `keys` and `values`. Provide\n     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`\n     * or two arrays, one of `keys` and one of corresponding `values`.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Arrays\n     * @param {Array} keys The array of keys.\n     * @param {Array} [values=[]] The array of values.\n     * @returns {Object} Returns an object composed of the given keys and\n     *  corresponding values.\n     * @example\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(keys, values) {\n      var index = -1,\n          length = keys ? keys.length : 0,\n          result = {};\n\n      if (!values && length && !isArray(keys[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = keys[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that executes `func`, with  the `this` binding and\n     * arguments of the created function, only after being called `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {number} n The number of times the function must be called before\n     *  `func` is executed.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('Done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'Done saving!', after all saves have completed\n     */\n    function after(n, func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with the `this`\n     * binding of `thisArg` and prepends any additional `bind` arguments to those\n     * provided to the bound function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var func = function(greeting) {\n     *   return greeting + ' ' + this.name;\n     * };\n     *\n     * func = _.bind(func, { 'name': 'fred' }, 'hi');\n     * func();\n     * // => 'hi fred'\n     */\n    function bind(func, thisArg) {\n      return arguments.length > 2\n        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)\n        : createWrapper(func, 1, null, null, thisArg);\n    }\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all the function properties\n     * of `object` will be bound.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...string} [methodName] The object method names to\n     *  bind, specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() { console.log('clicked ' + this.label); }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs', when the button is clicked\n     */\n    function bindAll(object) {\n      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),\n          index = -1,\n          length = funcs.length;\n\n      while (++index < length) {\n        var key = funcs[index];\n        object[key] = createWrapper(object[key], 1, null, null, object);\n      }\n      return object;\n    }\n\n    /**\n     * Creates a function that, when called, invokes the method at `object[key]`\n     * and prepends any additional `bindKey` arguments to those provided to the bound\n     * function. This method differs from `_.bind` by allowing bound functions to\n     * reference methods that will be redefined or don't yet exist.\n     * See http://michaux.ca/articles/lazy-function-definition-pattern.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'name': 'fred',\n     *   'greet': function(greeting) {\n     *     return greeting + ' ' + this.name;\n     *   }\n     * };\n     *\n     * var func = _.bindKey(object, 'greet', 'hi');\n     * func();\n     * // => 'hi fred'\n     *\n     * object.greet = function(greeting) {\n     *   return greeting + 'ya ' + this.name + '!';\n     * };\n     *\n     * func();\n     * // => 'hiya fred!'\n     */\n    function bindKey(object, key) {\n      return arguments.length > 2\n        ? createWrapper(key, 19, slice(arguments, 2), null, object)\n        : createWrapper(key, 3, null, null, object);\n    }\n\n    /**\n     * Creates a function that is the composition of the provided functions,\n     * where each function consumes the return value of the function that follows.\n     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {...Function} [func] Functions to compose.\n     * @returns {Function} Returns the new composed function.\n     * @example\n     *\n     * var realNameMap = {\n     *   'pebbles': 'penelope'\n     * };\n     *\n     * var format = function(name) {\n     *   name = realNameMap[name.toLowerCase()] || name;\n     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\n     * };\n     *\n     * var greet = function(formatted) {\n     *   return 'Hiya ' + formatted + '!';\n     * };\n     *\n     * var welcome = _.compose(greet, format);\n     * welcome('pebbles');\n     * // => 'Hiya Penelope!'\n     */\n    function compose() {\n      var funcs = arguments,\n          length = funcs.length;\n\n      while (length--) {\n        if (!isFunction(funcs[length])) {\n          throw new TypeError;\n        }\n      }\n      return function() {\n        var args = arguments,\n            length = funcs.length;\n\n        while (length--) {\n          args = [funcs[length].apply(this, args)];\n        }\n        return args[0];\n      };\n    }\n\n    /**\n     * Creates a function which accepts one or more arguments of `func` that when\n     * invoked either executes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` can be specified\n     * if `func.length` is not sufficient.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var curried = _.curry(function(a, b, c) {\n     *   console.log(a + b + c);\n     * });\n     *\n     * curried(1)(2)(3);\n     * // => 6\n     *\n     * curried(1, 2)(3);\n     * // => 6\n     *\n     * curried(1, 2, 3);\n     * // => 6\n     */\n    function curry(func, arity) {\n      arity = typeof arity == 'number' ? arity : (+arity || func.length);\n      return createWrapper(func, 4, null, null, null, arity);\n    }\n\n    /**\n     * Creates a function that will delay the execution of `func` until after\n     * `wait` milliseconds have elapsed since the last time it was invoked.\n     * Provide an options object to indicate that `func` should be invoked on\n     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls\n     * to the debounced function will return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to debounce.\n     * @param {number} wait The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * var lazyLayout = _.debounce(calculateLayout, 150);\n     * jQuery(window).on('resize', lazyLayout);\n     *\n     * // execute `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * });\n     *\n     * // ensure `batchLog` is executed once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * source.addEventListener('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }, false);\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      wait = nativeMax(0, wait) || 0;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      var delayed = function() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      };\n\n      var maxDelayed = function() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      };\n\n      return function() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Defers executing the `func` function until the current call stack has cleared.\n     * Additional arguments will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to defer.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) { console.log(text); }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    function defer(func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 1);\n      return setTimeout(function() { func.apply(undefined, args); }, 1);\n    }\n\n    /**\n     * Executes the `func` function after `wait` milliseconds. Additional arguments\n     * will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay execution.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) { console.log(text); }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    function delay(func, wait) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 2);\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it will be used to determine the cache key for storing the result\n     * based on the arguments provided to the memoized function. By default, the\n     * first argument provided to the memoized function is used as the cache key.\n     * The `func` is executed with the `this` binding of the memoized function.\n     * The result cache is exposed as the `cache` property on the memoized function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] A function used to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var fibonacci = _.memoize(function(n) {\n     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n     * });\n     *\n     * fibonacci(9)\n     * // => 34\n     *\n     * var data = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // modifying the result cache\n     * var get = _.memoize(function(name) { return data[name]; }, _.identity);\n     * get('pebbles');\n     * // => { 'name': 'pebbles', 'age': 1 }\n     *\n     * get.cache.pebbles.name = 'penelope';\n     * get('pebbles');\n     * // => { 'name': 'penelope', 'age': 1 }\n     */\n    function memoize(func, resolver) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var memoized = function() {\n        var cache = memoized.cache,\n            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];\n\n        return hasOwnProperty.call(cache, key)\n          ? cache[key]\n          : (cache[key] = func.apply(this, arguments));\n      }\n      memoized.cache = {};\n      return memoized;\n    }\n\n    /**\n     * Creates a function that is restricted to execute `func` once. Repeat calls to\n     * the function will return the value of the first call. The `func` is executed\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` executes `createApplication` once\n     */\n    function once(func) {\n      var ran,\n          result;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (ran) {\n          return result;\n        }\n        ran = true;\n        result = func.apply(this, arguments);\n\n        // clear the `func` variable so the function may be garbage collected\n        func = null;\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with any additional\n     * `partial` arguments prepended to those provided to the new function. This\n     * method is similar to `_.bind` except it does **not** alter the `this` binding.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) { return greeting + ' ' + name; };\n     * var hi = _.partial(greet, 'hi');\n     * hi('fred');\n     * // => 'hi fred'\n     */\n    function partial(func) {\n      return createWrapper(func, 16, slice(arguments, 1));\n    }\n\n    /**\n     * This method is like `_.partial` except that `partial` arguments are\n     * appended to those provided to the new function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var defaultsDeep = _.partialRight(_.merge, _.defaults);\n     *\n     * var options = {\n     *   'variable': 'data',\n     *   'imports': { 'jq': $ }\n     * };\n     *\n     * defaultsDeep(options, _.templateSettings);\n     *\n     * options.variable\n     * // => 'data'\n     *\n     * options.imports\n     * // => { '_': _, 'jq': $ }\n     */\n    function partialRight(func) {\n      return createWrapper(func, 32, null, slice(arguments, 1));\n    }\n\n    /**\n     * Creates a function that, when executed, will only call the `func` function\n     * at most once per every `wait` milliseconds. Provide an options object to\n     * indicate that `func` should be invoked on the leading and/or trailing edge\n     * of the `wait` timeout. Subsequent calls to the throttled function will\n     * return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to throttle.\n     * @param {number} wait The number of milliseconds to throttle executions to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * var throttled = _.throttle(updatePosition, 100);\n     * jQuery(window).on('scroll', throttled);\n     *\n     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? options.leading : leading;\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      debounceOptions.leading = leading;\n      debounceOptions.maxWait = wait;\n      debounceOptions.trailing = trailing;\n\n      return debounce(func, wait, debounceOptions);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Additional arguments provided to the function are appended\n     * to those provided to the wrapper function. The wrapper is executed with\n     * the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('Fred, Wilma, & Pebbles');\n     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return createWrapper(wrapper, 16, [value]);\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var getter = _.constant(object);\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Produces a callback bound to an optional `thisArg`. If `func` is a property\n     * name the created callback will return the property value for a given element.\n     * If `func` is an object the created callback will return `true` for elements\n     * that contain the equivalent object properties, otherwise it will return `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);\n     *   return !match ? func(callback, thisArg) : function(object) {\n     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(characters, 'age__gt38');\n     * // => [{ 'name': 'fred', 'age': 40 }]\n     */\n    function createCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (func == null || type == 'function') {\n        return baseCreateCallback(func, thisArg, argCount);\n      }\n      // handle \"_.pluck\" style callback shorthands\n      if (type != 'object') {\n        return property(func);\n      }\n      var props = keys(func),\n          key = props[0],\n          a = func[key];\n\n      // handle \"_.where\" style callback shorthands\n      if (props.length == 1 && a === a && !isObject(a)) {\n        // fast path the common case of providing an object with a single\n        // property containing a primitive value\n        return function(object) {\n          var b = object[key];\n          return a === b && (a !== 0 || (1 / a == 1 / b));\n        };\n      }\n      return function(object) {\n        var length = props.length,\n            result = false;\n\n        while (length--) {\n          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {\n            break;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Converts the characters `&`, `<`, `>`, `\"`, and `'` in `string` to their\n     * corresponding HTML entities.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('Fred, Wilma, & Pebbles');\n     * // => 'Fred, Wilma, &amp; Pebbles'\n     */\n    function escape(string) {\n      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Adds function properties of a source object to the destination object.\n     * If `object` is a function methods will be added to its prototype as well.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Function|Object} [object=lodash] object The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.\n     * @example\n     *\n     * function capitalize(string) {\n     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n     * }\n     *\n     * _.mixin({ 'capitalize': capitalize });\n     * _.capitalize('fred');\n     * // => 'Fred'\n     *\n     * _('fred').capitalize().value();\n     * // => 'Fred'\n     *\n     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });\n     * _('fred').capitalize();\n     * // => 'Fred'\n     */\n    function mixin(object, source, options) {\n      var chain = true,\n          methodNames = source && functions(source);\n\n      if (!source || (!options && !methodNames.length)) {\n        if (options == null) {\n          options = source;\n        }\n        ctor = lodashWrapper;\n        source = object;\n        object = lodash;\n        methodNames = functions(source);\n      }\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      var ctor = object,\n          isFunc = isFunction(ctor);\n\n      forEach(methodNames, function(methodName) {\n        var func = object[methodName] = source[methodName];\n        if (isFunc) {\n          ctor.prototype[methodName] = function() {\n            var chainAll = this.__chain__,\n                value = this.__wrapped__,\n                args = [value];\n\n            push.apply(args, arguments);\n            var result = func.apply(object, args);\n            if (chain || chainAll) {\n              if (value === result && isObject(result)) {\n                return this;\n              }\n              result = new ctor(result);\n              result.__chain__ = chainAll;\n            }\n            return result;\n          };\n        }\n      });\n    }\n\n    /**\n     * Reverts the '_' variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      context._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // no operation performed\n    }\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var stamp = _.now();\n     * _.defer(function() { console.log(_.now() - stamp); });\n     * // => logs the number of milliseconds it took for the deferred function to be called\n     */\n    var now = isNative(now = Date.now) && now || function() {\n      return new Date().getTime();\n    };\n\n    /**\n     * Converts the given value into an integer of the specified radix.\n     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the\n     * `value` is a hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * Note: This method avoids differences in native ES3 and ES5 `parseInt`\n     * implementations. See http://es5.github.io/#E.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} value The value to parse.\n     * @param {number} [radix] The radix used to interpret the value to parse.\n     * @returns {number} Returns the new integer value.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     */\n    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {\n      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`\n      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);\n    };\n\n    /**\n     * Creates a \"_.pluck\" style function, which returns the `key` value of a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} key The name of the property to retrieve.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'fred',   'age': 40 },\n     *   { 'name': 'barney', 'age': 36 }\n     * ];\n     *\n     * var getName = _.property('name');\n     *\n     * _.map(characters, getName);\n     * // => ['barney', 'fred']\n     *\n     * _.sortBy(characters, getName);\n     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]\n     */\n    function property(key) {\n      return function(object) {\n        return object[key];\n      };\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number will be\n     * returned. If `floating` is truey or either `min` or `max` are floats a\n     * floating-point number will be returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating=false] Specify returning a floating-point number.\n     * @returns {number} Returns a random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (typeof min == 'boolean' && noMax) {\n          floating = min;\n          min = 1;\n        }\n        else if (!noMax && typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /**\n     * Resolves the value of property `key` on `object`. If `key` is a function\n     * it will be invoked with the `this` binding of `object` and its result returned,\n     * else the property value is returned. If `object` is falsey then `undefined`\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to resolve.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = {\n     *   'cheese': 'crumpets',\n     *   'stuff': function() {\n     *     return 'nonsense';\n     *   }\n     * };\n     *\n     * _.result(object, 'cheese');\n     * // => 'crumpets'\n     *\n     * _.result(object, 'stuff');\n     * // => 'nonsense'\n     */\n    function result(object, key) {\n      if (object) {\n        var value = object[key];\n        return isFunction(value) ? object[key]() : value;\n      }\n    }\n\n    /**\n     * A micro-templating method that handles arbitrary delimiters, preserves\n     * whitespace, and correctly escapes quotes within interpolated code.\n     *\n     * Note: In the development build, `_.template` utilizes sourceURLs for easier\n     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n     *\n     * For more information on precompiling templates see:\n     * https://lodash.com/custom-builds\n     *\n     * For more information on Chrome extension sandboxes see:\n     * http://developer.chrome.com/stable/extensions/sandboxingEval.html\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} text The template text.\n     * @param {Object} data The data object used to populate the text.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as local variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [variable] The data object variable name.\n     * @returns {Function|string} Returns a compiled function when no `data` object\n     *  is given, else it returns the interpolated text.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= name %>');\n     * compiled({ 'name': 'fred' });\n     * // => 'hello fred'\n     *\n     * // using the \"escape\" delimiter to escape HTML in data property values\n     * _.template('<b><%- value %></b>', { 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to generate HTML\n     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the ES6 delimiter as an alternative to the default \"interpolate\" delimiter\n     * _.template('hello ${ name }', { 'name': 'pebbles' });\n     * // => 'hello pebbles'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * _.template('<% print(\"hello \" + name); %>!', { 'name': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using a custom template delimiters\n     * _.templateSettings = {\n     *   'interpolate': /{{([\\s\\S]+?)}}/g\n     * };\n     *\n     * _.template('hello {{ name }}!', { 'name': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using the `imports` option to import jQuery\n     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     *   var __t, __p = '', __e = _.escape;\n     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';\n     *   return __p;\n     * }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(text, data, options) {\n      // based on John Resig's `tmpl` implementation\n      // http://ejohn.org/blog/javascript-micro-templating/\n      // and Laura Doktorova's doT.js\n      // https://github.com/olado/doT\n      var settings = lodash.templateSettings;\n      text = String(text || '');\n\n      // avoid missing dependencies when `iteratorTemplate` is not defined\n      options = defaults({}, options, settings);\n\n      var imports = defaults({}, options.imports, settings.imports),\n          importsKeys = keys(imports),\n          importsValues = values(imports);\n\n      var isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // compile the regexp to match each delimiter\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // escape characters that cannot be included in string literals\n        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // replace delimiters with snippets\n        if (escapeValue) {\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // the JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // if `variable` is not specified, wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain\n      var variable = options.variable,\n          hasVariable = variable;\n\n      if (!hasVariable) {\n        variable = 'obj';\n        source = 'with (' + variable + ') {\\n' + source + '\\n}\\n';\n      }\n      // cleanup code by stripping empty strings\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // frame code as the function body\n      source = 'function(' + variable + ') {\\n' +\n        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\\n') +\n        \"var __t, __p = '', __e = _.escape\" +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      // Use a sourceURL for easier debugging.\n      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n      var sourceURL = '\\n/*\\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\\n*/';\n\n      try {\n        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);\n      } catch(e) {\n        e.source = source;\n        throw e;\n      }\n      if (data) {\n        return result(data);\n      }\n      // provide the compiled function's source by its `toString` method, in\n      // supported environments, or the `source` property as a convenience for\n      // inlining compiled templates during the build process\n      result.source = source;\n      return result;\n    }\n\n    /**\n     * Executes the callback `n` times, returning an array of the results\n     * of each callback execution. The callback is bound to `thisArg` and invoked\n     * with one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} n The number of times to execute the callback.\n     * @param {Function} callback The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns an array of the results of each `callback` execution.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) { mage.castSpell(n); });\n     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively\n     *\n     * _.times(3, function(n) { this.cast(n); }, mage);\n     * // => also calls `mage.castSpell(n)` three times\n     */\n    function times(n, callback, thisArg) {\n      n = (n = +n) > -1 ? n : 0;\n      var index = -1,\n          result = Array(n);\n\n      callback = baseCreateCallback(callback, thisArg, 1);\n      while (++index < n) {\n        result[index] = callback(index);\n      }\n      return result;\n    }\n\n    /**\n     * The inverse of `_.escape` this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their\n     * corresponding characters.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('Fred, Barney &amp; Pebbles');\n     * // => 'Fred, Barney & Pebbles'\n     */\n    function unescape(string) {\n      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return String(prefix == null ? '' : prefix) + id;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps the given value with explicit\n     * method chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(characters)\n     *     .sortBy('age')\n     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })\n     *     .first()\n     *     .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      value = new lodashWrapper(value);\n      value.__chain__ = true;\n      return value;\n    }\n\n    /**\n     * Invokes `interceptor` with the `value` as the first argument and then\n     * returns `value`. The purpose of this method is to \"tap into\" a method\n     * chain in order to perform operations on intermediate results within\n     * the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3, 4])\n     *  .tap(function(array) { array.pop(); })\n     *  .reverse()\n     *  .value();\n     * // => [3, 2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chaining\n     * @returns {*} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(characters).first();\n     * // => { 'name': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(characters).chain()\n     *   .first()\n     *   .pick('age')\n     *   .value();\n     * // => { 'age': 36 }\n     */\n    function wrapperChain() {\n      this.__chain__ = true;\n      return this;\n    }\n\n    /**\n     * Produces the `toString` result of the wrapped value.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chaining\n     * @returns {string} Returns the string result.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return String(this.__wrapped__);\n    }\n\n    /**\n     * Extracts the wrapped value.\n     *\n     * @name valueOf\n     * @memberOf _\n     * @alias value\n     * @category Chaining\n     * @returns {*} Returns the wrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).valueOf();\n     * // => [1, 2, 3]\n     */\n    function wrapperValueOf() {\n      return this.__wrapped__;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return wrapped values when chaining\n    lodash.after = after;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.chain = chain;\n    lodash.compact = compact;\n    lodash.compose = compose;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.createCallback = createCallback;\n    lodash.curry = curry;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.map = map;\n    lodash.mapValues = mapValues;\n    lodash.max = max;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.min = min;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.pull = pull;\n    lodash.range = range;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.shuffle = shuffle;\n    lodash.sortBy = sortBy;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.values = values;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n\n    // add aliases\n    lodash.collect = map;\n    lodash.drop = rest;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n    lodash.unzip = zip;\n\n    // add functions to `lodash.prototype`\n    mixin(lodash);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return unwrapped values when chaining\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.contains = contains;\n    lodash.escape = escape;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.indexOf = indexOf;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isNaN = isNaN;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isUndefined = isUndefined;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.mixin = mixin;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.result = result;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.template = template;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n\n    // add aliases\n    lodash.all = every;\n    lodash.any = some;\n    lodash.detect = find;\n    lodash.findWhere = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.include = contains;\n    lodash.inject = reduce;\n\n    mixin(function() {\n      var source = {}\n      forOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }(), false);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions capable of returning wrapped and unwrapped values when chaining\n    lodash.first = first;\n    lodash.last = last;\n    lodash.sample = sample;\n\n    // add aliases\n    lodash.take = first;\n    lodash.head = first;\n\n    forOwn(lodash, function(func, methodName) {\n      var callbackable = methodName !== 'sample';\n      if (!lodash.prototype[methodName]) {\n        lodash.prototype[methodName]= function(n, guard) {\n          var chainAll = this.__chain__,\n              result = func(this.__wrapped__, n, guard);\n\n          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))\n            ? result\n            : new lodashWrapper(result, chainAll);\n        };\n      }\n    });\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = '2.4.2';\n\n    // add \"Chaining\" functions to the wrapper\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.value = wrapperValueOf;\n    lodash.prototype.valueOf = wrapperValueOf;\n\n    // add `Array` functions that return unwrapped values\n    forEach(['join', 'pop', 'shift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        var chainAll = this.__chain__,\n            result = func.apply(this.__wrapped__, arguments);\n\n        return chainAll\n          ? new lodashWrapper(result, chainAll)\n          : result;\n      };\n    });\n\n    // add `Array` functions that return the existing wrapped value\n    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        func.apply(this.__wrapped__, arguments);\n        return this;\n      };\n    });\n\n    // add `Array` functions that return new wrapped values\n    forEach(['concat', 'slice', 'splice'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);\n      };\n    });\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // expose Lo-Dash\n  var _ = runInContext();\n\n  // some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lo-Dash to the global object even when an AMD loader is present in\n    // case Lo-Dash is loaded with a RequireJS shim config.\n    // See http://requirejs.org/docs/api.html#config-shim\n    root._ = _;\n\n    // define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module\n    define(function() {\n      return _;\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // in Narwhal or Rhino -require\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // in a browser or Rhino\n    root._ = _;\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/lib/query.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar util = require('util');\nvar _where = require('./filters/where');\nvar _limit = require('./filters/limit');\nvar _skip = require('./filters/skip');\nvar _select = require('./projections/select');\nvar _groupBy = require('./projections/groupBy');\nvar _sort = require('./sort');\n\n\n\n/**\n * Filter/aggregate/partition/map the tuples known as `classifier`\n * in `data` using `criteria` (a Waterline criteria object)\n * \n * @param  { Object[] }           data\n * @param  { Object }             criteria         [the Waterline criteria object- complete w/ `where`, `limit`, `sort, `skip`, and `joins`]\n * \n * @return { Integer | Object | Object[] }\n */\n\nmodule.exports = function query ( /* classifier|tuples, data|criteria [, criteria] */ ) {\n  \n  // Embed an `INDEX_IN_ORIG_DATA` for each tuple to remember its original index\n  // within `data`.  At the end, we'll lookup the `INDEX_IN_ORIG_DATA` for each tuple\n  // and expose it as part of our results.\n  var INDEX_IN_ORIG_DATA = '.(rigindex)';\n\n  var tuples, classifier, data, criteria;\n\n  // If no classifier is provided, and data was specified as an array\n  // instead of an object, infer tuples from the array\n  if (_.isArray(arguments[0]) && !arguments[2]) {\n    tuples = arguments[0];\n    criteria = arguments[1];\n  }\n  // If all three arguments were supplied:\n  // get tuples of type `classifier` (i.e. SELECT * FROM __________)\n  // and clone 'em.\n  else {\n    classifier = arguments[0];\n    data = arguments[1];\n    criteria = arguments[2];\n    tuples = data[classifier];\n  }\n\n  // Clone tuples to avoid dirtying things up\n  tuples = _.cloneDeep(tuples);\n\n  // Embed `INDEX_IN_ORIG_DATA` in each tuple\n  _.each(tuples, function(tuple, i) {\n    tuple[INDEX_IN_ORIG_DATA] = i;\n  });\n\n  // Ensure criteria object exists\n  criteria = criteria || {};\n\n  // Query and return result set using criteria\n  tuples = _where(tuples, criteria.where);\n  tuples = _sort(tuples, criteria.sort);\n  tuples = _skip(tuples, criteria.skip);\n  tuples = _limit(tuples, criteria.limit);\n  tuples = _select(tuples, criteria.select);\n  \n  // TODO:\n  // tuples = _groupBy(tuples, criteria.groupBy);\n\n  // Grab the INDEX_IN_ORIG_DATA from each matched tuple\n  // this is typically used to update the tuples in the external source data.\n  var originalIndices = _.pluck(tuples, INDEX_IN_ORIG_DATA);\n\n  // Remove INDEX_IN_ORIG_DATA from each tuple--\n  // it is no longer needed.\n  _.each(tuples, function(tuple) {\n    delete tuple[INDEX_IN_ORIG_DATA];\n  });\n\n  return {\n    results: tuples,\n    indices: originalIndices\n  };\n};\n\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/lib/filters/where.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar X_ISO_DATE = require('../X_ISO_DATE.constant');\n\n\n\n/**\n * Apply a(nother) `where` filter to `data`\n *\n * @param  { Object[] }  data\n * @param  { Object }    where\n * @return { Object[] }\n */\nmodule.exports = function (data, where) {\n  if( !data ) return data;\n  return _.filter(data, function(tuple) {\n    return matchSet(tuple, where);\n  });\n};\n\n\n\n\n\n\n//////////////////////////\n///\n/// private methods   ||\n///                   \\/\n///\n//////////////////////////\n\n\n// Match a model against each criterion in a criteria query\nfunction matchSet(model, criteria, parentKey) {\n\n  // Null or {} WHERE query always matches everything\n  if(!criteria || _.isEqual(criteria, {})) return true;\n\n  // By default, treat entries as AND\n  return _.all(criteria, function(criterion, key) {\n    return matchItem(model, key, criterion, parentKey);\n  });\n}\n\n\nfunction matchOr(model, disjuncts) {\n  var outcomes = [];\n  _.each(disjuncts, function(criteria) {\n    if(matchSet(model, criteria)) outcomes.push(true);\n  });\n\n  var outcome = outcomes.length > 0 ? true : false;\n  return outcome;\n}\n\nfunction matchAnd(model, conjuncts) {\n  var outcome = true;\n  _.each(conjuncts, function(criteria) {\n    if(!matchSet(model, criteria)) outcome = false;\n  });\n  return outcome;\n}\n\nfunction matchLike(model, criteria) {\n  for(var key in criteria) {\n    // Return false if no match is found\n    if (!checkLike(model[key], criteria[key])) return false;\n  }\n  return true;\n}\n\nfunction matchNot(model, criteria) {\n  return !matchSet(model, criteria);\n}\n\nfunction matchItem(model, key, criterion, parentKey) {\n\n  // Handle special attr query\n  if (parentKey) {\n\n    if (key === 'equals' || key === '=' || key === 'equal') {\n      return matchLiteral(model,parentKey,criterion, compare['=']);\n    }\n    else if (key === 'not' || key === '!') {\n\n      // Check for Not In\n      if(Array.isArray(criterion)) {\n\n        var match = false;\n        criterion.forEach(function(val) {\n          if(compare['='](model[parentKey], val)) {\n            match = true;\n          }\n        });\n\n        return match ? false : true;\n      }\n\n      return matchLiteral(model,parentKey,criterion, compare['!']);\n    }\n    else if (key === 'greaterThan' || key === '>') {\n      return matchLiteral(model,parentKey,criterion, compare['>']);\n    }\n    else if (key === 'greaterThanOrEqual' || key === '>=')  {\n      return matchLiteral(model,parentKey,criterion, compare['>=']);\n    }\n    else if (key === 'lessThan' || key === '<')  {\n      return matchLiteral(model,parentKey,criterion, compare['<']);\n    }\n    else if (key === 'lessThanOrEqual' || key === '<=')  {\n      return matchLiteral(model,parentKey,criterion, compare['<=']);\n    }\n    else if (key === 'startsWith') return matchLiteral(model,parentKey,criterion, checkStartsWith);\n    else if (key === 'endsWith') return matchLiteral(model,parentKey,criterion, checkEndsWith);\n    else if (key === 'contains') return matchLiteral(model,parentKey,criterion, checkContains);\n    else if (key === 'like') return matchLiteral(model,parentKey,criterion, checkLike);\n    else throw new Error ('Invalid query syntax!');\n  }\n  else if(key.toLowerCase() === 'or') {\n    return matchOr(model, criterion);\n  } else if(key.toLowerCase() === 'not') {\n    return matchNot(model, criterion);\n  } else if(key.toLowerCase() === 'and') {\n    return matchAnd(model, criterion);\n  } else if(key.toLowerCase() === 'like') {\n    return matchLike(model, criterion);\n  }\n  // IN query\n  else if(_.isArray(criterion)) {\n    return _.any(criterion, function(val) {\n      return compare['='](model[key], val);\n    });\n  }\n\n  // Special attr query\n  else if (_.isObject(criterion) && validSubAttrCriteria(criterion)) {\n    // Attribute is being checked in a specific way\n    return matchSet(model, criterion, key);\n  }\n\n  // Otherwise, try a literal match\n  else return matchLiteral(model,key,criterion, compare['=']);\n\n}\n\n// Comparison fns\nvar compare = {\n\n  // Equalish\n  '=' : function (a,b) {\n    var x = normalizeComparison(a,b);\n    return x[0] == x[1];\n  },\n\n  // Not equalish\n  '!' : function (a,b) {\n    var x = normalizeComparison(a,b);\n    return x[0] != x[1];\n  },\n  '>' : function (a,b) {\n    var x = normalizeComparison(a,b);\n    return x[0] > x[1];\n  },\n  '>=': function (a,b) {\n    var x = normalizeComparison(a,b);\n    return x[0] >= x[1];\n  },\n  '<' : function (a,b) {\n    var x = normalizeComparison(a,b);\n    return x[0] < x[1];\n  },\n  '<=': function (a,b) {\n    var x = normalizeComparison(a,b);\n    return x[0] <= x[1];\n  }\n};\n\n// Prepare two values for comparison\nfunction normalizeComparison(a,b) {\n\n  if(_.isUndefined(a) || a === null) a = '';\n  if(_.isUndefined(b) || b === null) b = '';\n\n  if (_.isString(a) && _.isString(b)) {\n    a = a.toLowerCase();\n    b = b.toLowerCase();\n  }\n\n  // If Comparing dates, keep them as dates\n  if(_.isDate(a) && _.isDate(b)) {\n    return [a.getTime(), b.getTime()];\n  }\n  // Otherwise convert them to ISO strings\n  if (_.isDate(a)) { a = a.toISOString(); }\n  if (_.isDate(b)) { b = b.toISOString(); }\n\n\n  // Stringify for comparisons- except for numbers, null, and undefined\n  if (!_.isNumber(a)) {\n    a = typeof a.toString !== 'undefined' ? a.toString() : '' + a;\n  }\n  if (!_.isNumber(b)) {\n    b = typeof b.toString !== 'undefined' ? b.toString() : '' + b;\n  }\n\n  // If comparing date-like things, treat them like dates\n  if (_.isString(a) && _.isString(b) && a.match(X_ISO_DATE) && b.match(X_ISO_DATE)) {\n    return ([new Date(a).getTime(), new Date(b).getTime()]);\n  }\n\n  return [a,b];\n}\n\n// Return whether this criteria is valid as an object inside of an attribute\nfunction validSubAttrCriteria(c) {\n\n  if(!_.isObject(c)) return false;\n\n  var valid = false;\n  var validAttributes = [\n    'equals', 'not', 'greaterThan', 'lessThan', 'greaterThanOrEqual', 'lessThanOrEqual',\n    '<', '<=', '!', '>', '>=', 'startsWith', 'endsWith', 'contains', 'like'];\n\n  _.each(validAttributes, function(attr) {\n    if(hasOwnProperty(c, attr)) valid = true;\n  });\n\n  return valid;\n}\n\n// Returns whether this value can be successfully parsed as a finite number\nfunction isNumbery (value) {\n  if(_.isDate(value)) return false;\n  return Math.pow(+value, 2) > 0;\n}\n\n// matchFn => the function that will be run to check for a match between the two literals\nfunction matchLiteral(model, key, criterion, matchFn) {\n\n  var val = _.cloneDeep(model[key]);\n\n  // If the criterion are both parsable finite numbers, cast them\n  if(isNumbery(criterion) && isNumbery(val)) {\n    criterion = +criterion;\n    val = +val;\n  }\n\n  // ensure the key attr exists in model\n  if(!model.hasOwnProperty(key)) return false;\n  if(_.isUndefined(criterion)) return false;\n\n  // ensure the key attr matches model attr in model\n  if((!matchFn(val,criterion))) {\n    return false;\n  }\n\n  // Otherwise this is a match\n  return true;\n}\n\n\nfunction checkStartsWith (value, matchString) {\n  // console.log('CheCKING startsWith ', value, 'against matchString:', matchString, 'result:',sqlLikeMatch(value, matchString));\n  return sqlLikeMatch(value, matchString + '%');\n}\nfunction checkEndsWith (value, matchString) {\n  return sqlLikeMatch(value, '%' + matchString);\n}\nfunction checkContains (value, matchString) {\n  return sqlLikeMatch(value, '%' + matchString + '%');\n}\nfunction checkLike (value, matchString) {\n  // console.log('CheCKING  ', value, 'against matchString:', matchString, 'result:',sqlLikeMatch(value, matchString));\n  return sqlLikeMatch(value, matchString);\n}\n\nfunction sqlLikeMatch (value,matchString) {\n\n  if(_.isRegExp(matchString)) {\n    // awesome\n  } else if(_.isString(matchString)) {\n    // Handle escaped percent (%) signs\n    matchString = matchString.replace(/%%%/g, '%');\n\n    // Escape regex\n    matchString = escapeRegExp(matchString);\n\n    // Replace SQL % match notation with something the ECMA regex parser can handle\n    matchString = matchString.replace(/([^%]*)%([^%]*)/g, '$1.*$2');\n\n    // Case insensitive by default\n    // TODO: make this overridable\n    var modifiers = 'i';\n\n    matchString = new RegExp('^' + matchString + '$', modifiers);\n  }\n  // Unexpected match string!\n  else {\n    console.error('matchString:');\n    console.error(matchString);\n    throw new Error('Unexpected match string: ' + matchString + ' Please use a regexp or string.');\n  }\n\n  // Deal with non-strings\n  if(_.isNumber(value)) value = '' + value;\n  else if(_.isBoolean(value)) value = value ? 'true' : 'false';\n  else if(!_.isString(value)) {\n    // Ignore objects, arrays, null, and undefined data for now\n    // (and maybe forever)\n    return false;\n  }\n\n  // Check that criterion attribute and is at least similar to the model's value for that attr\n  if(!value.match(matchString)) {\n    return false;\n  }\n  return true;\n}\n\nfunction escapeRegExp(str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\n\n\n\n/**\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n * @return {Boolean}\n * @api public\n */\n\nvar hop = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, prop) {\n  return hop.call(obj, prop);\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/lib/X_ISO_DATE.constant.js":"// See http://stackoverflow.com/a/3143231/486547\nmodule.exports = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/lib/filters/limit.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash')\n  , util = require('util');\n\n\n/**\n * Apply a `limit` modifier to `data` using `limit`.\n *\n * @param  { Object[] }  data\n * @param  { Integer }    limit\n * @return { Object[] }\n */\nmodule.exports = function (data, limit) {\n  if( limit === undefined || !data || limit === 0) return data;\n  return _.first(data, limit);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/lib/filters/skip.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash')\n  , util = require('util');\n\n\n/**\n * Apply a `skip` modifier to `data` using `numToSkip`.\n * \n * @param  { Object[] }  data\n * @param  { Integer }   numToSkip\n * @return { Object[] }\n */\nmodule.exports = function (data, numToSkip) {\n\n  if(!numToSkip || !data) return data;\n  \n  // Ignore the first `numToSkip` tuples\n  return _.rest(data, numToSkip);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/lib/projections/select.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar util = require('util');\n\n\n/**\n * Project `tuples` on `fields`.\n * \n * @param  { Object[] }  tuples    [i.e. filteredData]\n * @param  { String[]/Object{} }  fields    [i.e. schema]\n * @return { Object[] }\n */\nfunction select (tuples, fields) {\n\n  // Expand splat shortcut syntax\n  if (fields === '*') {\n    fields = { '*': true };\n  }\n\n  // If `fields` are not an Object or Array, don't modify the output.\n  if (typeof fields !== 'object') return tuples;\n\n  // If `fields` are specified as an Array, convert them to an Object.\n  if (_.isArray(fields)) {\n    fields = _.reduce(fields, function arrayToObj(memo, attrName) {\n      memo[attrName] = true;\n      return memo;\n    }, {});\n  }\n\n  // If the '*' key is specified, the projection algorithm is flipped:\n  // only keys which are explicitly set to `false` will be excluded--\n  // all other keys will be left alone (this lasts until the recursive step.)\n  var hasSplat = !!fields['*'];\n  var fieldsToExplicitlyOmit = _(fields).where(function _areExplicitlyFalse (v,k){ return v === false; }).keys();\n  delete fields['*'];\n\n\n  // Finally, select fields from tuples.\n  return _.map(tuples, function (tuple) {\n\n    // Select the requested attributes of the tuple\n    if (hasSplat) {\n      tuple = _.omit(tuple, function (value, attrName){\n        return _.contains(fieldsToExplicitlyOmit, attrName);\n      });\n    }\n    else {\n      tuple = _.pick(tuple, Object.keys(fields));\n    }\n\n\n    // || NOTE THAT THIS APPROACH WILL CHANGE IN AN UPCOMING RELEASE\n    // \\/ TO MATCH THE CONVENTIONS ESTABLISHED IN WL2.\n\n    // Take recursive step if necessary to support nested\n    // SELECT clauses (NOT nested modifiers- more like nested\n    // WHEREs)\n    // \n    // e.g.:\n    // like this:\n    //   -> { select: { pet: { collarSize: true } } }\n    //   \n    // not this:\n    //   -> { select: { pet: { select: { collarSize: true } } } }\n    //\n    _.each(fields, function (subselect, attrName) {\n\n      if (typeof subselect === 'object') {\n        if (_.isArray(tuple[attrName])) {\n          tuple[attrName] = select(tuple[attrName], subselect);\n        }\n        else if (_.isObject(tuple[attrName])) {\n          tuple[attrName] = select([tuple[attrName]], subselect)[0];\n        }\n      }\n    });\n\n    return tuple;\n  });\n}\n\nmodule.exports = select;\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/lib/projections/groupBy.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash')\n  , util = require('util');\n\n\n/**\n * Partition the tuples in `filteredData` into buckets via `groupByAttribute`.\n * Works with aggregations to allow for powerful reporting queries.\n * \n * @param  { Object[] }  filteredData\n * @param  { String }    groupByAttribute\n * @return { Object[] }\n */\nmodule.exports = function (filteredData, groupByAttribute) {\n  return filteredData;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline-criteria/lib/sort.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar util = require('util');\nvar X_ISO_DATE = require('./X_ISO_DATE.constant');\n\n\n\n/**\n * Sort the tuples in `data` using `comparator`.\n *\n * @param  { Object[] }  data\n * @param  { Object }    comparator\n * @param  { Function }    when\n * @return { Object[] }\n */\nmodule.exports = function(data, comparator, when) {\n  if (!comparator || !data) return data;\n\n  // Equivalent to a SQL \"WHEN\"\n  when = when||function rankSpecialCase (record, attrName) {\n\n    // null ranks lower than anything else\n    if ( typeof record[attrName]==='undefined' || record[attrName] === null ) {\n      return false;\n    }\n    else return true;\n  };\n\n  return sortData(_.cloneDeep(data), comparator, when);\n};\n\n\n\n//////////////////////////\n///\n/// private methods   ||\n///                   \\/\n///                   \n//////////////////////////\n\n\n\n\n\n\n/**\n * Sort `data` (tuples) using `sortVector` (comparator obj)\n *\n * Based on method described here:\n * http://stackoverflow.com/a/4760279/909625\n *\n * @param  { Object[] } data         [tuples]\n * @param  { Object }   sortVector [mongo-style comparator object]\n * @return { Object[] }\n */\n\nfunction sortData(data, sortVector, when) {\n\n  // Constants\n  var GREATER_THAN = 1;\n  var LESS_THAN = -1;\n  var EQUAL = 0;\n  \n  return data.sort(function comparator(a, b) {\n    return _(sortVector).reduce(function (flagSoFar, sortDirection, attrName){\n\n\n      var outcome;\n\n      // Handle special cases (defined by WHEN):\n      var $a = when(a, attrName);\n      var $b = when(b, attrName);\n      if (!$a && !$b) outcome = EQUAL;\n      else if (!$a && $b) outcome = LESS_THAN;\n      else if ($a && !$b) outcome = GREATER_THAN;\n\n      // General case:\n      else {\n        // Coerce types\n        $a = a[attrName];\n        $b = b[attrName];\n        if ( $a < $b ) outcome = LESS_THAN;\n        else if ( $a > $b ) outcome = GREATER_THAN;\n        else outcome = EQUAL;\n      }\n\n      // Less-Than case (-1)\n      // (leaves flagSoFar untouched if it has been set, otherwise sets it)\n      if ( outcome === LESS_THAN ) {\n        return flagSoFar || -sortDirection;\n      }\n      // Greater-Than case (1)\n      // (leaves flagSoFar untouched if it has been set, otherwise sets it)\n      else if ( outcome === GREATER_THAN ) {\n        return flagSoFar || sortDirection;\n      }\n      // Equals case (0)\n      // (always leaves flagSoFar untouched)\n      else return flagSoFar;\n\n    }, 0);\n  });\n}\n\n\n\n\n\n\n/**\n * Coerce a value to its probable intended type for sorting.\n * \n * @param  {???} x\n * @return {???}\n */\nfunction coerceIntoBestGuessType (x) {\n  switch ( guessType(x) ) {\n    case 'booleanish': return (x==='true')?true:false;\n    case 'numberish': return +x;\n    case 'dateish': return new Date(x);\n    default: return x;\n  }\n}\n\n\nfunction guessType (x) {\n\n  if (!_.isString(x)) {\n    return typeof x;\n  }\n\n  // Probably meant to be a boolean\n  else if (x === 'true' || x === 'false') {\n    return 'booleanish';\n  }\n\n  // Probably meant to be a number\n  else if (+x === x) {\n    return 'numberish';\n  }\n\n  // Probably meant to be a date\n  else if (x.match(X_ISO_DATE)) {\n    return 'dateish';\n  }\n\n  // Just another string\n  else return typeof x;\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/finders/helpers.js":"/**\n * Finder Helper Queries\n *\n * (these call other collection-level methods)\n */\n\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\n\nmodule.exports = {\n\n  // Return models where ALL of the specified attributes match queryString\n\n  findOneLike: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.findOneLike([criteria],[options],callback)';\n\n    // Normalize criteria\n    criteria = normalize.likeCriteria(criteria, this._schema.schema);\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.findOne(criteria, options, cb);\n  },\n\n  findLike: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.findLike([criteria],[options],callback)';\n\n    // Normalize criteria\n    criteria = normalize.likeCriteria(criteria, this._schema.schema);\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.find(criteria, options, cb);\n  },\n\n  // Return models where >= 1 of the specified attributes start with queryString\n  startsWith: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.startsWith([criteria],[options],callback)';\n\n    criteria = normalize.likeCriteria(criteria, this._schema.schema, function applyStartsWith(criteria) {\n      return criteria + '%';\n    });\n\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.find(criteria, options, cb);\n  },\n\n  // Return models where >= 1 of the specified attributes end with queryString\n  endsWith: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.startsWith([criteria],[options],callback)';\n\n    criteria = normalize.likeCriteria(criteria, this._schema.schema, function applyEndsWith(criteria) {\n      return '%' + criteria;\n    });\n\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.find(criteria, options, cb);\n  },\n\n  // Return models where >= 1 of the specified attributes contain queryString\n  contains: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.startsWith([criteria],[options],callback)';\n\n    criteria = normalize.likeCriteria(criteria, this._schema.schema, function applyContains(criteria) {\n      return '%' + criteria + '%';\n    });\n\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.find(criteria, options, cb);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/finders/dynamicFinders.js":"/**\n * Dynamic Queries\n *\n * Query the collection using the name of the attribute directly\n */\n\nvar _ = require('lodash');\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\nvar finder = module.exports = {};\n\n/**\n * buildDynamicFinders\n *\n * Attaches shorthand dynamic methods to the prototype for each attribute\n * in the schema.\n */\n\nfinder.buildDynamicFinders = function() {\n  var self = this;\n\n  // For each defined attribute, create a dynamic finder function\n  Object.keys(this._attributes).forEach(function(attrName) {\n\n    // Check if attribute is an association, if so generate limited dynamic finders\n    if (hasOwnProperty(self._schema.schema[attrName], 'foreignKey')) {\n      if (self.associationFinders !== false) {\n        self.generateAssociationFinders(attrName);\n      }\n      return;\n    }\n\n    var capitalizedMethods = ['findOneBy*', 'findOneBy*In', 'findOneBy*Like', 'findBy*', 'findBy*In',\n      'findBy*Like', 'countBy*', 'countBy*In', 'countBy*Like'];\n\n    var lowercasedMethods = ['*StartsWith', '*Contains', '*EndsWith'];\n\n\n    if (self.dynamicFinders !== false) {\n      capitalizedMethods.forEach(function(method) {\n        self.generateDynamicFinder(attrName, method);\n      });\n      lowercasedMethods.forEach(function(method) {\n        self.generateDynamicFinder(attrName, method, true);\n      });\n    }\n  });\n};\n\n\n/**\n * generateDynamicFinder\n *\n * Creates a dynamic method based off the schema. Used for shortcuts for various\n * methods where a criteria object can automatically be built.\n *\n * @param {String} attrName\n * @param {String} method\n * @param {Boolean} dont capitalize the attrName or do, defaults to false\n */\n\nfinder.generateDynamicFinder = function(attrName, method, dontCapitalize) {\n  var self = this;\n  var criteria;\n\n  // Capitalize Attribute Name for camelCase\n  var preparedAttrName = dontCapitalize ? attrName : utils.capitalize(attrName);\n\n  // Figure out actual dynamic method name by injecting attribute name\n  var actualMethodName = method.replace(/\\*/g, preparedAttrName);\n\n  // Assign this finder to the collection\n  this[actualMethodName] = function dynamicMethod(value, options, cb) {\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    options = options || {};\n\n    var usage = utils.capitalize(self.identity) + '.' + actualMethodName + '(someValue,[options],callback)';\n\n    if (typeof value === 'undefined') return usageError('No value specified!', usage, cb);\n    if (options.where) return usageError('Cannot specify `where` option in a dynamic ' + method + '*() query!', usage, cb);\n\n    // Build criteria query and submit it\n    options.where = {};\n    options.where[attrName] = value;\n\n    switch (method) {\n\n\n      ///////////////////////////////////////\n      // Finders\n      ///////////////////////////////////////\n\n\n      case 'findOneBy*':\n      case 'findOneBy*In':\n        return self.findOne(options, cb);\n\n      case 'findOneBy*Like':\n        criteria = _.extend(options, {\n          where: {\n            like: options.where\n          }\n        });\n\n        return self.findOne(criteria, cb);\n\n\n      ///////////////////////////////////////\n      // Aggregate Finders\n      ///////////////////////////////////////\n\n\n      case 'findBy*':\n      case 'findBy*In':\n        return self.find(options, cb);\n\n      case 'findBy*Like':\n        criteria = _.extend(options, {\n          where: {\n            like: options.where\n          }\n        });\n\n        return self.find(criteria, cb);\n\n\n      ///////////////////////////////////////\n      // Count Finders\n      ///////////////////////////////////////\n\n\n      case 'countBy*':\n      case 'countBy*In':\n        return self.count(options, cb);\n\n      case 'countBy*Like':\n        criteria = _.extend(options, {\n          where: {\n            like: options.where\n          }\n        });\n\n        return self.count(criteria, cb);\n\n\n      ///////////////////////////////////////\n      // Searchers\n      ///////////////////////////////////////\n\n      case '*StartsWith':\n        return self.startsWith(options, cb);\n\n      case '*Contains':\n        return self.contains(options, cb);\n\n      case '*EndsWith':\n        return self.endsWith(options, cb);\n    }\n  };\n};\n\n\n/**\n * generateAssociationFinders\n *\n * Generate Dynamic Finders for an association.\n * Adds a .findBy<name>() method for has_one and belongs_to associations.\n *\n * @param {String} attrName, the column name of the attribute\n */\n\nfinder.generateAssociationFinders = function(attrName) {\n  var self = this;\n  var name, model;\n\n  // Find the user defined key for this attrName, look in self defined columnName\n  // properties and if that's not set see if the generated columnName matches the attrName\n  for (var key in this._attributes) {\n\n    // Cache the value\n    var cache = this._attributes[key];\n\n    if (!hasOwnProperty(cache, 'model')) continue;\n\n    if (cache.model.toLowerCase() + '_id' === attrName) {\n      name = key;\n      model = cache.model;\n    }\n  }\n\n  if (!name || !model) return;\n\n  // Build a findOneBy<attrName> dynamic finder that forces a join on the association\n  this['findOneBy' + utils.capitalize(name)] = function dynamicAssociationMethod(value, cb) {\n\n    // Check proper usage\n    var usage = utils.capitalize(self.identity) + '.' + 'findBy' + utils.capitalize(name) +\n      '(someValue, callback)';\n\n    if (typeof value === 'undefined') return usageError('No value specified!', usage, cb);\n    if (typeof value === 'function') return usageError('No value specified!', usage, cb);\n\n    var criteria = associationQueryCriteria(self, value, attrName);\n    return this.findOne(criteria, cb);\n  };\n\n  // Build a findBy<attrName> dynamic finder that forces a join on the association\n  this['findBy' + utils.capitalize(name)] = function dynamicAssociationMethod(value, cb) {\n\n    // Check proper usage\n    var usage = utils.capitalize(self.identity) + '.' + 'findBy' + utils.capitalize(name) +\n      '(someValue, callback)';\n\n    if (typeof value === 'undefined') return usageError('No value specified!', usage, cb);\n    if (typeof value === 'function') return usageError('No value specified!', usage, cb);\n\n    var criteria = associationQueryCriteria(self, value, attrName);\n    return this.find(criteria, cb);\n  };\n};\n\n\n/**\n * Build Join Array\n */\n\nfunction buildJoin() {\n  var self = this;\n  var pk, attr;\n\n  // Set the attr value to the generated schema attribute\n  attr = self.waterline.schema[self.identity].attributes[name];\n\n  // Get the current collection's primary key attribute\n  Object.keys(self._attributes).forEach(function(key) {\n    if (hasOwnProperty(self._attributes[key], 'primaryKey') && self._attributes[key].primaryKey) {\n      pk = key;\n    }\n  });\n\n  if (!attr) throw new Error('Attempting to populate an attribute that doesn\\'t exist');\n\n  // Grab the key being populated to check if it is a has many to belongs to\n  // If it's a belongs_to the adapter needs to know that it should replace the foreign key\n  // with the associated value.\n  var parentKey = self.waterline.collections[self.identity].attributes[name];\n\n\n  // Build the initial join object that will link this collection to either another collection\n  // or to a junction table.\n  var join = {\n    parent: self._tableName,\n    parentKey: attr.columnName || pk,\n    child: attr.references,\n    childKey: attr.on,\n    select: true,\n    removeParentKey: !!parentKey.model\n  };\n\n  return join;\n}\n\n/**\n * Query Criteria Builder for associations\n */\n\nfunction associationQueryCriteria(context, value, attrName) {\n\n  // Build a criteria object\n  var criteria = {\n    where: {},\n    joins: []\n  };\n\n  // Build a join condition\n  var join = buildJoin.call(context);\n  criteria.joins.push(join);\n\n  // Add where values\n  criteria.where[attrName] = value;\n  return criteria;\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/query/stream.js":"/**\n * Streaming Queries\n */\n\nvar usageError = require('../utils/usageError');\nvar utils = require('../utils/helpers');\nvar normalize = require('../utils/normalize');\nvar ModelStream = require('../utils/stream');\n\nmodule.exports = {\n\n  /**\n   * Stream a Result Set\n   *\n   * @param {Object} criteria\n   * @param {Object} transformation, defaults to JSON\n   */\n\n  stream: function(criteria, transformation) {\n    var self = this;\n\n    var usage = utils.capitalize(this.identity) + '.stream([criteria],[options])';\n\n    // Normalize criteria and fold in options\n    criteria = normalize.criteria(criteria);\n\n    // Transform Search Criteria\n    criteria = self._transformer.serialize(criteria);\n\n    // Configure stream to adapter, kick off fetch, and return stream object\n    // so that user code can use it as it fires data events\n    var stream = new ModelStream(transformation);\n\n    // very important to wait until next tick before triggering adapter\n    // otherwise write() and end() won't fire properly\n    process.nextTick(function() {\n\n      // Write once immediately to force prefix in case no models are returned\n      stream.write();\n\n      // Trigger Adapter Method\n      self.adapter.stream(criteria, stream);\n    });\n\n    return stream;\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/stream.js":"/**\n * Streams\n *\n * A Streaming API with support for Transformations\n */\n\nvar util = require('util');\nvar Stream = require('stream');\nvar Transformations = require('./transformations');\nvar _ = require('lodash');\n\nvar ModelStream = module.exports = function(transformation) {\n\n  // Use specified, or otherwise default, JSON transformation\n  this.transformation = transformation || Transformations.json;\n\n  // Reset write index\n  this.index = 0;\n\n  // Make stream writable\n  this.writable = true;\n};\n\nutil.inherits(ModelStream, Stream);\n\n/**\n * Write to stream\n *\n * Extracts args to write and emits them as data events\n *\n * @param {Object} model\n * @param {Function} cb\n */\n\nModelStream.prototype.write = function(model, cb) {\n  var self = this;\n\n  // Run transformation on this item\n  this.transformation.write(model, this.index, function writeToStream(err, transformedModel) {\n\n    // Increment index for next time\n    self.index++;\n\n    // Write transformed model to stream\n    self.emit('data', _.clone(transformedModel));\n\n    // Inform that we're finished\n    if (cb) return cb(err);\n  });\n\n};\n\n/**\n * End Stream\n */\n\nModelStream.prototype.end = function(err, cb) {\n  var self = this;\n\n  if (err) {\n    this.emit('error', err.message);\n    if (cb) return cb(err);\n    return;\n  }\n\n  this.transformation.end(function(err, suffix) {\n\n    if (err) {\n      self.emit('error', err);\n      if (cb) return cb(err);\n      return;\n    }\n\n    // Emit suffix if specified\n    if (suffix) self.emit('data', suffix);\n    self.emit('end');\n    if (cb) return cb();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/node_modules/waterline/lib/waterline/utils/transformations.js":"/**\n * Transformations\n */\n\nvar Transformations = module.exports = {};\n\n// Add JSON Transformation methods\nTransformations.json = {};\n\n/**\n * Write Method Transformations\n *\n * Used to stream back valid JSON from Waterline\n */\n\nTransformations.json.write = function(model, index, cb) {\n  var transformedModel;\n\n  if (!model) transformedModel = '';\n\n  // Transform to JSON\n  if (model) {\n    try {\n      transformedModel = JSON.stringify(model);\n    } catch (e) {\n      return cb(e);\n    }\n  }\n\n  // Prefix with opening [\n  if (index === 0) { transformedModel = '['; }\n\n  // Prefix with comma after first model\n  if (index > 1) transformedModel = ',' + transformedModel;\n\n  cb(null, transformedModel);\n};\n\n/**\n * Close off JSON Array\n */\nTransformations.json.end = function(cb) {\n  var suffix = ']';\n  cb(null, suffix);\n};\n"}