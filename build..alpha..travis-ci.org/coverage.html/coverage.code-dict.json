{"/home/travis/build/npmtest/node-npmtest-waterline/test.js":"/* istanbul instrument in package npmtest_waterline */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-waterline/lib.npmtest_waterline.js":"/* istanbul instrument in package npmtest_waterline */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_waterline = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_waterline = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-waterline/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-waterline && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_waterline */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_waterline\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_waterline.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_waterline.rollup.js'] =\n            local.assetsDict['/assets.npmtest_waterline.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_waterline.__dirname +\n                    '/lib.npmtest_waterline.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline.js":"var _ = require('lodash');\nvar async = require('async');\nvar Schema = require('waterline-schema');\nvar Connections = require('./waterline/connections');\nvar CollectionLoader = require('./waterline/collection/loader');\nvar COLLECTION_DEFAULTS = require('./waterline/collection/defaults');\nvar hasOwnProperty = require('./waterline/utils/helpers').object.hasOwnProperty;\n\n/**\n * Waterline\n */\n\nvar Waterline = module.exports = function() {\n\n  if (!(this instanceof Waterline)) {\n    return new Waterline();\n  }\n\n  // Keep track of all the collections internally so we can build associations\n  // between them when needed.\n  this._collections = [];\n\n  // Keep track of all the active connections used by collections\n  this._connections = {};\n\n  return this;\n};\n\n/*\n ***********************************************************\n * Modules that can be extended\n ***********************************************************/\n\n// Collection to be extended in your application\nWaterline.Collection = require('./waterline/collection');\n\n// Model Instance, returned as query results\nWaterline.Model = require('./waterline/model');\n\n/*\n ***********************************************************\n * Prototype Methods\n ***********************************************************/\n\n/**\n * loadCollection\n *\n * Loads a new Collection. It should be an extended Waterline.Collection\n * that contains your attributes, instance methods and class methods.\n *\n * @param {Object} collection\n * @return {Object} internal models dictionary\n * @api public\n */\n\nWaterline.prototype.loadCollection = function(collection) {\n\n  // Cache collection\n  this._collections.push(collection);\n\n  return this._collections;\n};\n\n/**\n * initialize\n *\n * Creates an initialized version of each Collection and auto-migrates depending on\n * the Collection configuration.\n *\n * @param {Object} config object containing adapters\n * @param {Function} callback\n * @return {Array} instantiated collections\n * @api public\n */\n\nWaterline.prototype.initialize = function(options, cb) {\n  var self = this;\n\n  // Ensure a config object is passed in containing adapters\n  if (!options) { throw new Error('Usage Error: function(options, callback)'); }\n  if (!options.adapters) { throw new Error('Options object must contain an adapters object'); }\n  if (!options.connections) { throw new Error('Options object must contain a connections object'); }\n\n  // Check that the given adapter is compatible with Waterline 0.11.x.\n  try {\n    _.each(options.adapters, function(adapter) {\n      // Adapters meant for Waterline >= 0.12 will have an adapterApiVersion property, so if we\n      // see that then we know the adapter won't work with this version of Waterline.\n      if (!_.isUndefined(adapter.adapterApiVersion)) {\n        throw new Error(\n          '\\n-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-\\n'+\n          'Cannot initialize Waterline.\\n'+\n          'The installed version of adapter `' + adapter.identity + '` is too new!\\n' +\n          'Please try installing a version < 1.0.\\n' +\n          '-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-\\n');\n      }\n    });\n  } catch (e) {\n    return cb(e);\n  }\n\n  // Allow collections to be passed in to the initialize method\n  if (options.collections) {\n    for (var collection in options.collections) {\n      this.loadCollection(_.cloneDeep(options.collections[collection]));\n    }\n\n    // Remove collections from the options after they have been loaded\n    delete options.collections;\n  }\n\n  // Cache a reference to instantiated collections\n  this.collections = {};\n\n  // Build up all the connections used by the collections\n  this.connections = new Connections(options.adapters, options.connections);\n\n  // Grab config defaults or set them to empty\n  var defaults = _.merge({}, COLLECTION_DEFAULTS, options.defaults);\n\n  // Build a schema map\n  this.schema = new Schema(this._collections, this.connections, defaults);\n\n  // Load a Collection into memory\n  function loadCollection(item, next) {\n    var loader = new CollectionLoader(item, self.connections, defaults);\n    var collection = loader.initialize(self);\n\n    // Store the instantiated collection so it can be used\n    // internally to create other records\n    self.collections[collection.identity.toLowerCase()] = collection;\n\n    next();\n  }\n\n  async.auto({\n\n    // Load all the collections into memory\n    loadCollections: function(next) {\n      async.each(self._collections, loadCollection, function(err) {\n        if (err) return next(err);\n\n        // Migrate Junction Tables\n        var junctionTables = [];\n\n        Object.keys(self.schema).forEach(function(table) {\n          if (!self.schema[table].junctionTable) return;\n          junctionTables.push(Waterline.Collection.extend(self.schema[table]));\n        });\n\n        async.each(junctionTables, loadCollection, function(err) {\n          if (err) return next(err);\n          next(null, self.collections);\n        });\n      });\n    },\n\n    // Build up Collection Schemas\n    buildCollectionSchemas: ['loadCollections', function(next, results) {\n      var collections = self.collections;\n      var schemas = {};\n\n      Object.keys(collections).forEach(function(key) {\n        var collection = collections[key];\n\n        // Remove hasMany association keys\n        var schema = _.clone(collection._schema.schema);\n\n        Object.keys(schema).forEach(function(key) {\n          if (hasOwnProperty(schema[key], 'type')) return;\n          delete schema[key];\n        });\n\n        // Grab JunctionTable flag\n        var meta = collection.meta || {};\n        meta.junctionTable = hasOwnProperty(collection.waterline.schema[collection.identity], 'junctionTable') ?\n          collection.waterline.schema[collection.identity].junctionTable : false;\n\n        schemas[collection.identity] = collection;\n        schemas[collection.identity].definition = schema;\n        schemas[collection.identity].meta = meta;\n      });\n\n      next(null, schemas);\n    }],\n\n    // Register the Connections with an adapter\n    registerConnections: ['buildCollectionSchemas', function(next, results) {\n      async.each(Object.keys(self.connections), function(item, nextItem) {\n        var connection = self.connections[item];\n        var config = {};\n        var usedSchemas = {};\n\n        // Check if the connection's adapter has a register connection method\n        if (!hasOwnProperty(connection._adapter, 'registerConnection')) return nextItem();\n\n        // Copy all values over to a tempory object minus the adapter definition\n        Object.keys(connection.config).forEach(function(key) {\n          config[key] = connection.config[key];\n        });\n\n        // Set an identity on the connection\n        config.identity = item;\n\n        // Grab the schemas used on this connection\n        connection._collections.forEach(function(coll) {\n          var identity = coll;\n          if (hasOwnProperty(self.collections[coll].__proto__, 'tableName')) {\n            identity = self.collections[coll].__proto__.tableName;\n          }\n\n          usedSchemas[identity] = results.buildCollectionSchemas[coll];\n        });\n\n        // Call the registerConnection method\n        connection._adapter.registerConnection(config, usedSchemas, function(err) {\n          if (err) return nextItem(err);\n          nextItem();\n        });\n      }, next);\n    }]\n\n  }, function(err) {\n    if (err) return cb(err);\n    self.bootstrap(function(err) {\n      if (err) return cb(err);\n      cb(null, { collections: self.collections, connections: self.connections });\n    });\n  });\n\n};\n\n/**\n * Teardown\n *\n * Calls the teardown method on each connection if available.\n */\n\nWaterline.prototype.teardown = function teardown(cb) {\n  var self = this;\n\n  async.each(Object.keys(this.connections), function(item, next) {\n    var connection = self.connections[item];\n\n    // Check if the adapter has a teardown method implemented\n    if (!hasOwnProperty(connection._adapter, 'teardown')) return next();\n\n    connection._adapter.teardown(item, next);\n  }, cb);\n};\n\n/**\n * Bootstrap\n *\n * Auto-migrate all collections\n */\n\nWaterline.prototype.bootstrap = function bootstrap(cb) {\n  var self = this;\n\n  //\n  // TODO:\n  // Come back to this -- see https://github.com/balderdashy/waterline/issues/259\n  // (the stuff in this file works fine-- the work would be structural changes elsewhere)\n  //\n\n  // // Use the shema to get a list of junction tables idents\n  // // and then determine which are \"logical\" collections\n  // // (i.e. everything EXCEPT junction tables)\n  // var junctionTableIdents = _(this.schema).filter({junctionTable: true}).pluck('identity').value();\n  // var logicalCollections = _(this.collections).omit(junctionTableIdents).value();\n\n  // // Flatten logical collections obj into an array for convenience\n  // var toBeSynced = _.reduce(logicalCollections, function(logicals,coll,ident) {\n  //     logicals.push(coll);\n  //     return logicals;\n  //   }, []);\n\n  // // console.log(junctionTableIdents);\n  // // console.log(Object.keys(logicalCollections));\n  // // console.log('\\n',\n  // //   'Migrating collections ::',\n  // //   _(toBeSynced).pluck('identity').value()\n  // // );\n\n  // For now:\n  var toBeSynced = _.reduce(this.collections, function(resources, collection, ident) {\n    resources.push(collection);\n    return resources;\n  }, []);\n\n  // Run auto-migration strategies on each collection\n  // async.each(toBeSynced, function(collection, next) {\n  async.eachSeries(toBeSynced, function(collection, next) {\n  // async.eachLimit(toBeSynced, 9, function(collection, next) {\n    collection.sync(next);\n  }, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/connections/index.js":"/**\n * Module Dependencies\n */\nvar _ = require('lodash');\nvar util = require('util');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\n/**\n * Connections are active \"connections\" to a specific adapter for a specific configuration.\n * This allows you to have collections share named connections.\n *\n * @param {Object} adapters\n * @param {Object} objects\n * @api public\n */\n\nvar Connections = module.exports = function(adapters, options) {\n\n  // Hold the active connections\n  this._connections = {};\n\n  // Build the connections\n  this._build(adapters, options);\n\n  return this._connections;\n};\n\n\n/**\n * Builds up a named connections object with a clone of the adapter\n * it will use for the connection.\n *\n * @param {Object} adapters\n * @param {Object} options\n * @api private\n */\nConnections.prototype._build = function _build(adapters, options) {\n\n  var self = this;\n\n  // For each of the configured connections in options, find the required\n  // adapter by name and build up an object that can be attached to the\n  // internal connections object.\n  Object.keys(options).forEach(function(key) {\n    var config = options[key];\n    var msg,\n        connection;\n\n    // Ensure an adapter module is specified\n    if (!hasOwnProperty(config, 'adapter')) {\n      msg = util.format('Connection (\"%s\") is missing a required property (`adapter`).  You should indicate the name of one of your adapters.', key);\n      throw new Error(msg);\n    }\n\n    // Ensure the adapter exists in the adapters options\n    if (!hasOwnProperty(adapters, config.adapter)) {\n      if (typeof config.adapter !== 'string') {\n        msg = util.format('Invalid `adapter` property in connection `%s`.  It should be a string (the name of one of the adapters you passed into `waterline.initialize()`)', key);\n      }\n      else msg = util.format('Unknown adapter \"%s\" for connection `%s`.  You should double-check that the connection\\'s `adapter` property matches the name of one of your adapters.  Or perhaps you forgot to include your \"%s\" adapter when you called `waterline.initialize()`...', config.adapter, key, config.adapter);\n      throw new Error(msg);\n    }\n\n    // Build the connection config\n    connection = {\n      config: _.merge({}, adapters[config.adapter].defaults, config),\n      _adapter: _.cloneDeep(adapters[config.adapter]),\n      _collections: []\n    };\n\n    // Attach the connections to the connection library\n    self._connections[key] = connection;\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/helpers.js":"\n/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\n\n/**\n * Equivalent to _.objMap, _.map for objects, keeps key/value associations\n *\n * Should be deprecated.\n *\n * @api public\n */\nexports.objMap = function objMap(input, mapper, context) {\n  return _.reduce(input, function(obj, v, k) {\n    obj[k] = mapper.call(context, v, k, input);\n    return obj;\n  }, {}, context);\n};\n\n/**\n * Run a method meant for a single object on a object OR array\n * For an object, run the method and return the result.\n * For a list, run the method on each item return the resulting array.\n * For anything else, return it silently.\n *\n * Should be deprecated.\n *\n * @api public\n */\n\nexports.pluralize = function pluralize(collection, application) {\n  if (Array.isArray(collection)) return _.map(collection, application);\n  if (_.isObject(collection)) return application(collection);\n  return collection;\n};\n\n/**\n * _.str.capitalize\n *\n * @param {String} str\n * @return {String}\n * @api public\n */\n\nexports.capitalize = function capitalize(str) {\n  str = str === null ? '' : String(str);\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n * ignore\n */\n\nexports.object = {};\n\n/**\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n * @return {Boolean}\n * @api public\n */\n\nvar hop = Object.prototype.hasOwnProperty;\nexports.object.hasOwnProperty = function(obj, prop) {\n  if (obj === null || obj === undefined) return false;\n  return hop.call(obj, prop);\n};\n\n/**\n * Check if an ID resembles a Mongo BSON ID.\n * Can't use the `hop` helper above because BSON ID's will have their own hasOwnProperty value.\n *\n * @param {String} id\n * @return {Boolean}\n * @api public\n */\n\nexports.matchMongoId = function matchMongoId(id) {\n  // id must be truthy- and either BE a string, or be an object\n  // with a toString method.\n  if (!id ||\n   !(_.isString(id) || (_.isObject(id) || _.isFunction(id.toString)))\n  ) return false;\n  else return /^[a-fA-F0-9]{24}$/.test(id.toString());\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/collection/loader.js":"/**\n * Module Dependencies\n */\n\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\n/**\n * Collection Loader\n *\n * @param {Object} connections\n * @param {Object} collection\n * @api public\n */\n\nvar CollectionLoader = module.exports = function(collection, connections, defaults) {\n\n  this.defaults = defaults;\n\n  // Normalize and validate the collection\n  this.collection = this._validate(collection, connections);\n\n  // Find the named connections used in the collection\n  this.namedConnections = this._getConnections(collection, connections);\n\n  return this;\n};\n\n/**\n * Initalize the collection\n *\n * @param {Object} context\n * @param {Function} callback\n * @api public\n */\n\nCollectionLoader.prototype.initialize = function initialize(context) {\n  return new this.collection(context, this.namedConnections);\n};\n\n/**\n * Validate Collection structure.\n *\n * @param {Object} collection\n * @param {Object} connections\n * @api private\n */\n\nCollectionLoader.prototype._validate = function _validate(collection, connections) {\n\n  // Throw Error if no Tablename/Identity is set\n  if (!hasOwnProperty(collection.prototype, 'tableName') && !hasOwnProperty(collection.prototype, 'identity')) {\n    throw new Error('A tableName or identity property must be set.');\n  }\n\n  // Ensure identity is lowercased\n  collection.prototype.identity = collection.prototype.identity.toLowerCase();\n\n  // Set the defaults\n  collection.prototype.defaults = this.defaults;\n\n  // Find the connections used by this collection\n  // If none is specified check if a default connection exist\n  if (!hasOwnProperty(collection.prototype, 'connection')) {\n\n    // Check if a default connection was specified\n    if (!hasOwnProperty(connections, 'default')) {\n      throw new Error('No adapter was specified for collection: ' + collection.prototype.identity);\n    }\n\n    // Set the connection as the default\n    collection.prototype.connection = 'default';\n  }\n\n  return collection;\n};\n\n/**\n * Get the named connections\n *\n * @param {Object} collection\n * @param {Object} connections\n * @api private\n */\n\nCollectionLoader.prototype._getConnections = function _getConnections(collection, connections) {\n\n  // Hold the used connections\n  var usedConnections = {};\n\n  // Normalize connection to array\n  if (!Array.isArray(collection.prototype.connection)) {\n    collection.prototype.connection = [collection.prototype.connection];\n  }\n\n  // Set the connections used for the adapter\n  collection.prototype.connection.forEach(function(conn) {\n\n    // Ensure the named connection exist\n    if (!hasOwnProperty(connections, conn)) {\n      var msg = 'The connection ' + conn + ' specified in ' + collection.prototype.identity + ' does not exist!';\n      throw new Error(msg);\n    }\n\n    usedConnections[conn] = connections[conn];\n  });\n\n  return usedConnections;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/collection/defaults.js":"\n/**\n * Default Collection properties\n * @type {Object}\n */\nmodule.exports = {\n\n\tmigrate: 'alter'\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/collection/index.js":"/**\n * Dependencies\n */\n\nvar _ = require('lodash');\nvar extend = require('../utils/extend');\nvar inherits = require('util').inherits;\n\n// Various Pieces\nvar Core = require('../core');\nvar Query = require('../query');\n\n/**\n * Collection\n *\n * A prototype for managing a collection of database\n * records.\n *\n * This file is the prototype for collections defined using Waterline.\n * It contains the entry point for all ORM methods (e.g. User.find())\n *\n * Methods in this file defer to the adapter for their true implementation:\n * the implementation here just validates and normalizes the parameters.\n *\n * @param {Object} waterline, reference to parent\n * @param {Object} options\n * @param {Function} callback\n */\n\nvar Collection = module.exports = function(waterline, connections, cb) {\n\n  var self = this;\n\n  // Set the named connections\n  this.connections = connections || {};\n\n  // Cache reference to the parent\n  this.waterline = waterline;\n\n  // Default Attributes\n  this.attributes = this.attributes || {};\n\n  // Instantiate Base Collection\n  Core.call(this);\n\n  // Instantiate Query Language\n  Query.call(this);\n\n  return this;\n};\n\ninherits(Collection, Core);\ninherits(Collection, Query);\n\n// Make Extendable\nCollection.extend = extend;\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/extend.js":"/**\n * Extend Method\n *\n * Taken from Backbone Source:\n * http://backbonejs.org/docs/backbone.html#section-189\n */\n\nvar _ = require('lodash');\n\nmodule.exports = function(protoProps, staticProps) {\n  var parent = this;\n  var child;\n\n  if (protoProps && _.has(protoProps, 'constructor')) {\n    child = protoProps.constructor;\n  } else {\n    child = function() { return parent.apply(this, arguments); };\n  }\n\n  _.extend(child, parent, staticProps);\n\n  var Surrogate = function() { this.constructor = child; };\n  Surrogate.prototype = parent.prototype;\n  child.prototype = new Surrogate();\n\n  if (protoProps) _.extend(child.prototype, protoProps);\n\n  child.__super__ = parent.prototype;\n\n  return child;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/core/index.js":"/**\n * Dependencies\n */\n\nvar _ = require('lodash');\nvar schemaUtils = require('../utils/schema');\nvar COLLECTION_DEFAULTS = require('../collection/defaults');\nvar Model = require('../model');\nvar Cast = require('./typecast');\nvar Schema = require('./schema');\nvar Dictionary = require('./dictionary');\nvar Validator = require('./validations');\nvar Transformer = require('./transformations');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\n/**\n * Core\n *\n * Setup the basic Core of a collection to extend.\n */\n\nvar Core = module.exports = function(options) {\n\n  options = options || {};\n\n  // Set Defaults\n  this.adapter = this.adapter || {};\n  this._attributes = _.clone(this.attributes);\n  this.connections = this.connections || {};\n\n  this.defaults = _.merge(COLLECTION_DEFAULTS, this.defaults);\n\n  // Construct our internal objects\n  this._cast = new Cast();\n  this._schema = new Schema(this);\n  this._validator = new Validator();\n\n  // Normalize attributes, extract instance methods, and callbacks\n  // Note: this is ordered for a reason!\n  this._callbacks = schemaUtils.normalizeCallbacks(this);\n  this._instanceMethods = schemaUtils.instanceMethods(this.attributes);\n  this._attributes = schemaUtils.normalizeAttributes(this._attributes);\n\n  this.hasSchema = Core._normalizeSchemaFlag.call(this);\n\n  this.migrate = Object.getPrototypeOf(this).hasOwnProperty('migrate') ?\n    this.migrate : this.defaults.migrate;\n\n  // Initalize the internal values from the Collection\n  Core._initialize.call(this, options);\n\n  return this;\n};\n\n/**\n * Initialize\n *\n * Setups internal mappings from an extended collection.\n */\n\nCore._initialize = function(options) {\n  var self = this;\n\n  options = options || {};\n\n  // Extend a base Model with instance methods\n  this._model = new Model(this, this._instanceMethods);\n\n  // Cache the attributes from the schema builder\n  var schemaAttributes = this.waterline.schema[this.identity].attributes;\n\n  // Remove auto attributes for validations\n  var _validations = _.clone(this._attributes);\n  if (this.autoPK) delete _validations.id;\n  if (this.autoCreatedAt) delete _validations.createdAt;\n  if (this.autoUpdatedAt) delete _validations.updatedAt;\n\n  // If adapter exposes any reserved attributes, pass them to the schema\n  var connIdx = Array.isArray(this.connection) ? this.connection[0] : this.connection;\n\n  var adapterInfo = {};\n  if (this.connections[connIdx] && this.connections[connIdx]._adapter) {\n    adapterInfo = this.connections[connIdx]._adapter;\n  }\n\n  var reservedAttributes = adapterInfo.reservedAttributes || {};\n\n  // Initialize internal objects from attributes\n  this._schema.initialize(this._attributes, this.hasSchema, reservedAttributes);\n  this._cast.initialize(this._schema.schema);\n  this._validator.initialize(_validations, this.types, this.defaults.validations);\n\n  // Set the collection's primaryKey attribute\n  Object.keys(schemaAttributes).forEach(function(key) {\n    if (hasOwnProperty(schemaAttributes[key], 'primaryKey') && schemaAttributes[key].primaryKey) {\n      self.primaryKey = key;\n    }\n  });\n\n  // Build Data Transformer\n  this._transformer = new Transformer(schemaAttributes, this.waterline.schema);\n\n  // Transform Schema\n  this._schema.schema = this._transformer.serialize(this._schema.schema, 'schema');\n\n  // Build up a dictionary of which methods run on which connection\n  this.adapterDictionary = new Dictionary(_.cloneDeep(this.connections), this.connection);\n\n  // Add this collection to the connection\n  Object.keys(this.connections).forEach(function(conn) {\n    self.connections[conn]._collections = self.connections[conn]._collections || [];\n    self.connections[conn]._collections.push(self.identity);\n  });\n\n  // Remove remnants of user defined attributes\n  delete this.attributes;\n};\n\n/**\n * Normalize Schema Flag\n *\n * Normalize schema setting by looking at the model first to see if it is defined, if not look at\n * the connection and see if it's defined and if not finally look into the adapter and check if\n * there is a default setting. If not found anywhere be safe and set to true.\n *\n * @api private\n * @return {Boolean}\n */\n\nCore._normalizeSchemaFlag = function() {\n\n  // If schema is defined on the collection, return the value\n  if (hasOwnProperty(Object.getPrototypeOf(this), 'schema')) {\n    return Object.getPrototypeOf(this).schema;\n  }\n\n  // Grab the first connection used\n  if (!this.connection || !Array.isArray(this.connection)) return true;\n  var connection = this.connections[this.connection[0]];\n\n  // Check the user defined config\n  if (hasOwnProperty(connection, 'config') && hasOwnProperty(connection.config, 'schema')) {\n    return connection.config.schema;\n  }\n\n  // Check the defaults defined in the adapter\n  if (!hasOwnProperty(connection, '_adapter')) return true;\n  if (!hasOwnProperty(connection._adapter, 'schema')) return true;\n\n  return connection._adapter.schema;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/schema.js":"/**\n * Dependencies\n */\n\nvar _ = require('lodash');\nvar types = require('./types');\nvar callbacks = require('./callbacks');\nvar hasOwnProperty = require('./helpers').object.hasOwnProperty;\n\n/**\n * Expose schema\n */\n\nvar schema = module.exports = exports;\n\n/**\n * Iterate over `attrs` normalizing string values to the proper\n * attribute object.\n *\n * Example:\n * {\n *   name: 'STRING',\n *   age: {\n *     type: 'INTEGER'\n *   }\n * }\n *\n * Returns:\n * {\n *   name: {\n *     type: 'string'\n *   },\n *   age: {\n *     type: 'integer'\n *   }\n * }\n *\n * @param {Object} attrs\n * @return {Object}\n */\n\nschema.normalizeAttributes = function(attrs) {\n  var attributes = {};\n\n  Object.keys(attrs).forEach(function(key) {\n\n    // Not concerned with functions\n    if (typeof attrs[key] === 'function') return;\n\n    // Expand shorthand type\n    if (typeof attrs[key] === 'string') {\n      attributes[key] = { type: attrs[key] };\n    } else {\n      attributes[key] = attrs[key];\n    }\n\n    // Ensure type is lower case\n    if (attributes[key].type && typeof attributes[key].type !== 'undefined') {\n      attributes[key].type = attributes[key].type.toLowerCase();\n    }\n\n    // Ensure Collection property is lowercased\n    if (hasOwnProperty(attrs[key], 'collection')) {\n      attrs[key].collection = attrs[key].collection.toLowerCase();\n    }\n\n    // Ensure Model property is lowercased\n    if (hasOwnProperty(attrs[key], 'model')) {\n      attrs[key].model = attrs[key].model.toLowerCase();\n    }\n  });\n\n  return attributes;\n};\n\n\n/**\n * Return all methods in `attrs` that should be provided\n * on the model.\n *\n * Example:\n * {\n *   name: 'string',\n *   email: 'string',\n *   doSomething: function() {\n *     return true;\n *   }\n * }\n *\n * Returns:\n * {\n *   doSomething: function() {\n *     return true;\n *   }\n * }\n *\n * @param {Object} attrs\n * @return {Object}\n */\n\nschema.instanceMethods = function(attrs) {\n  var methods = {};\n\n  if (!attrs) return methods;\n\n  Object.keys(attrs).forEach(function(key) {\n    if (typeof attrs[key] === 'function') {\n      methods[key] = attrs[key];\n    }\n  });\n\n  return methods;\n};\n\n\n/**\n * Normalize callbacks\n *\n * Return all callback functions in `context`, allows for string mapping to\n * functions located in `context.attributes`.\n *\n * Example:\n * {\n *   attributes: {\n *     name: 'string',\n *     email: 'string',\n *     increment: function increment() { i++; }\n *   },\n *   afterCreate: 'increment',\n *   beforeCreate: function() { return true; }\n * }\n *\n * Returns:\n * {\n *   afterCreate: [\n *     function increment() { i++; }\n *   ],\n *   beforeCreate: [\n *     function() { return true; }\n *   ]\n * }\n *\n * @param {Object} context\n * @return {Object}\n */\n\nschema.normalizeCallbacks = function(context) {\n  var i, _i, len, _len, fn;\n  var fns = {};\n\n  function defaultFn(fn) {\n    return function(values, next) { return next(); };\n  }\n\n  for (i = 0, len = callbacks.length; i < len; i = i + 1) {\n    fn = callbacks[i];\n\n    // Skip if the model hasn't defined this callback\n    if (typeof context[fn] === 'undefined') {\n      fns[fn] = [ defaultFn(fn) ];\n      continue;\n    }\n\n    if (Array.isArray(context[fn])) {\n      fns[fn] = [];\n\n      // Iterate over all functions\n      for (_i = 0, _len = context[fn].length; _i < _len; _i = _i + 1) {\n        if (typeof context[fn][_i] === 'string') {\n          // Attempt to map string to function\n          if (typeof context.attributes[context[fn][_i]] === 'function') {\n            fns[fn][_i] = context.attributes[context[fn][_i]];\n            delete context.attributes[context[fn][_i]];\n          } else {\n            throw new Error('Unable to locate callback `' + context[fn][_i] + '`');\n          }\n        } else {\n          fns[fn][_i] = context[fn][_i];\n        }\n      }\n    } else if (typeof context[fn] === 'string') {\n      // Attempt to map string to function\n      if (typeof context.attributes[context[fn]] === 'function') {\n        fns[fn] = [ context.attributes[context[fn]] ];\n        delete context.attributes[context[fn]];\n      } else {\n        throw new Error('Unable to locate callback `' + context[fn] + '`');\n      }\n    } else {\n      // Just add a single function\n      fns[fn] = [ context[fn] ];\n    }\n  }\n\n  return fns;\n};\n\n\n/**\n * Replace any Join Criteria references with the defined tableName for a collection.\n *\n * @param {Object} criteria\n * @param {Object} collections\n * @return {Object}\n * @api public\n */\n\nschema.serializeJoins = function(criteria, collections) {\n\n  if (!criteria.joins) return criteria;\n\n  var joins = _.cloneDeep(criteria.joins);\n\n  joins.forEach(function(join) {\n\n    if (!hasOwnProperty(collections[join.parent], 'tableName')) return;\n    if (!hasOwnProperty(collections[join.child], 'tableName')) return;\n\n    join.parent = collections[join.parent].tableName;\n    join.child = collections[join.child].tableName;\n\n  });\n\n  criteria.joins = joins;\n  return criteria;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/types.js":"/**\n * Types Supported By Schemas\n */\n\nmodule.exports = [\n  'string',\n  'text',\n  'integer',\n  'float',\n  'date',\n  'time',\n  'datetime',\n  'boolean',\n  'binary',\n  'array',\n  'json',\n  'mediumtext',\n  'longtext',\n  'objectid'\n];\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/callbacks.js":"/**\n * Lifecycle Callbacks Allowed\n */\n\nmodule.exports = [\n  'beforeValidate',\n  'afterValidate',\n  'beforeUpdate',\n  'afterUpdate',\n  'beforeCreate',\n  'afterCreate',\n  'beforeDestroy',\n  'afterDestroy'\n];\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/index.js":"\n/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar Bluebird = require('bluebird');\nvar Model = require('./lib/model');\nvar defaultMethods = require('./lib/defaultMethods');\nvar internalMethods = require('./lib/internalMethods');\n\n/**\n * Build Extended Model Prototype\n *\n * @param {Object} context\n * @param {Object} mixins\n * @return {Object}\n * @api public\n */\n\nmodule.exports = function(context, mixins) {\n\n  /**\n   * Extend the model prototype with default instance methods\n   */\n\n  var prototypeFns = {\n\n    toObject: function() {\n      return new defaultMethods.toObject(context, this);\n    },\n\n    save: function(options, cb) {\n      return new defaultMethods.save(context, this, options, cb);\n    },\n\n    destroy: function(cb) {\n      return new defaultMethods.destroy(context, this, cb);\n    },\n\n    _defineAssociations: function() {\n      new internalMethods.defineAssociations(context, this);\n    },\n\n    _normalizeAssociations: function() {\n      new internalMethods.normalizeAssociations(context, this);\n    },\n\n    _cast: function(values) {\n      _.keys(context._attributes).forEach(function(key) {\n        var type = context._attributes[key].type;\n\n        // Attempt to parse Array or JSON type\n        if (type === 'array' || type === 'json') {\n          if (!_.isString(values[key])) return;\n          try {\n            values[key] = JSON.parse(values[key]);\n          } catch(e) {\n            return;\n          }\n        }\n\n        // Convert booleans back to true/false\n        if (type === 'boolean') {\n          var val = values[key];\n          if (val === 0) values[key] = false;\n          if (val === 1) values[key] = true;\n        }\n\n      });\n    },\n\n    /**\n     * Model.validate()\n     *\n     * Takes the currently set attributes and validates the model\n     * Shorthand for Model.validate({ attributes }, cb)\n     *\n     * @param {Function} callback - (err)\n     * @return {Promise}\n     */\n\n    validate: function(cb) {\n      // Collect current values\n      var values = this.toObject();\n\n      if (cb) {\n        context.validate(values, function(err) {\n          if (err) { return cb(err); }\n          cb();\n        });\n        return;\n      } else {\n        return new Bluebird(function(resolve, reject) {\n          context.validate(values, function(err) {\n            if (err) { return reject(err); }\n            resolve();\n          });\n        });\n      }\n    }\n\n  };\n\n  // If any of the attributes are protected, the default toJSON method should\n  // remove them.\n  var protectedAttributes = _.compact(_.map(context._attributes, function(attr, key) {return attr.protected ? key : undefined;}));\n\n  prototypeFns.toJSON = function() {\n    var obj = this.toObject();\n\n    if (protectedAttributes.length) {\n      _.each(protectedAttributes, function(key) {\n        delete obj[key];\n      });\n    }\n\n    // Remove toJSON from the result, to prevent infinite recursion with\n    // msgpack or other recursive object transformation tools.\n    //\n    // Causes issues if set to null and will error in Sails if we delete it because blueprints call it.\n    //\n    // obj.toJSON = null;\n\n    return obj;\n  };\n\n  var prototype = _.extend(prototypeFns, mixins);\n\n  var model = Model.extend(prototype);\n\n  // Return the extended model for use in Waterline\n  return model;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/model.js":"\n/**\n * Dependencies\n */\n\nvar extend = require('../../utils/extend');\nvar _ = require('lodash');\nvar util = require('util');\n\n/**\n * A Basic Model Interface\n *\n * Initialize a new Model with given params\n *\n * @param {Object} attrs\n * @param {Object} options\n * @return {Object}\n * @api public\n *\n * var Person = Model.prototype;\n * var person = new Person({ name: 'Foo Bar' });\n * person.name # => 'Foo Bar'\n */\n\nvar Model = module.exports = function(attrs, options) {\n  var self = this;\n\n  attrs = attrs || {};\n  options = options || {};\n\n  // Store options as properties\n  Object.defineProperty(this, '_properties', {\n    enumerable: false,\n    writable: false,\n    value: options\n  });\n\n  // Cast things that need to be cast\n  this._cast(attrs);\n\n  // Build association getters and setters\n  this._defineAssociations();\n\n  // Attach attributes to the model instance\n  for (var key in attrs) {\n    this[key] = attrs[key];\n\n    if (this.associationsCache.hasOwnProperty(key)) {\n      this.associationsCache[key] = _.cloneDeep(attrs[key]);\n    }\n  }\n\n  // Normalize associations\n  this._normalizeAssociations();\n\n\n  /**\n   * Log output\n   * @return {String} output when this model is util.inspect()ed\n   * (usually with console.log())\n   */\n\n  Object.defineProperty(this, 'inspect', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: function() {\n      var output;\n      try {\n        output = self.toObject();\n      } catch (e) {}\n\n      return output ? util.inspect(output) : self;\n    }\n  });\n\n  return this;\n};\n\n// Make Extendable\nModel.extend = extend;\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/defaultMethods/index.js":"\n/**\n * Export Default Methods\n */\n\nmodule.exports = {\n  toObject: require('./toObject'),\n  destroy: require('./destroy'),\n  save: require('./save')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/defaultMethods/toObject.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Model.toObject()\n *\n * Returns an object containing just the model values. Useful for doing\n * operations on the current values minus the instance methods.\n *\n * @param {Object} context, Waterline collection instance\n * @param {Object} proto, model prototype\n * @api public\n * @return {Object}\n */\n\nvar toObject = module.exports = function(context, proto) {\n\n  var self = this;\n\n  this.context = context;\n  this.proto = proto;\n\n  // Hold joins used in the query\n  this.usedJoins = [];\n\n  // Create an object that can hold the values to be returned\n  this.object = {};\n\n  // Run methods to add and modify values to the above object\n  this.addAssociations();\n  this.addProperties();\n  this.makeObject();\n  this.filterJoins();\n  this.filterFunctions();\n\n  // Ok now we want to create a POJO that can be serialized for use in a response.\n  // This is after all usually called in a toJSON method so lets make sure its all\n  // good in there. This could be faster and safer I recon.\n  try {\n\n    // Stringify/parse the object\n    var _obj = JSON.parse(JSON.stringify(this.object));\n\n    return _obj;\n\n  // Return a nicer error message than just throwing the json parse message\n  } catch (e) {\n    var err = new Error();\n    err.message = 'There was an error turning the model into an object.';\n    err.data = self.object;\n    throw err;\n  }\n};\n\n\n/**\n * Add Association Keys\n *\n * If a showJoins flag is active, add all association keys.\n *\n * @param {Object} keys\n * @api private\n */\n\ntoObject.prototype.addAssociations = function() {\n  var self = this;\n\n  if (!this.proto._properties) return;\n  if (!this.proto._properties.showJoins) return;\n\n  // Copy prototype over for attributes\n  for (var association in this.proto.associations) {\n\n    // Handle hasMany attributes\n    if (hasOwnProperty(this.proto.associations[association], 'value')) {\n\n      var records = [];\n      var values = this.proto.associations[association].value;\n\n      values.forEach(function(record) {\n        if (typeof record !== 'object') return;\n        // Since `typeof null` === `\"object\"`, we should also check for that case:\n        if (record === null) return;\n        var item = Object.create(record.__proto__);\n        Object.keys(record).forEach(function(key) {\n          item[key] = _.cloneDeep(record[key]);\n        });\n        records.push(item);\n      });\n\n      this.object[association] = records;\n      continue;\n    }\n\n    // Handle belongsTo attributes\n    var record = this.proto[association];\n    var item;\n\n    // Check if the association foreign key is a date. If so set the object's\n    // association and continue. Manual check here is needed because _.isObject\n    // matches dates and you will end up with a loop that never exits.\n    if (_.isDate(record)) {\n\n      item = new Date(record);\n      _.extend(item.__proto__ , record.__proto__);\n\n      this.object[association] = item;\n    }\n\n    // Is the record is a populated object, create a new object from it.\n    // _.isObject() does not match null, so we're good here.\n    else if (_.isObject(record) && !Array.isArray(record)) {\n\n      item = Object.create(record.__proto__);\n\n      Object.keys(record).forEach(function(key) {\n        item[key] = record[key];\n      });\n\n      this.object[association] = item;\n    }\n\n    else if (!_.isUndefined(record)) {\n      this.object[association] = record;\n    }\n  }\n};\n\n/**\n * Add Properties\n *\n * Copies over non-association attributes to the newly created object.\n *\n * @api private\n */\n\ntoObject.prototype.addProperties = function() {\n  var self = this;\n\n  Object.keys(this.proto).forEach(function(key) {\n    if (hasOwnProperty(self.object, key)) return;\n    self.object[key] = self.proto[key];\n  });\n\n};\n\n/**\n * Make Object\n *\n * Runs toJSON on all associated values\n *\n * @api private\n */\n\ntoObject.prototype.makeObject = function() {\n  var self = this;\n\n  if (!this.proto._properties) return;\n  if (!this.proto._properties.showJoins) return;\n\n  // Handle Joins\n  Object.keys(this.proto.associations).forEach(function(association) {\n\n    // Don't run toJSON on records that were not populated\n    if (!self.proto._properties || !self.proto._properties.joins) return;\n\n    // Build up a join key name based on the attribute's model/collection name\n    var joinsName = association;\n    if (self.context._attributes[association].model) joinsName = self.context._attributes[association].model.toLowerCase();\n    if (self.context._attributes[association].collection) joinsName = self.context._attributes[association].collection.toLowerCase();\n\n    // Check if the join was used\n    if (self.proto._properties.joins.indexOf(joinsName) < 0 && self.proto._properties.joins.indexOf(association) < 0) return;\n    self.usedJoins.push(association);\n\n    // Call toJSON on each associated record\n    if (Array.isArray(self.object[association])) {\n      var records = [];\n\n      self.object[association].forEach(function(item) {\n        if (!hasOwnProperty(item.__proto__, 'toJSON')) return;\n        records.push(item.toJSON());\n      });\n\n      self.object[association] = records;\n      return;\n    }\n\n    if (!self.object[association]) return;\n\n    // Association was null or not valid\n    // (don't try to `hasOwnProperty` it so we don't throw)\n    if (typeof self.object[association] !== 'object') {\n      self.object[association] = self.object[association];\n      return;\n    }\n\n    if (!hasOwnProperty(self.object[association].__proto__, 'toJSON')) return;\n    self.object[association] = self.object[association].toJSON();\n  });\n\n};\n\n/**\n * Remove Non-Joined Associations\n *\n * @api private\n */\n\ntoObject.prototype.filterJoins = function() {\n  var attributes = this.context._attributes;\n  var properties = this.proto._properties;\n\n  for (var attribute in attributes) {\n    if (!hasOwnProperty(attributes[attribute], 'model') && !hasOwnProperty(attributes[attribute], 'collection')) continue;\n\n    // If no properties and a collection attribute, delete the association and return\n    if (!properties && hasOwnProperty(attributes[attribute], 'collection')) {\n      delete this.object[attribute];\n      continue;\n    }\n\n    // If showJoins is false remove the association object\n    if (properties && !properties.showJoins) {\n\n      // Don't delete belongs to keys\n      if (!attributes[attribute].model) delete this.object[attribute];\n    }\n\n    if (properties && properties.joins) {\n      if (this.usedJoins.indexOf(attribute) < 0) {\n\n        // Don't delete belongs to keys\n        if (!attributes[attribute].model) delete this.object[attribute];\n      }\n    }\n  }\n};\n\n/**\n * Filter Functions\n *\n * @api private\n */\n\ntoObject.prototype.filterFunctions = function() {\n  for (var key in this.object) {\n    if (typeof this.object[key] === 'function') {\n      delete this.object[key];\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/defaultMethods/destroy.js":"\n/**\n * Module dependencies\n */\n\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\nvar defer = require('../../../utils/defer');\nvar noop = function() {};\n\n/**\n * Model.destroy()\n *\n * Destroys an instance of a model\n *\n * @param {Object} context,\n * @param {Object} proto\n * @param {Function} callback\n * @return {Promise}\n * @api public\n */\n\nvar Destroy = module.exports = function(context, proto, cb) {\n\n  var deferred;\n  var err;\n\n  if (typeof cb !== 'function') {\n    deferred = defer();\n  }\n\n  cb = cb || noop;\n\n  var values = proto.toObject();\n  var attributes = context.waterline.schema[context.identity].attributes;\n  var primaryKey = this.findPrimaryKey(attributes, values);\n\n  if (!primaryKey) {\n    err = new Error('No Primary Key set to update the record with! ' +\n    'Try setting an attribute as a primary key or include an ID property.');\n\n    if (deferred) {\n      deferred.reject(err);\n    }\n\n    return cb(err);\n  }\n\n  if (!values[primaryKey]) {\n    err = new Error('No Primary Key set to update the record with! ' +\n    'Primary Key must have a value, it can\\'t be an optional value.');\n\n    if (deferred) {\n      deferred.reject(err);\n    }\n\n    return cb(err);\n  }\n\n  // Build Search Criteria\n  var criteria = {};\n  criteria[primaryKey] = values[primaryKey];\n\n  // Execute Query\n  context.destroy(criteria, function(err, status) {\n    if (err) {\n\n      if (deferred) {\n        deferred.reject(err);\n      }\n\n      return cb(err);\n    }\n\n    if (deferred) {\n      deferred.resolve(status);\n    }\n\n    cb.apply(this, arguments);\n  });\n\n  if (deferred) {\n    return deferred.promise;\n  }\n};\n\n/**\n * Find Primary Key\n *\n * @param {Object} attributes\n * @param {Object} values\n * @api private\n */\n\nDestroy.prototype.findPrimaryKey = function(attributes, values) {\n  var primaryKey = null;\n\n  for (var attribute in attributes) {\n    if (hasOwnProperty(attributes[attribute], 'primaryKey') && attributes[attribute].primaryKey) {\n      primaryKey = attribute;\n      break;\n    }\n  }\n\n  // If no primary key check for an ID property\n  if (!primaryKey && hasOwnProperty(values, 'id')) primaryKey = 'id';\n\n  return primaryKey;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/defer.js":"var Promise = require('bluebird');\n\nmodule.exports = function defer() {\n  var resolve, reject;\n\n  var promise = new Promise(function() {\n    resolve = arguments[0];\n    reject = arguments[1];\n  });\n\n  return {\n    resolve: resolve,\n    reject: reject,\n    promise: promise\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/defaultMethods/save.js":"var _ = require('lodash');\nvar async = require('async');\nvar deep = require('deep-diff');\nvar updateInstance = require('../associationMethods/update');\nvar addAssociation = require('../associationMethods/add');\nvar removeAssociation = require('../associationMethods/remove');\nvar hop = require('../../../utils/helpers').object.hasOwnProperty;\nvar defer = require('../../../utils/defer');\nvar WLError = require('../../../error/WLError');\nvar noop = function() {};\n\n/**\n * Model.save()\n *\n * Takes the currently set attributes and updates the database.\n * Shorthand for Model.update({ attributes }, cb)\n *\n * @param {Object} context\n * @param {Object} proto\n * @param {Function} callback\n * @param {Object} options\n * @return {Promise}\n * @api public\n */\n\nmodule.exports = function(context, proto, options, cb) {\n\n  var deferred;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (typeof cb !== 'function') {\n    deferred = defer();\n  }\n\n  cb = cb || noop;\n\n  /**\n   * TO-DO:\n   * This should all be wrapped in a transaction. That's coming next but for the meantime\n   * just hope we don't get in a nasty state where the operation fails!\n   */\n\n  var mutatedModels = [];\n\n  async.auto({\n\n    // Compare any populated model values to their current state.\n    // If they have been mutated then the values will need to be synced.\n    compareModelValues: function(next) {\n      var modelKeys = Object.keys(proto.associationsCache);\n\n      async.each(modelKeys, function(key, nextKey) {\n        if (!hop(proto, key) || proto[key] === undefined) {\n          return async.setImmediate(function() {\n            nextKey();\n          });\n        }\n\n        var currentVal = proto[key];\n        var previousVal = proto.associationsCache[key];\n\n        // Normalize previousVal to an object\n        if (Array.isArray(previousVal)) {\n          previousVal = previousVal[0];\n        }\n\n        if (deep(currentVal, previousVal)) {\n          mutatedModels.push(key);\n        }\n\n        return async.setImmediate(function() {\n          nextKey();\n        });\n      }, next);\n    },\n\n    // Update The Current Record\n    updateRecord: ['compareModelValues', function(next) {\n\n      // Shallow clone proto.toObject() to remove all the functions\n      var data = _.clone(proto.toObject());\n\n      new updateInstance(context, data, mutatedModels, function(err, data) {\n        next(err, data);\n      });\n    }],\n\n\n    // Build a set of associations to add and remove.\n    // These are populated from using model[associationKey].add() and\n    // model[associationKey].remove().\n    buildAssociationOperations: ['compareModelValues', function(next) {\n\n      // Build a dictionary to hold operations based on association key\n      var operations = {\n        addKeys: {},\n        removeKeys: {}\n      };\n\n      Object.keys(proto.associations).forEach(function(key) {\n\n        // Ignore belongsTo associations\n        if (proto.associations[key].hasOwnProperty('model')) return;\n\n        // Grab what records need adding\n        if (proto.associations[key].addModels.length > 0) {\n          operations.addKeys[key] = proto.associations[key].addModels;\n        }\n\n        // Grab what records need removing\n        if (proto.associations[key].removeModels.length > 0) {\n          operations.removeKeys[key] = proto.associations[key].removeModels;\n        }\n      });\n\n      return async.setImmediate(function() {\n        return next(null, operations);\n      });\n\n    }],\n\n    // Create new associations for each association key\n    addAssociations: ['buildAssociationOperations', 'updateRecord', function(next, results) {\n      var keys = results.buildAssociationOperations.addKeys;\n      return new addAssociation(context, proto, keys, function(err, failedTransactions) {\n        if (err) return next(err);\n\n        // reset addKeys\n        for (var key in results.buildAssociationOperations.addKeys) {\n          proto.associations[key].addModels = [];\n        }\n\n        next(null, failedTransactions);\n      });\n    }],\n\n    // Remove associations for each association key\n    // Run after the addAssociations so that the connection pools don't get exhausted.\n    // Once transactions are ready we can remove this restriction as they will be run on the same\n    // connection.\n    removeAssociations: ['buildAssociationOperations', 'addAssociations', function(next, results) {\n      var keys = results.buildAssociationOperations.removeKeys;\n      return new removeAssociation(context, proto, keys, function(err, failedTransactions) {\n        if (err) return next(err);\n\n        // reset removeKeys\n        for (var key in results.buildAssociationOperations.removeKeys) {\n          proto.associations[key].removeModels = [];\n        }\n\n        next(null, failedTransactions);\n      });\n    }]\n\n  },\n\n  function(err, results) {\n    if (err) {\n      if (deferred) {\n        deferred.reject(err);\n      }\n      return cb(err);\n    }\n\n    // Collect all failed transactions if any\n    var failedTransactions = [];\n    var error;\n\n    if (results.addAssociations) {\n      failedTransactions = failedTransactions.concat(results.addAssociations);\n    }\n\n    if (results.removeAssociations) {\n      failedTransactions = failedTransactions.concat(results.removeAssociations);\n    }\n\n    if (failedTransactions.length > 0) {\n      error = new Error('Some associations could not be added or destroyed during save().');\n      error.failedTransactions = failedTransactions;\n\n      if (deferred) {\n        deferred.reject(new WLError(error));\n      }\n      return cb(new WLError(error));\n    }\n\n    if (!results.updateRecord.length) {\n      error = new Error('Error updating a record.');\n      if (deferred) {\n        deferred.reject(new WLError(error));\n      }\n      return cb(new WLError(error));\n    }\n\n    // Reset the model attribute values with the new values.\n    // This is needed because you could have a lifecycle callback that has\n    // changed the data since last time you accessed it.\n    // Attach attributes to the model instance\n    var newData = results.updateRecord[0];\n    _.each(newData, function(val, key) {\n      proto[key] = val;\n    });\n\n    // If a promise, resolve it\n    if (deferred) {\n      deferred.resolve();\n    }\n\n    // Return the callback\n    return cb();\n  });\n\n  if (deferred) {\n    return deferred.promise;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/associationMethods/update.js":"\n/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('../../../utils/helpers');\nvar nestedOperations = require('../../../utils/nestedOperations');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Update the current instance with the currently set values\n *\n * Called in the model instance context.\n *\n * @param {Object} collection\n * @param {Object} proto\n * @param {Array} mutatedModels\n * @param {Function} callback\n */\n\nvar Update = module.exports = function(collection, proto, mutatedModels, cb) {\n\n  var values = typeof proto.toObject === 'function' ? proto.toObject() : proto;\n  var attributes = collection.waterline.schema[collection.identity].attributes;\n  var primaryKey = this.findPrimaryKey(attributes, values);\n\n  if (!primaryKey) {\n    return cb(new Error('No Primary Key set to update the record with! ' +\n      'Try setting an attribute as a primary key or include an ID property.'));\n  }\n\n  if (!values[primaryKey]) {\n    return cb(new Error('No Primary Key set to update the record with! ' +\n      'Primary Key must have a value, it can\\'t be an optional value.'));\n  }\n\n  // Build Search Criteria\n  var criteria = {};\n  criteria[primaryKey] = values[primaryKey];\n\n  // Clone values so they can be mutated\n  var _values = _.cloneDeep(values);\n\n  // For any nested model associations (objects not collection arrays) that were not changed,\n  // lets set the value to just the foreign key so that an update query is not performed on the\n  // associatied model.\n  var keys = _.keys(_values);\n  keys.forEach(function(key) {\n\n    // Nix any collection attributes so that they do not get sync'd during the update process.\n    // One reason for this is that the result set is not guaranteed to be complete,\n    // so the sync could exclude items.\n    if (attributes[key] && hop(attributes[key], 'collection') && attributes[key].collection) {\n\n      delete _values[key];\n      return;\n    }\n\n    // If the key was changed, keep it expanded\n    if (mutatedModels.indexOf(key) !== -1) return;\n\n    // Reduce it down to a foreign key value\n    var vals = {};\n    vals[key] = _values[key];\n\n    // Delete and replace the value with a reduced version\n    delete _values[key];\n    var reduced = nestedOperations.reduceAssociations.call(collection, collection.identity, collection.waterline.schema, vals);\n    _values = _.merge(_values, reduced);\n  });\n\n  // Update the collection with the new values\n  collection.update(criteria, _values, cb);\n};\n\n\n/**\n * Find Primary Key\n *\n * @param {Object} attributes\n * @param {Object} values\n * @api private\n */\n\nUpdate.prototype.findPrimaryKey = function(attributes, values) {\n  var primaryKey = null;\n\n  for (var attribute in attributes) {\n    if (hop(attributes[attribute], 'primaryKey') && attributes[attribute].primaryKey) {\n      primaryKey = attribute;\n      break;\n    }\n  }\n\n  // If no primary key check for an ID property\n  if (!primaryKey && hop(values, 'id')) primaryKey = 'id';\n\n  return primaryKey;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/nestedOperations/index.js":"/**\n * Handlers for parsing nested associations within create/update values.\n */\n\nmodule.exports = {\n  reduceAssociations: require('./reduceAssociations'),\n  valuesParser: require('./valuesParser'),\n  create: require('./create'),\n  update: require('./update')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/nestedOperations/reduceAssociations.js":"/**\n * Module Dependencies\n */\n\nvar hop = require('../helpers').object.hasOwnProperty;\nvar _ = require('lodash');\nvar assert = require('assert');\nvar util = require('util');\n\n/**\n * Traverse an object representing values replace associated objects with their\n * foreign keys.\n *\n * @param {String} model\n * @param {Object} schema\n * @param {Object} values\n * @return {Object}\n * @api private\n */\n\n\nmodule.exports = function(model, schema, values, method) {\n  var self = this;\n\n  Object.keys(values).forEach(function(key) {\n\n    // Check to see if this key is a foreign key\n    var attribute = schema[model].attributes[key];\n\n    // If not a plainObject, check if this is a model instance and has a toObject method\n    if (!_.isPlainObject(values[key])) {\n      if (_.isObject(values[key]) && !Array.isArray(values[key]) && values[key].toObject && typeof values[key].toObject === 'function') {\n        values[key] = values[key].toObject();\n      } else {\n        return;\n      }\n    }\n    // Check that this user-specified value is not NULL\n    if (values[key] === null) return;\n\n    // Check that this user-specified value actually exists\n    // as an attribute in `model`'s schema.\n    // If it doesn't- just ignore it\n    if (typeof attribute !== 'object') return;\n\n    if (!hop(values[key], attribute.on)) return;\n\n    // Look and see if the related model has a custom primary key AND that\n    // the intended method is \"create\"\n    var related = self.waterline.collections[attribute.references];\n    var relatedPK = _.find(related.attributes, { primaryKey: true });\n\n    // If a custom PK was used and it's not autoIncrementing and the record\n    // is being created then go ahead and don't reduce it. This allows nested\n    // creates to work when custom PK's are used.\n    if (!relatedPK.autoIncrement && !related.autoPK && method && (method == 'create' || method == 'update')) {\n      return;\n    }\n\n    // Otherwise reduce the association like normal\n    var fk = values[key][attribute.on];\n    values[key] = fk;\n\n  });\n\n  return values;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/nestedOperations/valuesParser.js":"/**\n * Module Dependencies\n */\n\nvar hasOwnProperty = require('../helpers').object.hasOwnProperty;\n\n/**\n * Traverse an object representing values and map out any associations.\n *\n * @param {String} model\n * @param {Object} schema\n * @param {Object} values\n * @return {Object}\n * @api private\n */\n\n\nmodule.exports = function(model, schema, values) {\n  var self = this;\n\n  // Pick out the top level associations\n  var associations = {\n    collections: [],\n    models: []\n  };\n\n  Object.keys(values).forEach(function(key) {\n\n    // Ignore values equal to null\n    if (values[key] === null) return;\n\n    // Ignore joinTables\n    if (hasOwnProperty(schema[model], 'junctionTable')) return;\n    if (!hasOwnProperty(schema[model].attributes, key)) return;\n\n    var attribute = schema[model].attributes[key];\n    if (!hasOwnProperty(attribute, 'collection') && !hasOwnProperty(attribute, 'foreignKey')) return;\n\n    if (hasOwnProperty(attribute, 'collection')) associations.collections.push(key);\n    if (hasOwnProperty(attribute, 'foreignKey')) associations.models.push(key);\n\n  });\n\n  return associations;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/nestedOperations/create.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar hasOwnProperty = require('../helpers').object.hasOwnProperty;\n\n/**\n * Queue up .add() operations on a model instance for any nested association\n * values in a .create() query.\n *\n * @param {Object} parentModel\n * @param {Object} values\n * @param {Object} associations\n * @param {Function} cb\n * @api private\n */\n\nmodule.exports = function(parentModel, values, associations, cb) {\n  var self = this;\n\n  // For each association, grab the primary key value and normalize into model.add methods\n  associations.forEach(function(association) {\n    var attribute = self.waterline.schema[self.identity].attributes[association];\n    var modelName;\n\n    if (hasOwnProperty(attribute, 'collection')) modelName = attribute.collection;\n\n    if (!modelName) return;\n\n    // Grab the relation's PK\n    var related = self.waterline.collections[modelName];\n    var relatedPK = _.find(related.attributes, { primaryKey: true });\n\n    // Get the attribute's name\n    var pk = self.waterline.collections[modelName].primaryKey;\n\n    var optValues = values[association];\n    if (!optValues) return;\n    if (!_.isArray(optValues)) {\n      optValues = _.isString(optValues) ? optValues.split(',') : [optValues];\n    }\n    optValues.forEach(function(val) {\n\n      // If value is not an object, queue up an add\n      if (!_.isPlainObject(val)) return parentModel[association].add(val);\n\n      // If value is an object, check if a primary key is defined\n      // If a custom PK was used and it's not autoIncrementing and the record\n      // is being created then go ahead and don't reduce it. This allows nested\n      // creates to work when custom PK's are used.\n      if (relatedPK.autoIncrement && related.autoPK && hasOwnProperty(val, pk)) {\n        return parentModel[association].add(val[pk]);\n      } else {\n        parentModel[association].add(val);\n      }\n    });\n  });\n\n  // Save the parent model\n  parentModel.save(cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/nestedOperations/update.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar hop = require('../helpers').object.hasOwnProperty;\n\n\n/**\n * Update nested associations. Will take a values object and perform updating and\n * creating of all the nested associations. It's the same as syncing so it will first\n * remove any associations related to the parent and then \"sync\" the new associations.\n *\n * @param {Array} parents\n * @param {Object} values\n * @param {Object} associations\n * @param {Function} cb\n */\n\nmodule.exports = function(parents, values, associations, cb) {\n\n  var self = this;\n\n  // Combine model and collection associations\n  associations = associations.collections.concat(associations.models);\n\n  // Build up .add and .update operations for each association\n  var operations = buildOperations.call(self, parents, associations, values);\n\n  // Now that our operations are built, lets go through and run any updates.\n  // Then for each parent, find all the current associations and remove them then add\n  // all the new associations in using .add()\n  sync.call(self, parents, operations, cb);\n\n};\n\n\n/**\n * Build Up Operations (add and update)\n *\n * @param {Array} associations\n * @param {Object} values\n * @return {Object}\n */\n\nfunction buildOperations(parents, associations, values) {\n\n  var self = this;\n  var operations = {};\n\n  // For each association, grab the primary key value and normalize into model.add methods\n  associations.forEach(function(association) {\n\n    var optValues = values[association];\n\n    // If values are being nulled out just return. This is used when removing foreign\n    // keys on the parent model.\n    if (optValues === null) return;\n\n    // Pull out any association values that have primary keys, these will need to be updated. All\n    // values can be added for each parent however.\n    operations[association] = {\n      add: [],\n      update: []\n    };\n\n    // Normalize optValues to an array\n    if (!Array.isArray(optValues)) optValues = [optValues];\n    queueOperations.call(self, parents, association, operations[association], optValues);\n  });\n\n  return operations;\n}\n\n/**\n * Queue Up Operations.\n *\n * Takes the array normalized association values and queues up\n * operations for the specific association.\n *\n * @param {String} association\n * @param {Object} operation\n * @param {Array} values\n */\n\nfunction queueOperations(parents, association, operation, values) {\n\n  var self = this;\n  var attribute = self.waterline.schema[self.identity].attributes[association];\n  var modelName;\n\n  if (hop(attribute, 'collection')) modelName = attribute.collection;\n  if (hop(attribute, 'foreignKey')) modelName = attribute.references;\n  if (!modelName) return;\n\n  var collection = self.waterline.collections[modelName];\n\n  // Grab the relation's PK\n  var relatedPK = _.find(collection.attributes, { primaryKey: true });\n  var relatedPkName = collection.primaryKey;\n\n  // If this is a join table, we can just queue up operations on the parent\n  // for this association.\n  if (collection.junctionTable) {\n\n    // For each parent, queue up any .add() operations\n    parents.forEach(function(parent) {\n      values.forEach(function(val) {\n        if (!hop(parent, association)) return;\n        if (typeof parent[association].add !== 'function') return;\n        parent[association].add(val);\n      });\n    });\n\n    return;\n  }\n\n  values.forEach(function(val) {\n\n    // Check the values and see if the model's primary key is given. If so look into\n    // the schema attribute and check if this is a collection or model attribute. If it's\n    // a collection attribute lets update the child record and if it's a model attribute,\n    // update the child and set the parent's foreign key value to the new primary key.\n    //\n    // If a custom PK was used and it's not autoIncrementing add the record. This\n    // allows nested creates to work when custom PK's are used.\n    if (!relatedPK.autoIncrement && !collection.autoPK) {\n      operation.add.push(val);\n      return;\n    }\n\n    // If it's missing a PK queue up an add\n    if (!hop(val, relatedPkName)) {\n      operation.add.push(val);\n      return;\n    }\n\n    // Build up the criteria that will be used to update the child record\n    var criteria = {};\n    criteria[relatedPkName] = val[relatedPkName];\n\n    // Queue up the update operation\n    operation.update.push({ model: modelName, criteria: criteria, values: val });\n\n    // Check if the parents foreign key needs to be updated\n    if (!hop(attribute, 'foreignKey')) {\n      operation.add.push(val[relatedPkName]);\n      return;\n    }\n\n    // Set the new foreign key value for each parent\n    parents.forEach(function(parent) {\n      parent[association] = val[relatedPkName];\n    });\n\n  });\n}\n\n/**\n * Sync Associated Data\n *\n * Using the operations, lets go through and run any updates on any nested object with\n * primary keys. This ensures that all the data passed up is persisted. Then for each parent,\n * find all the current associations and unlink them and then add all the new associations\n * in using .add(). This ensures that whatever is passed in to an update is what the value will\n * be when queried again.\n *\n * @param {Object} operations\n * @param {Function} cb\n */\n\nfunction sync(parents, operations, cb) {\n  var self = this;\n\n  async.auto({\n\n    // Update any nested associations\n    update: function(next) {\n      updateRunner.call(self, parents, operations, next);\n    },\n\n    // For each parent, unlink all the associations currently set\n    unlink: ['update', function(next) {\n      unlinkRunner.call(self, parents, operations, next);\n    }],\n\n    // For each parent found, link any associations passed in by either creating\n    // the new record or linking an existing record\n    link: ['unlink', function(next) {\n      linkRunner.call(self, parents, operations, next);\n    }]\n\n  }, cb);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n// .sync() - Async Auto Runners\n////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Run Update Operations.\n *\n * Uses the information stored in an operation to perform a .update() on the\n * associated model using the new values.\n *\n * @param {Object} operation\n * @param {Function} cb\n */\n\nfunction updateRunner(parents, operations, cb) {\n\n  var self = this;\n\n  // There will be an array of update operations inside of a namespace. Use this to run\n  // an update on the model instance of the association.\n  function associationLoop(association, next) {\n    async.each(operations[association].update, update, next);\n  }\n\n  function update(operation, next) {\n    var model = self.waterline.collections[operation.model];\n    model.update(operation.criteria, operation.values).exec(next);\n  }\n\n  // Operations are namespaced under an association key. So run each association's updates\n  // in parallel for now. May need to be limited in the future but all adapters should\n  // support connection pooling.\n  async.each(Object.keys(operations), associationLoop, cb);\n\n}\n\n\n/**\n * Unlink Associated Records.\n *\n * For each association passed in to the update we are essentially replacing the\n * association's value. In order to do this we first need to clear out any associations\n * that currently exist.\n *\n * @param {Object} operations\n * @param {Function} cb\n */\n\nfunction unlinkRunner(parents, operations, cb) {\n\n  var self = this;\n\n  // Given a parent, build up remove operations and run them.\n  function unlinkParentAssociations(parent, next) {\n    var opts = buildParentRemoveOperations.call(self, parent, operations);\n    removeOperationRunner.call(self, opts, next);\n  }\n\n  async.each(parents, unlinkParentAssociations, cb);\n}\n\n\n/**\n * Link Associated Records\n *\n * Given a set of operations, associate the records with the parent records. This\n * can be done by either creating join table records or by setting foreign keys.\n * It defaults to a parent.add() method for most situations.\n *\n * @param {Object} operations\n * @param {Function} cb\n */\n\nfunction linkRunner(parents, operations, cb) {\n\n  var self = this;\n\n  function linkChildRecords(parent, next) {\n\n    // Queue up `.add()` operations on the parent model and figure out\n    // which records need to be created.\n    //\n    // If an .add() method is available always use it. If this is a nested model an .add()\n    // method won't be available so queue up a create operation.\n    var recordsToCreate = buildParentLinkOperations.call(self, parent, operations);\n\n    // Create the new records and update the parent with the new foreign key\n    // values that may have been set when creating child records.\n    createNewRecords.call(self, parent, recordsToCreate, function(err) {\n      if (err) return next(err);\n      updateParentRecord(parent, cb);\n    });\n  }\n\n  // Update the parent record one last time. This ensures a model attribute (single object)\n  // on the parent can create a new record and then set the parent's foreign key value to\n  // the newly created child record's primary key.\n  //\n  // Example:\n  // Parent.update({\n  //   name: 'foo',\n  //   nestedModel: {\n  //     name: 'bar'\n  //   }\n  // })\n  //\n  // The above query would create the new nested model and then set the parent's nestedModel\n  // value to the newly created model's primary key.\n  //\n  // We then run a .save() to persist any .add() records that may have been used. The update and\n  // .save() are used instead of a find and then save because it's the same amount of queries\n  // and it's easier to take advantage of all that the .add() method gives us.\n  //\n  //\n  // TO-DO:\n  // Make this much smarter to reduce the amount of queries that need to be run. We should probably\n  // be able to at least cut this in half!\n  //\n  function updateParentRecord(parent, next) {\n\n    var criteria = {};\n    var model = self.waterline.collections[self.identity];\n\n    criteria[self.primaryKey] = parent[self.primaryKey];\n    var pValues = parent.toObject();\n\n    model.update(criteria, pValues).exec(function(err) {\n      if (err) return next(err);\n\n      // Call .save() to persist any .add() functions that may have been used.\n      parent.save(next);\n    });\n  }\n\n  async.each(parents, linkChildRecords, cb);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n// .sync() - Helper Functions\n////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Build up operations for performing unlinks.\n *\n * Given a parent and a set of operations, queue up operations to either\n * remove join table records or null out any foreign keys on an child model.\n *\n * @param {Object} parent\n * @param {Object} operations\n * @return {Array}\n */\n\nfunction buildParentRemoveOperations(parent, operations) {\n\n  var self = this;\n  var opts = [];\n\n  // Inspect the association and see if this relationship has a joinTable.\n  // If so create an operation criteria that clears all matching records from the\n  // table. If it doesn't have a join table, build an operation criteria that\n  // nulls out the foreign key on matching records.\n  Object.keys(operations).forEach(function(association) {\n\n    var criteria = {};\n    var searchCriteria = {};\n    var attribute = self.waterline.schema[self.identity].attributes[association];\n\n    /////////////////////////////////////////////////////////////////////////\n    // Parent Record:\n    // If the foreign key is stored on the parent side, null it out\n    /////////////////////////////////////////////////////////////////////////\n\n    if (hop(attribute, 'foreignKey')) {\n\n      // Set search criteria where primary key is equal to the parents primary key\n      searchCriteria[self.primaryKey] = parent[self.primaryKey];\n\n      // Store any information we may need to build up an operation.\n      // Use the `nullify` key to show we want to perform an update and not a destroy.\n      criteria = {\n        model: self.identity,\n        criteria: searchCriteria,\n        keyName: association,\n        nullify: true\n      };\n\n      opts.push(criteria);\n      return;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Child Record:\n    // Lookup the attribute on the other side of the association on in the\n    // case of a m:m association the child table will be the join table.\n    /////////////////////////////////////////////////////////////////////////\n\n    var child = self.waterline.schema[attribute.collection];\n    var childAttribute = child.attributes[attribute.onKey];\n\n    // Set the search criteria to use the collection's `via` key and the parent's primary key.\n    searchCriteria[attribute.on] = parent[self.primaryKey];\n\n    // If the childAttribute stores the foreign key, find all children with the\n    // foreignKey equal to the parent's primary key and null them out or in the case of\n    // a `junctionTable` flag destroy them.\n    if (hop(childAttribute, 'foreignKey')) {\n\n      // Store any information needed to perform the query. Set nullify to false if\n      // a `junctionTable` property is found.\n      criteria = {\n        model: child.identity,\n        criteria: searchCriteria,\n        keyName: attribute.on,\n        nullify: !hop(child, 'throughTable')\n      };\n\n\n      opts.push(criteria);\n      return;\n    }\n  });\n\n  return opts;\n}\n\n\n/**\n * Remove Operation Runner\n *\n * Given a criteria object matching a remove operation, perform the\n * operation using waterline collection instances.\n *\n * @param {Array} operations\n * @param {Function} callback\n */\n\nfunction removeOperationRunner(operations, cb) {\n\n  var self = this;\n\n  function runner(operation, next) {\n    var values = {};\n\n    // If nullify is false, run a destroy method using the criteria to destroy\n    // the join table records.\n    if (!operation.nullify) {\n      self.waterline.collections[operation.model].destroy(operation.criteria).exec(next);\n      return;\n    }\n\n    // Run an update operation to set the foreign key to null on all the\n    // associated child records.\n    values[operation.keyName] = null;\n\n    self.waterline.collections[operation.model].update(operation.criteria, values).exec(next);\n  }\n\n\n  // Run the operations\n  async.each(operations, runner, cb);\n}\n\n\n/**\n * Build up operations for performing links.\n *\n * Given a parent and a set of operations, queue up operations to associate two\n * records together. This could be using the parent's `.add()` method which handles\n * the logic for us or building up a `create` operation that we can run to create the\n * associated record with the correct foreign key set.\n *\n * @param {Object} parent\n * @param {Object} operations\n * @return {Object}\n */\n\nfunction buildParentLinkOperations(parent, operations) {\n\n  var recordsToCreate = {};\n\n  // Determine whether to use the parent association's `.add()` function\n  // or whether to queue up a create operation.\n  function determineOperation(association, opt) {\n\n    // Check if the association has an `add` method, if so use it.\n    if (hop(parent[association], 'add')) {\n      parent[association].add(opt);\n      return;\n    }\n\n    recordsToCreate[association] = recordsToCreate[association] || [];\n    recordsToCreate[association].push(opt);\n  }\n\n  // For each operation look at all the .add operations and determine\n  // what to do with them.\n  Object.keys(operations).forEach(function(association) {\n    operations[association].add.forEach(function(opt) {\n      determineOperation(association, opt);\n    });\n  });\n\n  return recordsToCreate;\n}\n\n\n/**\n * Create New Records.\n *\n * Given an object of association records to create, perform a create\n * on the child model and set the parent's foreign key to the newly\n * created record's primary key.\n *\n * @param {Object} parent\n * @param {Object} recordsToCreate\n * @param {Function} cb\n */\n\nfunction createNewRecords(parent, recordsToCreate, cb) {\n\n  var self = this;\n\n  // For each association, run the createRecords function\n  // in the model context.\n  function mapAssociations(association, next) {\n\n    // First, pull the model attribute's referenced (foreign) collection\n    var attribute = self.waterline.schema[self.identity].attributes[association];\n    var referencedCollection = attribute.references;\n\n    var model = self.waterline.collections[referencedCollection];\n    var records = recordsToCreate[association];\n\n    function createRunner(record, nextRecord) {\n      var args = [parent, association, record, nextRecord];\n      createRecord.apply(model, args);\n    }\n\n    async.each(records, createRunner, next);\n  }\n\n  // Create a record and set the parent's foreign key to the\n  // newly created record's primary key.\n  function createRecord(parent, association, record, next) {\n    var self = this;\n\n    this.create(record).exec(function(err, val) {\n      if (err) return next(err);\n      parent[association] = val[self.primaryKey];\n      next();\n    });\n  }\n\n\n  async.each(Object.keys(recordsToCreate), mapAssociations, cb);\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/associationMethods/add.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Add associations for a model.\n *\n * If an object was used a new record should be created and linked to the parent.\n * If only a primary key was used then the record should only be linked to the parent.\n *\n * Called in the model instance context.\n *\n * @param {Object} collection\n * @param {Object} proto\n * @param {Object} records\n * @param {Function} callback\n */\n\nvar Add = module.exports = function(collection, proto, records, cb) {\n\n  this.collection = collection;\n  this.proto = proto;\n  this.failedTransactions = [];\n  this.primaryKey = null;\n\n  var values = proto.toObject();\n  var attributes = collection.waterline.schema[collection.identity].attributes;\n\n  this.primaryKey = this.findPrimaryKey(attributes, values);\n\n  if (!this.primaryKey) {\n    return cb(new Error('No Primary Key set to associate the record with! ' +\n      'Try setting an attribute as a primary key or include an ID property.'));\n  }\n\n  if (!proto.toObject()[this.primaryKey]) {\n    return cb(new Error('No Primary Key set to associate the record with! ' +\n      'Primary Key must have a value, it can\\'t be an optional value.'));\n  }\n\n  // Loop through each of the associations on this model and add any associations\n  // that have been specified. Do this in series and limit the actual saves to 10\n  // at a time so that connection pools are not exhausted.\n  //\n  // In the future when transactions are available this will all be done on a single\n  // connection and can be re-written.\n\n  this.createCollectionAssociations(records, cb);\n};\n\n/**\n * Find Primary Key\n *\n * @param {Object} attributes\n * @param {Object} values\n * @api private\n */\n\nAdd.prototype.findPrimaryKey = function(attributes, values) {\n  var primaryKey = null;\n\n  for (var attribute in attributes) {\n    if (hasOwnProperty(attributes[attribute], 'primaryKey') && attributes[attribute].primaryKey) {\n      primaryKey = attribute;\n      break;\n    }\n  }\n\n  // If no primary key check for an ID property\n  if (!primaryKey && hasOwnProperty(values, 'id')) primaryKey = 'id';\n\n  return primaryKey;\n};\n\n/**\n * Create Collection Associations\n *\n * @param {Object} records\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.createCollectionAssociations = function(records, cb) {\n  var self = this;\n\n  async.eachSeries(Object.keys(records), function(associationKey, next) {\n    self.createAssociations(associationKey, records[associationKey], next);\n  },\n\n  function(err) {\n    if (err || self.failedTransactions.length > 0) {\n      return cb(null, self.failedTransactions);\n    }\n\n    cb();\n  });\n};\n\n/**\n * Create Records for an Association property on a collection\n *\n * @param {String} key\n * @param {Array} records\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.createAssociations = function(key, records, cb) {\n  var self = this;\n\n  // Grab the collection the attribute references\n  // this allows us to make a query on it\n  var attribute = this.collection._attributes[key];\n  var collectionName = attribute.collection.toLowerCase();\n  var associatedCollection = this.collection.waterline.collections[collectionName];\n  var relatedPK = _.find(associatedCollection.attributes, { primaryKey: true });\n  var schema = this.collection.waterline.schema[this.collection.identity].attributes[key];\n\n  // Limit Adds to 10 at a time to prevent the connection pool from being exhausted\n  async.eachLimit(records, 10, function(association, next) {\n\n    // If an object was passed in it should be created.\n    // This allows new records to be created through the association interface\n    if (association !== null && typeof association === 'object' && Object.keys(association).length > 0) {\n\n      // If a custom PK was used on the associated collection and it's not\n      // autoIncrementing, create the record. This allows nested\n      // creates to work when custom PK's are used.\n      if (!relatedPK || !relatedPK.autoIncrement && !associatedCollection.autoPK) {\n        return self.createNewRecord(associatedCollection, schema, association, key, next);\n      }\n\n      // Check if the record contains a primary key, if so just link the values\n      if (hasOwnProperty(association, associatedCollection.primaryKey)) {\n        var pk = associatedCollection.primaryKey;\n        return self.updateRecord(associatedCollection, schema, association[pk], key, next);\n      }\n\n      return self.createNewRecord(associatedCollection, schema, association, key, next);\n    }\n\n    // If the value is a primary key just update the association's foreign key\n    // This will either create the new association through a foreign key or re-associatiate\n    // with another collection.\n    self.updateRecord(associatedCollection, schema, association, key, next);\n\n  }, cb);\n};\n\n/**\n * Create A New Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.createNewRecord = function(collection, attribute, values, key, cb) {\n  var self = this;\n\n  // Check if this is a many-to-many by looking at the junctionTable flag\n  var schema = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var junctionTable = schema.junctionTable || schema.throughTable;\n\n  // If this isn't a many-to-many then add the foreign key in to the values\n  if (!junctionTable) {\n    values[attribute.onKey] = this.proto[this.primaryKey];\n  }\n\n  collection.create(values, function(err, record) {\n    if (err) {\n\n      // If no via was specified and the insert failed on a one-to-many build up an error message that\n      // properly reflects the error.\n      if (!junctionTable && !hasOwnProperty(attribute, 'via')) {\n        err = new Error('You attempted to create a has many relationship but didn\\'t link the two ' +\n          'atttributes together. Please setup a link using the via keyword.');\n      }\n\n      self.failedTransactions.push({\n        type: 'insert',\n        collection: collection.identity,\n        values: values,\n        err: err\n      });\n    }\n\n    // if no junction table then return\n    if (!junctionTable) return cb();\n\n    // if junction table but there was an error don't try and link the records\n    if (err) return cb();\n\n    // Find the collection's Primary Key value\n    var primaryKey = self.findPrimaryKey(collection._attributes, record.toObject());\n\n    if (!primaryKey) {\n      self.failedTransactions.push({\n        type: 'insert',\n        collection: collection.identity,\n        values: {},\n        err: new Error('No Primary Key value was found on the joined collection')\n      });\n    }\n\n    // Find the Many To Many Collection\n    var joinCollection = self.collection.waterline.collections[attribute.collection.toLowerCase()];\n\n    // The related record was created now the record in the junction table\n    // needs to be created to link the two records\n    self.createManyToMany(joinCollection, attribute, record[primaryKey], key, cb);\n  });\n};\n\n/**\n * Update A Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.updateRecord = function(collection, attribute, pk, key, cb) {\n  var self = this;\n\n  // Check if this is a many-to-many by looking at the junctionTable flag\n  var schema = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var junctionTable = schema.junctionTable || schema.throughTable;\n\n  // If so build out the criteria and create a new record in the junction table\n  if (junctionTable) {\n    var joinCollection = this.collection.waterline.collections[attribute.collection.toLowerCase()];\n    return this.createManyToMany(joinCollection, attribute, pk, key, cb);\n  }\n\n  // Grab the associated collection's primaryKey\n  var attributes = this.collection.waterline.schema[collection.identity].attributes;\n  var associationKey = this.findPrimaryKey(attributes, attributes);\n\n  if (!associationKey) {\n    return cb(new Error('No Primary Key defined on the child record you ' +\n      'are trying to associate the record with! Try setting an attribute as a primary key or ' +\n      'include an ID property.'));\n  }\n\n  // Build up criteria and updated values used to update the record\n  var criteria = {};\n  var _values = {};\n\n  criteria[associationKey] = pk;\n  _values[attribute.onKey] = this.proto[this.primaryKey];\n\n  collection.update(criteria, _values, function(err) {\n\n    if (err) {\n      self.failedTransactions.push({\n        type: 'update',\n        collection: collection.identity,\n        criteria: criteria,\n        values: _values,\n        err: err\n      });\n    }\n\n    cb();\n  });\n};\n\n/**\n * Create A Many To Many Join Table Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nAdd.prototype.createManyToMany = function(collection, attribute, pk, key, cb) {\n  var self = this;\n\n  // Grab the associated collection's primaryKey\n  var collectionAttributes = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var associationKeyAttr = collectionAttributes.attributes[attribute.on] || collectionAttributes.attributes[attribute.via];\n  var associationKey = associationKeyAttr.via;\n\n  // If this is a throughTable, look into the meta data cache for what key to use\n  if (collectionAttributes.throughTable) {\n    var cacheKey = collectionAttributes.throughTable[self.collection.adapter.identity + '.' + key] || collectionAttributes.throughTable[attribute.via + '.' + key];\n    if (!cacheKey) {\n      return cb(new Error('Unable to find the proper cache key in the through table definition'));\n    }\n\n    associationKey = cacheKey;\n  }\n\n  if (!associationKey) {\n    return cb(new Error('No Primary Key set on the child record you ' +\n      'are trying to associate the record with! Try setting an attribute as a primary key or ' +\n      'include an ID property.'));\n  }\n\n  // Build up criteria and updated values used to create the record\n  var criteria = {};\n  var _values = {};\n\n  criteria[associationKey] = pk;\n  criteria[attribute.onKey] = this.proto[this.primaryKey];\n  _values = _.clone(criteria);\n\n  async.auto({\n\n    validateAssociation: function(next) {\n      var associatedCollectionName = collectionAttributes.attributes[associationKey].references;\n      var associatedCollection = self.collection.waterline.collections[associatedCollectionName];\n      var primaryKey = self.findPrimaryKey(associatedCollection.attributes, {});\n      var _criteria = {};\n      _criteria[primaryKey] = pk;\n\n      associatedCollection.findOne(_criteria, function(err, record) {\n        if (err) return next(err);\n        if (!record) {\n          return next(new Error('Associated Record For ' + associatedCollectionName +\n            ' with ' + primaryKey + ' = ' + pk + ' No Longer Exists'));\n        }\n\n        next();\n      });\n    },\n\n    validateRecord: function(next) {\n\n      // First look up the record to ensure it doesn't exist\n      collection.findOne(criteria, function(err, val) {\n        if (err) {\n          return next(err);\n        }\n\n        next(null, val);\n      });\n    },\n\n    createRecord: ['validateAssociation', 'validateRecord', function(next, results) {\n      // If the record already exists, don't try and create it again to prevent\n      // duplicates.\n      var validateRecord = results.validateRecord;\n      if (validateRecord) {\n        return async.setImmediate(function() {\n          next();\n        });\n      }\n\n      collection.create(_values, next);\n    }]\n\n  }, function(err) {\n    if (err) {\n      self.failedTransactions.push({\n        type: 'insert',\n        collection: collection.identity,\n        criteria: criteria,\n        values: _values,\n        err: err\n      });\n    }\n\n    return cb();\n\n  });\n};\n\n/**\n * Find Association Key\n *\n * @param {Object} collection\n * @return {String}\n * @api private\n */\n\nAdd.prototype.findAssociationKey = function(collection) {\n  var associationKey = null;\n\n  for (var attribute in collection.attributes) {\n    var attr = collection.attributes[attribute];\n    var identity = this.collection.identity;\n\n    if (!hasOwnProperty(attr, 'references')) continue;\n    var attrCollection = attr.references;\n\n    if (attrCollection !== identity) {\n      associationKey = attr.columnName;\n    }\n  }\n\n  return associationKey;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/associationMethods/remove.js":"var _ = require('lodash');\nvar async = require('async');\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Remove associations from a model.\n *\n * Accepts a primary key value of an associated record that already exists in the database.\n *\n *\n * @param {Object} collection\n * @param {Object} proto\n * @param {Object} records\n * @param {Function} callback\n */\n\nvar Remove = module.exports = function(collection, proto, records, cb) {\n\n  this.collection = collection;\n  this.proto = proto;\n  this.failedTransactions = [];\n  this.primaryKey = null;\n\n  var values = proto.toObject();\n  var attributes = collection.waterline.schema[collection.identity].attributes;\n\n  this.primaryKey = this.findPrimaryKey(attributes, values);\n\n  if (!this.primaryKey) {\n    return cb(new Error('No Primary Key set to associate the record with! ' +\n      'Try setting an attribute as a primary key or include an ID property.'));\n  }\n\n  if (!proto.toObject()[this.primaryKey]) {\n    return cb(new Error('No Primary Key set to associate ' +\n      'the record with! Primary Key must have a value, it can\\'t be an optional value.'));\n  }\n\n  // Loop through each of the associations on this model and remove any associations\n  // that have been specified. Do this in series and limit the actual saves to 10\n  // at a time so that connection pools are not exhausted.\n  //\n  // In the future when transactions are available this will all be done on a single\n  // connection and can be re-written.\n  this.removeCollectionAssociations(records, proto, cb);\n};\n\n/**\n * Find Primary Key\n *\n * @param {Object} attributes\n * @param {Object} values\n * @api private\n */\n\nRemove.prototype.findPrimaryKey = function(attributes, values) {\n  var primaryKey = null;\n\n  for (var attribute in attributes) {\n    if (hasOwnProperty(attributes[attribute], 'primaryKey') && attributes[attribute].primaryKey) {\n      primaryKey = attribute;\n      break;\n    }\n  }\n\n  // If no primary key check for an ID property\n  if (!primaryKey && hasOwnProperty(values, 'id')) primaryKey = 'id';\n\n  return primaryKey;\n};\n\n/**\n * Remove Collection Associations\n *\n * @param {Object} records\n * @param {Function} callback\n * @api private\n */\n\nRemove.prototype.removeCollectionAssociations = function(records, proto, cb) {\n  var self = this;\n\n  async.eachSeries(_.keys(records), function(associationKey, next) {\n    self.removeAssociations(associationKey, records[associationKey], proto, next);\n  },\n\n  function(err) {\n    if (err || self.failedTransactions.length > 0) {\n      return cb(null, self.failedTransactions);\n    }\n\n    cb();\n  });\n};\n\n/**\n * Remove Associations\n *\n * @param {String} key\n * @param {Array} records\n * @param {Function} callback\n * @api private\n */\n\nRemove.prototype.removeAssociations = function(key, records, proto, cb) {\n  var self = this;\n\n  // Grab the collection the attribute references\n  // this allows us to make a query on it\n  var attribute = this.collection._attributes[key];\n  var collectionName = attribute.collection.toLowerCase();\n  var associatedCollection = this.collection.waterline.collections[collectionName];\n  var schema = this.collection.waterline.schema[this.collection.identity].attributes[key];\n\n  // Limit Removes to 10 at a time to prevent the connection pool from being exhausted\n  async.eachLimit(records, 10, function(associationId, next) {\n    self.removeRecord(associatedCollection, schema, associationId, key, proto, next);\n  }, cb);\n\n};\n\n/**\n * Remove A Single Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nRemove.prototype.removeRecord = function(collection, attribute, associationId, key, proto, cb) {\n  var self = this;\n\n  // Validate `values` is a correct primary key format\n  var validAssociationKey = this.validatePrimaryKey(associationId);\n\n  if (!validAssociationKey) {\n    this.failedTransactions.push({\n      type: 'remove',\n      collection: collection.identity,\n      values: associationId,\n      err: new Error('Remove association only accepts a single primary key value')\n    });\n\n    return cb();\n  }\n\n  // Check if this is a many-to-many by looking at the junctionTable flag\n  var schema = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var junctionTable = schema.junctionTable || schema.throughTable;\n\n  // If so build out the criteria and remove a record from the junction table\n  if (junctionTable) {\n    var joinCollection = this.collection.waterline.collections[attribute.collection.toLowerCase()];\n    return this.removeManyToMany(joinCollection, attribute, associationId, key, cb);\n  }\n\n  // Grab the associated collection's primaryKey\n  var attributes = this.collection.waterline.schema[collection.identity].attributes;\n  var associationKey = this.findPrimaryKey(attributes, attributes);\n\n  if (!associationKey) {\n    return cb(new Error('No Primary Key defined on the child record you ' +\n      'are trying to un-associate the record with! Try setting an attribute as a primary key or ' +\n      'include an ID property.'));\n  }\n\n  // Build up criteria and updated values used to update the record\n  var criteria = {};\n  var _values = {};\n\n  criteria[associationKey] = associationId;\n  criteria[attribute.on] = proto.id;\n  _values[attribute.on] = null;\n\n  collection.update(criteria, _values, function(err) {\n\n    if (err) {\n      self.failedTransactions.push({\n        type: 'update',\n        collection: collection.identity,\n        criteria: criteria,\n        values: _values,\n        err: err\n      });\n    }\n\n    cb();\n  });\n};\n\n/**\n * Validate A Primary Key\n *\n * Only support primary keys being passed in to the remove function. Check if it's a mongo\n * id or anything that has a toString method.\n *\n * @param {Integer|String} key\n * @return {Boolean}\n * @api private\n */\n\nRemove.prototype.validatePrimaryKey = function(key) {\n  var validAssociation = false;\n\n  // Attempt to see if the value is an ID and resembles a MongoID\n  if (_.isString(key) && utils.matchMongoId(key)) validAssociation = true;\n\n  // Check it can be turned into a string\n  if (key && key.toString() !== '[object Object]') validAssociation = true;\n\n  return validAssociation;\n};\n\n/**\n * Remove A Many To Many Join Table Record\n *\n * @param {Object} collection\n * @param {Object} attribute\n * @param {Object} values\n * @param {Function} callback\n * @api private\n */\n\nRemove.prototype.removeManyToMany = function(collection, attribute, pk, key, cb) {\n  var self = this;\n\n  // Grab the associated collection's primaryKey\n  var collectionAttributes = this.collection.waterline.schema[attribute.collection.toLowerCase()];\n  var associationKeyAttr = collectionAttributes.attributes[attribute.on] || collectionAttributes.attributes[attribute.via];\n  var associationKey = associationKeyAttr.via;\n\n  // If this is a throughTable, look into the meta data cache for what key to use\n  if (collectionAttributes.throughTable) {\n    var cacheKey = collectionAttributes.throughTable[self.collection.adapter.identity + '.' + key] || collectionAttributes.throughTable[attribute.via + '.' + key];\n    if (!cacheKey) {\n      return cb(new Error('Unable to find the proper cache key in the through table definition'));\n    }\n\n    associationKey = cacheKey;\n  }\n\n  if (!associationKey) {\n    return cb(new Error('No Primary Key set on the child record you ' +\n      'are trying to associate the record with! Try setting an attribute as a primary key or ' +\n      'include an ID property.'));\n  }\n\n  // Build up criteria and updated values used to create the record\n  var criteria = {};\n  criteria[associationKey] = pk;\n  criteria[attribute.on] = this.proto[this.primaryKey];\n\n  // Run a destroy on the join table record\n  collection.destroy(criteria, function(err) {\n\n    if (err) {\n      self.failedTransactions.push({\n        type: 'destroy',\n        collection: collection.identity,\n        criteria: criteria,\n        err: err\n      });\n    }\n\n    cb();\n  });\n};\n\n/**\n * Find Association Key\n *\n * @param {Object} collection\n * @return {String}\n * @api private\n */\n\nRemove.prototype.findAssociationKey = function(collection) {\n  var associationKey = null;\n\n  for (var attribute in collection.attributes) {\n    var attr = collection.attributes[attribute];\n    var identity = this.collection.identity;\n\n    if (!hasOwnProperty(attr, 'references')) continue;\n    var attrCollection = attr.references.toLowerCase();\n\n    if (attrCollection !== identity) {\n      associationKey = attr.columnName;\n    }\n  }\n\n  return associationKey;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/error/WLError.js":"var util = require('util');\nvar _ = require('lodash');\n\n/**\n * WLError\n *\n * All errors passed to a query callback in Waterline extend\n * from this base error class.\n *\n * @param  {Object} properties\n * @constructor {WLError}\n */\nfunction WLError(properties) {\n  WLError.super_.call(this);\n\n  // Fold defined properties into the new WLError instance.\n  properties || (properties = { });\n  _.extend(this, properties);\n\n  // Generate stack trace\n  // (or use `originalError` if it is a true error instance)\n  if (_.isObject(this.originalError) && this.originalError instanceof Error) {\n    this._e = this.originalError;\n  } else {\n    this._e = new Error();\n  }\n\n  // Doctor up a modified version of the stack trace called `rawStack`:\n  this.rawStack = (this._e.stack.replace(/^Error(\\r|\\n)*(\\r|\\n)*/, ''));\n\n  // Customize `details`:\n  // Try to dress up the wrapped \"original\" error as much as possible.\n  // @type {String} a detailed explanation of this error\n  if (_.isString(this.originalError)) {\n    this.details = this.originalError;\n\n  // Run toString() on Errors:\n  } else if (this.originalError && util.isError(this.originalError)) {\n    this.details = this.originalError.toString();\n\n  // But for other objects, use util.inspect()\n  } else if (this.originalError) {\n    this.details = util.inspect(this.originalError);\n  }\n\n  // If `details` is set, prepend it with \"Details:\"\n  if (this.details) {\n    this.details = 'Details:  ' + this.details + '\\n';\n  }\n}\n\nutil.inherits(WLError, Error);\n\n// Default properties\nWLError.prototype.status = 500;\nWLError.prototype.code = 'E_UNKNOWN';\nWLError.prototype.reason = 'Encountered an unexpected error';\nWLError.prototype.details = '';\n\n/**\n * Override JSON serialization.\n * (i.e. when this error is passed to `res.json()` or `JSON.stringify`)\n *\n * For example:\n * ```json\n * {\n *   status: 500,\n *   code: 'E_UNKNOWN'\n * }\n * ```\n *\n * @return {Object}\n */\nWLError.prototype.toJSON =\nWLError.prototype.toPOJO =\nfunction() {\n  var obj = {\n    error: this.code,\n    status: this.status,\n    summary: this.reason,\n    raw: this.originalError\n  };\n\n  // Only include `raw` if its truthy.\n  if (!obj.raw) delete obj.raw;\n\n  return obj;\n};\n\n/**\n * Override output for `sails.log[.*]`\n *\n * @return {String}\n *\n * For example:\n * ```sh\n * Waterline: ORM encountered an unexpected error:\n * { ValidationError: { name: [ [Object], [Object] ] } }\n * ```\n */\nWLError.prototype.toLog = function() {\n  return this.inspect();\n};\n\n/**\n * Override output for `util.inspect`\n * (also when this error is logged using `console.log`)\n *\n * @return {String}\n */\nWLError.prototype.inspect = function() {\n  return util.format('Error (%s) :: %s\\n%s\\n\\n%s', this.code, this.reason, this.rawStack, this.details);\n};\n\n/**\n * @return {String}\n */\nWLError.prototype.toString = function() {\n  return util.format('[Error (%s) %s]', this.code, this.reason, this.details);\n};\n\nObject.defineProperties(WLError.prototype, {\n  stack: {\n    enumerable: true,\n    get: function() {\n      return util.format('Error (%s) :: %s\\n%s', this.code, this.reason, this.rawStack);\n    },\n    set: function(value) {\n      this.rawStack = value;\n    }\n  },\n  message: {\n    enumerable: true,\n    get: function() {\n      return this.rawMessage || this.toString();\n    },\n    set: function(value) {\n      this.rawMessage = value;\n    }\n  }\n});\n\nmodule.exports = WLError;\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/internalMethods/index.js":"\n/**\n * Export Internal Methods\n */\n\nmodule.exports = {\n  normalizeAssociations: require('./normalizeAssociations'),\n  defineAssociations: require('./defineAssociations')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/internalMethods/normalizeAssociations.js":"\n/**\n * Check and normalize belongs_to and has_many association keys\n *\n * Ensures that a belongs_to association is an object and that a has_many association\n * is an array.\n *\n * @param {Object} context,\n * @param {Object} proto\n * @api private\n */\n\nvar Normalize = module.exports = function(context, proto) {\n\n  this.proto = proto;\n\n  var attributes = context.waterline.collections[context.identity].attributes || {};\n\n  this.collections(attributes);\n  this.models(attributes);\n};\n\n/**\n * Normalize Collection Attribute to Array\n *\n * @param {Object} attributes\n * @api private\n */\n\nNormalize.prototype.collections = function(attributes) {\n  for (var attribute in attributes) {\n\n    // If attribute is not a collection, it doesn't need normalizing\n    if (!attributes[attribute].collection) continue;\n\n    // Sets the attribute as an array if it's not already\n    if (this.proto[attribute] && !Array.isArray(this.proto[attribute])) {\n      this.proto[attribute] = [this.proto[attribute]];\n    }\n  }\n};\n\n/**\n * Normalize Model Attribute to Object\n *\n * @param {Object} attributes\n * @api private\n */\n\nNormalize.prototype.models = function(attributes) {\n  for (var attribute in attributes) {\n\n    // If attribute is not a model, it doesn't need normalizing\n    if (!attributes[attribute].model) continue;\n\n    // Sets the attribute to the first item in the array if it's an array\n    if (this.proto[attribute] && Array.isArray(this.proto[attribute])) {\n      this.proto[attribute] = this.proto[attribute][0];\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/internalMethods/defineAssociations.js":"\n/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar Association = require('../association');\nvar utils = require('../../../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Add association getters and setters for any has_many\n * attributes.\n *\n * @param {Object} context\n * @param {Object} proto\n * @api private\n */\n\nvar Define = module.exports = function(context, proto) {\n  var self = this;\n\n  this.proto = proto;\n\n  // Build Associations Listing\n  Object.defineProperty(proto, 'associations', {\n    enumerable: false,\n    writable: true,\n    value: {}\n  });\n\n  // Build associations cache to hold original values.\n  // Used to check if values have been mutated and need to be synced when\n  // a model.save call is made.\n  Object.defineProperty(proto, 'associationsCache', {\n    enumerable: false,\n    writable: true,\n    value: {}\n  });\n\n  var attributes = context._attributes || {};\n  var collections = this.collectionKeys(attributes);\n  var models = this.modelKeys(attributes);\n\n  if (collections.length === 0 && models.length === 0) return;\n\n  // Create an Association getter and setter for each collection\n  collections.forEach(function(collection) {\n    self.buildHasManyProperty(collection);\n  });\n\n  // Attach Models to the prototype and set in the associations object\n  models.forEach(function(model) {\n    self.buildBelongsToProperty(model);\n  });\n};\n\n/**\n * Find Collection Keys\n *\n * @param {Object} attributes\n * @api private\n * @return {Array}\n */\n\nDefine.prototype.collectionKeys = function(attributes) {\n  var collections = [];\n\n  // Find any collection keys\n  for (var attribute in attributes) {\n    if (!hasOwnProperty(attributes[attribute], 'collection')) continue;\n    collections.push(_.cloneDeep(attribute));\n  }\n\n  return collections;\n};\n\n/**\n * Find Model Keys\n *\n * @param {Object} attributes\n * @api private\n * @return {Array}\n */\n\nDefine.prototype.modelKeys = function(attributes) {\n  var models = [];\n\n  // Find any collection keys\n  for (var attribute in attributes) {\n    if (!hasOwnProperty(attributes[attribute], 'model')) continue;\n    models.push({ key: _.cloneDeep(attribute), val: _.cloneDeep(attributes[attribute]) });\n  }\n\n  return models;\n};\n\n/**\n * Create Getter/Setter for hasMany associations\n *\n * @param {String} collection\n * @api private\n */\n\nDefine.prototype.buildHasManyProperty = function(collection) {\n  var self = this;\n\n  // Attach to a non-enumerable property\n  this.proto.associations[collection] = new Association();\n\n  // Attach getter and setter to the model\n  Object.defineProperty(this.proto, collection, {\n    set: function(val) { self.proto.associations[collection]._setValue(val); },\n    get: function() { return self.proto.associations[collection]._getValue(); },\n    enumerable: true,\n    configurable: true\n  });\n};\n\n/**\n * Add belongsTo attributes to associations object\n *\n * @param {String} collection\n * @api private\n */\n\nDefine.prototype.buildBelongsToProperty = function(model) {\n\n  // Attach to a non-enumerable property\n  this.proto.associations[model.key] = model.val;\n\n  // Build a cache for this model\n  this.proto.associationsCache[model.key] = {};\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/model/lib/association.js":"\n/**\n * Handles an Association\n */\n\nvar Association = module.exports = function() {\n  this.addModels = [];\n  this.removeModels = [];\n  this.value = [];\n};\n\n/**\n * Set Value\n *\n * @param {Number|Object} value\n * @api private\n */\n\nAssociation.prototype._setValue = function(value) {\n  if (Array.isArray(value)) {\n    this.value = value;\n    return;\n  }\n\n  this.value = this.value = [value];\n};\n\n/**\n * Get Value\n *\n * @api private\n */\n\nAssociation.prototype._getValue = function() {\n  var self = this;\n  var value = this.value;\n\n  // Attach association methods to values array\n  // This allows access using the getter and the desired\n  // API for synchronously adding and removing associations.\n\n  value.add = function add(obj) {\n    if (Array.isArray(obj)) {\n      obj.forEach(function(el) {\n        self.addModels.push(el);\n      });\n    } else {\n      self.addModels.push(obj);\n    }\n  };\n\n  value.remove = function remove(obj) {\n    if (Array.isArray(obj)) {\n      obj.forEach(function(el) {\n        self.removeModels.push(el);\n      });\n    } else {\n      self.removeModels.push(obj);\n    }\n  };\n\n  return value;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/core/typecast.js":"/**\n * Module dependencies\n */\n\nvar types = require('../utils/types');\nvar utils = require('../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\nvar _ = require('lodash');\n\n/**\n * Cast Types\n *\n * Will take values and cast they to the correct type based on the\n * type defined in the schema.\n *\n * Especially handy for converting numbers passed as strings to the\n * correct integer type.\n *\n * Should be run before sending values to an adapter.\n */\n\nvar Cast = module.exports = function() {\n  this._types = {};\n\n  return this;\n};\n\n/**\n * Builds an internal _types object that contains each\n * attribute with it's type. This can later be used to\n * transform values into the correct type.\n *\n * @param {Object} attrs\n */\n\nCast.prototype.initialize = function(attrs) {\n  var self = this;\n\n  Object.keys(attrs).forEach(function(key) {\n    self._types[key] = ~types.indexOf(attrs[key].type) ? attrs[key].type : 'string';\n  });\n};\n\n/**\n * Converts a set of values into the proper types\n * based on the Collection's schema.\n *\n * @param {Object} values\n * @return {Object}\n * @api public\n */\n\nCast.prototype.run = function(values) {\n  var self = this;\n\n  if (values === undefined || values === null) {\n    return;\n  }\n\n  Object.keys(values).forEach(function(key) {\n\n    // Set undefined to null\n    if (_.isUndefined(values[key])) values[key] = null;\n    if (!hasOwnProperty(self._types, key) || values[key] === null || !hasOwnProperty(values, key)) {\n      return;\n    }\n\n    // If the value is a plain object, don't attempt to cast it\n    if (_.isPlainObject(values[key])) return;\n\n    // Find the value's type\n    var type = self._types[key];\n\n    // Casting Function\n    switch (type) {\n      case 'string':\n      case 'text':\n        values[key] = self.string(values[key]);\n        break;\n\n      case 'integer':\n        values[key] = self.integer(key, values[key]);\n        break;\n\n      case 'float':\n        values[key] = self.float(values[key]);\n        break;\n\n      case 'date':\n      case 'time':\n      case 'datetime':\n        values[key] = self.date(values[key]);\n        break;\n\n      case 'boolean':\n        values[key] = self.boolean(values[key]);\n        break;\n\n      case 'array':\n        values[key] = self.array(values[key]);\n        break;\n    }\n  });\n\n  return values;\n};\n\n/**\n * Cast String Values\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nCast.prototype.string = function string(str) {\n  return typeof str.toString !== 'undefined' ? str.toString() : '' + str;\n};\n\n/**\n * Cast Integer Values\n *\n * @param {String} key\n * @param {Integer} value\n * @return {Integer}\n * @api private\n */\n\nCast.prototype.integer = function integer(key, value) {\n  var _value;\n\n  // Attempt to see if the value is resembles a MongoID\n  // if so let's not try and cast it and instead return a string representation of\n  // it. Needed for sails-mongo.\n  if (utils.matchMongoId(value)) return value.toString();\n\n  // Attempt to parseInt\n  try {\n    _value = parseInt(value, 10);\n  } catch(e) {\n    return value;\n  }\n\n  return _value;\n};\n\n/**\n * Cast Float Values\n *\n * @param {Float} value\n * @return {Float}\n * @api private\n */\n\nCast.prototype.float = function float(value) {\n  var _value;\n\n  try {\n    _value = parseFloat(value);\n  } catch(e) {\n    return value;\n  }\n\n  return _value;\n};\n\n/**\n * Cast Boolean Values\n *\n * @param {Boolean} value\n * @return {Boolean}\n * @api private\n */\n\nCast.prototype.boolean = function boolean(value) {\n  var parsed;\n\n  if (_.isString(value)) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value;\n  }\n\n  // Nicely cast [0, 1] to true and false\n  try {\n    parsed = parseInt(value, 10);\n  } catch(e) {\n    return false;\n  }\n\n  if (parsed === 0) return false;\n  if (parsed === 1) return true;\n\n  return value;\n};\n\n/**\n * Cast Date Values\n *\n * @param {String|Date} value\n * @return {Date}\n * @api private\n */\n\nCast.prototype.date = function date(value) {\n  var _value;\n  if (value.__proto__ == Date.prototype) {\n    _value = new Date(value.getTime());\n  } else if (typeof value.toDate === 'function') {\n    _value = value.toDate();\n  } else {\n    _value = new Date(Date.parse(value));\n  }\n\n  if (_value.toString() === 'Invalid Date') return value;\n  return _value;\n};\n\n/**\n * Cast Array Values\n *\n * @param {Array|String} value\n * @return {Array}\n * @api private\n */\n\nCast.prototype.array = function array(value) {\n  if (Array.isArray(value)) return value;\n  return [value];\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/core/schema.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar types = require('../utils/types');\nvar utils = require('../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Builds a Schema Object from an attributes\n * object in a model.\n *\n * Loops through an attributes object to build a schema\n * containing attribute name as key and a type for casting\n * in the database. Also includes a default value if supplied.\n *\n * Example:\n *\n * attributes: {\n *   name: 'string',\n *   phone: {\n *     type: 'string',\n *     defaultsTo: '555-555-5555'\n *   }\n * }\n *\n * Returns: {\n *   name: { type: 'string' },\n *   phone: { type: 'string, defaultsTo: '555-555-5555' }\n * }\n *\n * @param {Object} context\n * @return {Object}\n */\n\nvar Schema = module.exports = function(context) {\n  this.context = context || {};\n  this.schema = {};\n\n  return this;\n};\n\n/**\n * Initialize the internal schema object\n *\n * @param {Object} attrs\n * @param {Object} associations\n * @param {Boolean} hasSchema\n */\n\nSchema.prototype.initialize = function(attrs, hasSchema, reservedAttributes) {\n  var self = this;\n\n  // Build normal attributes\n  Object.keys(attrs).forEach(function(key) {\n    if (hasOwnProperty(attrs[key], 'collection')) return;\n    self.schema[key] = self.objectAttribute(key, attrs[key]);\n  });\n\n  // Build Reserved Attributes\n  if (Array.isArray(reservedAttributes)) {\n    reservedAttributes.forEach(function(key) {\n      self.schema[key] = {};\n    });\n  }\n\n  // Set hasSchema to determine if values should be cleansed or not\n  this.hasSchema = typeof hasSchema !== 'undefined' ? hasSchema : true;\n};\n\n/**\n * Handle the building of an Object attribute\n *\n * Cleans any unnecessary attributes such as validation properties off of\n * the internal schema and set's defaults for incorrect values.\n *\n * @param {Object} value\n * @return {Object}\n */\n\nSchema.prototype.objectAttribute = function(attrName, value) {\n  var attr = {};\n\n  for (var key in value) {\n    switch (key) {\n\n      // Set schema[attribute].type\n      case 'type':\n        // Allow validation types in attributes and transform them to strings\n        attr.type = ~types.indexOf(value[key]) ? value[key] : 'string';\n        break;\n\n      // Set schema[attribute].defaultsTo\n      case 'defaultsTo':\n        attr.defaultsTo = value[key];\n        break;\n\n      // Set schema[attribute].primaryKey\n      case 'primaryKey':\n        attr.primaryKey = value[key];\n        attr.unique = true;\n        break;\n\n      // Set schema[attribute].foreignKey\n      case 'foreignKey':\n        attr.foreignKey = value[key];\n        break;\n\n      // Set schema[attribute].references\n      case 'references':\n        attr.references = value[key];\n        break;\n\n      // Set schema[attribute].on\n      case 'on':\n        attr.on = value[key];\n        break;\n\n      // Set schema[attribute].via\n      case 'via':\n        attr.via = value[key];\n        break;\n\n      // Set schema[attribute].autoIncrement\n      case 'autoIncrement':\n        attr.autoIncrement = value[key];\n        attr.type = 'integer';\n        break;\n\n      // Set schema[attribute].unique\n      case 'unique':\n        attr.unique = value[key];\n        break;\n\n      // Set schema[attribute].index\n      case 'index':\n        attr.index = value[key];\n        break;\n\n      // Set schema[attribute].enum\n      case 'enum':\n        attr.enum = value[key];\n        break;\n\n      // Set schema[attribute].size\n      case 'size':\n        attr.size = value[key];\n        break;\n\n      // Set schema[attribute].notNull\n      case 'notNull':\n        attr.notNull = value[key];\n        break;\n\n      // Handle Belongs To Attributes\n      case 'model':\n        var type;\n        var attrs = this.context.waterline.schema[value[key].toLowerCase()].attributes;\n\n        for (var attribute in attrs) {\n          if (hasOwnProperty(attrs[attribute], 'primaryKey') && attrs[attribute].primaryKey) {\n            type = attrs[attribute].type;\n            break;\n          }\n        }\n\n        attr.type = type.toLowerCase();\n        attr.model = value[key].toLowerCase();\n        attr.foreignKey = true;\n        attr.alias = attrName;\n        break;\n    }\n  }\n\n  return attr;\n};\n\n\n/**\n * Clean Values\n *\n * Takes user inputted data and strips out any values not defined in\n * the schema.\n *\n * This is run after all the validations and right before being sent to the\n * adapter. This allows you to add temporary properties when doing validation\n * callbacks and have them stripped before being sent to the database.\n *\n * @param {Object} values to clean\n * @return {Object} clone of values, stripped of any extra properties\n */\n\nSchema.prototype.cleanValues = function(values) {\n\n  var clone = {};\n\n  for (var key in values) {\n\n    // The value can pass through if either the collection does have a schema and the key is in the schema,\n    // or otherwise if the collection is schemaless and the key does not represent an associated collection.\n    if ((this.hasSchema && hasOwnProperty(this.schema, key)) ||\n        (!this.hasSchema && !(hasOwnProperty(this.context._attributes, key) && hasOwnProperty(this.context._attributes[key], 'collection')))) {\n\n      clone[key] = values[key];\n    }\n\n  }\n\n  return clone;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/core/dictionary.js":"var _ = require('lodash');\n\n/**\n * Handle Building an Adapter/Connection dictionary\n *\n * @param {Object} connections\n * @param {Array} ordered\n * @return {Object}\n * @api public\n *\n * Manages a 'dictionary' object of the following structure:\n * {\n *    CONNECTION: {\n *      METHOD: ADAPTER_NAME\n *    }\n * }\n */\nvar Dictionary = module.exports = function(connections, ordered) {\n  this.dictionary = this._build(connections);\n  return this._smash(ordered);\n};\n\n/**\n * Build Dictionary. This maps adapter methods to the effective connection\n * for which the method is pertinent.\n *\n * @param {Object} connections\n * @api private\n */\nDictionary.prototype._build = function _build(connections) {\n  return _.mapValues(connections, function(connection, connectionName) {\n    var adapter = connection._adapter || { };\n\n    return _.mapValues(adapter, function(method) {\n      return connectionName;\n    });\n  });\n};\n\n/**\n * Combine Dictionary into a single level object.\n *\n * Appends methods from other adapters onto the left most connection adapter,\n * but does not override any existing methods defined in the leftmost adapter.\n *\n * @param {Array} ordered\n * @return {Object}\n * @api private\n */\nDictionary.prototype._smash = function _smash(ordered) {\n  var mergeArguments = _.map((ordered || [ ]).reverse(), function(adapterName) {\n    return this.dictionary[adapterName];\n  }, this);\n\n  return _.merge.apply(null, mergeArguments);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/core/validations.js":"/**\n * Handles validation on a model\n *\n * Uses Anchor for validating\n * https://github.com/balderdashy/anchor\n */\n\nvar _ = require('lodash');\nvar anchor = require('anchor');\nvar async = require('async');\nvar utils = require('../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\nvar WLValidationError = require('../error/WLValidationError');\n\n\n/**\n * Build up validations using the Anchor module.\n *\n * @param {String} adapter\n */\n\nvar Validator = module.exports = function(adapter) {\n  this.validations = {};\n};\n\n/**\n * Builds a Validation Object from a normalized attributes\n * object.\n *\n * Loops through an attributes object to build a validation object\n * containing attribute name as key and a series of validations that\n * are run on each model. Skips over type and defaultsTo as they are\n * schema properties.\n *\n * Example:\n *\n * attributes: {\n *   name: {\n *     type: 'string',\n *     length: { min: 2, max: 5 }\n *   }\n *   email: {\n *     type: 'string',\n *     required: true\n *   }\n * }\n *\n * Returns: {\n *   name: { length: { min:2, max: 5 }},\n *   email: { required: true }\n * }\n */\n\nValidator.prototype.initialize = function(attrs, types, defaults) {\n  var self = this;\n\n  defaults = defaults || {};\n\n  this.reservedProperties = ['defaultsTo', 'primaryKey', 'autoIncrement', 'unique', 'index', 'collection', 'dominant', 'through',\n          'columnName', 'foreignKey', 'references', 'on', 'groupKey', 'model', 'via', 'size',\n          'example', 'validationMessage', 'validations', 'populateSettings', 'onKey', 'protected'];\n\n\n  if (defaults.ignoreProperties && Array.isArray(defaults.ignoreProperties)) {\n    this.reservedProperties = this.reservedProperties.concat(defaults.ignoreProperties);\n  }\n\n  // Add custom type definitions to anchor\n  types = types || {};\n  anchor.define(types);\n\n  Object.keys(attrs).forEach(function(attr) {\n    self.validations[attr] = {};\n\n    Object.keys(attrs[attr]).forEach(function(prop) {\n\n      // Ignore null values\n      if (attrs[attr][prop] === null) { return; }\n\n      // If property is reserved don't do anything with it\n      if (self.reservedProperties.indexOf(prop) > -1) { return; }\n\n      // use the Anchor `in` method for enums\n      if (prop === 'enum') {\n        self.validations[attr]['in'] = attrs[attr][prop];\n        return;\n      }\n\n      self.validations[attr][prop] = attrs[attr][prop];\n    });\n  });\n};\n\n\n/**\n * Validator.prototype.validate()\n *\n * Accepts a dictionary of values and validates them against\n * the validation rules expected by this schema (`this.validations`).\n * Validation is performed using Anchor.\n *\n *\n * @param {Dictionary} values\n *        The dictionary of values to validate.\n *\n * @param {Boolean|String|String[]} presentOnly\n *        only validate present values (if `true`) or validate the\n *        specified attribute(s).\n *\n * @param {Function} callback\n *        @param {Error} err - a fatal error, if relevant.\n *        @param {Array} invalidAttributes - an array of errors\n */\n\nValidator.prototype.validate = function(values, presentOnly, cb) {\n  var self = this;\n  var errors = {};\n  var validations = Object.keys(this.validations);\n\n  // Handle optional second arg AND Use present values only, specified values, or all validations\n  /* eslint-disable no-fallthrough */\n  switch (typeof presentOnly) {\n    case 'function':\n      cb = presentOnly;\n      break;\n    case 'string':\n      validations = [presentOnly];\n      break;\n    case 'object':\n      if (Array.isArray(presentOnly)) {\n        validations = presentOnly;\n        break;\n      } // Fall through to the default if the object is not an array\n    default:\n      // Any other truthy value.\n      if (presentOnly) {\n        validations = _.intersection(validations, Object.keys(values));\n      }\n    /* eslint-enable no-fallthrough */\n  }\n\n\n  // Validate all validations in parallel\n  async.each(validations, function _eachValidation(validation, cb) {\n    var curValidation = self.validations[validation];\n\n    // Build Requirements\n    var requirements;\n    try {\n      requirements = anchor(curValidation);\n    }\n    catch (e) {\n      // Handle fatal error:\n      return cb(e);\n    }\n    requirements = _.cloneDeep(requirements);\n\n    // Grab value and set to null if undefined\n    var value = values[validation];\n    if (typeof value == 'undefined') {\n      value = null;\n    }\n\n    // If value is not required and empty then don't\n    // try and validate it\n    if (!curValidation.required) {\n      if (value === null || value === '') {\n        return cb();\n      }\n    }\n\n    // If Boolean and required manually check\n    if (curValidation.required && curValidation.type === 'boolean' && (typeof value !== 'undefined' && value !== null)) {\n      if (value.toString() === 'true' || value.toString() === 'false') {\n        return cb();\n      }\n    }\n\n    // If type is integer and the value matches a mongoID let it validate\n    if (hasOwnProperty(self.validations[validation], 'type') && self.validations[validation].type === 'integer') {\n      if (utils.matchMongoId(value)) {\n        return cb();\n      }\n    }\n\n    // Rule values may be specified as sync or async functions.\n    // Call them and replace the rule value with the function's result\n    // before running validations.\n    async.each(Object.keys(requirements.data), function _eachKey(key, next) {\n      try {\n        if (typeof requirements.data[key] !== 'function') {\n          return next();\n        }\n\n        // Run synchronous function\n        if (requirements.data[key].length < 1) {\n          requirements.data[key] = requirements.data[key].apply(values, []);\n          return next();\n        }\n\n        // Run async function\n        requirements.data[key].call(values, function(result) {\n          requirements.data[key] = result;\n          next();\n        });\n      }\n      catch (e) {\n        return next(e);\n      }\n    }, function afterwards(unexpectedErr) {\n      if (unexpectedErr) {\n        // Handle fatal error\n        return cb(unexpectedErr);\n      }\n\n      // If the value has a dynamic required function and it evaluates to false lets look and see\n      // if the value supplied is null or undefined. If so then we don't need to check anything. This\n      // prevents type errors like `undefined` should be a string.\n      // if required is set to 'false', don't enforce as required rule\n      if (requirements.data.hasOwnProperty('required') && !requirements.data.required) {\n        if (_.isNull(value)) {\n          return cb();\n        }\n      }\n\n      // Now run the validations using Anchor.\n      var validationError;\n      try {\n        validationError = anchor(value).to(requirements.data, values);\n      }\n      catch (e) {\n        // Handle fatal error:\n        return cb(e);\n      }\n\n      // If no validation errors, bail.\n      if (!validationError) {\n        return cb();\n      }\n\n      // Build an array of errors.\n      errors[validation] = [];\n\n      validationError.forEach(function(obj) {\n        if (obj.property) {\n          delete obj.property;\n        }\n        errors[validation].push({ rule: obj.rule, message: obj.message });\n      });\n\n      return cb();\n    });\n\n  }, function allValidationsChecked(err) {\n    // Handle fatal error:\n    if (err) {\n      return cb(err);\n    }\n\n\n    if (Object.keys(errors).length === 0) {\n      return cb();\n    }\n\n    return cb(undefined, errors);\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/error/WLValidationError.js":"/**\n * Module dependencies\n */\n\nvar WLError = require('./WLError');\nvar WLUsageError = require('./WLUsageError');\nvar util = require('util');\nvar _ = require('lodash');\n\n\n/**\n * WLValidationError\n *\n * @extends WLError\n */\nfunction WLValidationError(properties) {\n\n  // Call superclass\n  WLValidationError.super_.call(this, properties);\n\n  // Ensure valid usage\n  if (typeof this.invalidAttributes !== 'object') {\n    return new WLUsageError({\n      reason: 'An `invalidAttributes` object must be passed into the constructor for `WLValidationError`'\n    });\n  }\n  // if ( typeof this.model !== 'string' ) {\n  //   return new WLUsageError({\n  //     reason: 'A `model` string (the collection\\'s `globalId`) must be passed into the constructor for `WLValidationError`'\n  //   });\n  // }\n\n  // Customize the `reason` based on the # of invalid attributes\n  // (`reason` may not be overridden)\n  var isSingular = this.length === 1;\n  this.reason = util.format('%d attribute%s %s invalid',\n    this.length,\n    isSingular ? '' : 's',\n    isSingular ? 'is' : 'are');\n\n  // Always apply the 'E_VALIDATION' error code, even if it was overridden.\n  this.code = 'E_VALIDATION';\n\n  // Status may be overridden.\n  this.status = properties.status || 400;\n\n  // Model should always be set.\n  // (this should be the globalId of model, or \"collection\")\n  this.model = properties.model;\n\n  // Ensure messages exist for each invalidAttribute\n  this.invalidAttributes = _.mapValues(this.invalidAttributes, function(rules, attrName) {\n    return _.map(rules, function(rule) {\n      if (!rule.message) {\n        rule.message = util.format('A record with that `%s` already exists (`%s`).', attrName, rule.value);\n      }\n      return rule;\n    });\n  });\n\n  // Customize the `details`\n  this.details = util.format('Invalid attributes sent to %s:\\n', this.model) +\n  _.reduce(this.messages, function(memo, messages, attrName) {\n    memo += ' • ' + attrName + '\\n';\n    memo += _.reduce(messages, function(memo, message) {\n      memo += '   • ' + message + '\\n';\n      return memo;\n    }, '');\n    return memo;\n  }, '');\n\n}\nutil.inherits(WLValidationError, WLError);\n\n\n/**\n * `rules`\n *\n * @return {Object[Array[String]]} dictionary of validation rule ids, indexed by attribute\n */\nWLValidationError.prototype.__defineGetter__('rules', function() {\n  return _.mapValues(this.invalidAttributes, function(rules, attrName) {\n    return _.pluck(rules, 'rule');\n  });\n});\n\n\n/**\n * `messages` (aka `errors`)\n *\n * @return {Object[Array[String]]} dictionary of validation messages, indexed by attribute\n */\nWLValidationError.prototype.__defineGetter__('messages', function() {\n  return _.mapValues(this.invalidAttributes, function(rules, attrName) {\n    return _.pluck(rules, 'message');\n  });\n});\nWLValidationError.prototype.__defineGetter__('errors', function() {\n  return this.messages;\n});\n\n\n/**\n * `attributes` (aka `keys`)\n *\n * @return {Array[String]} of invalid attribute names\n */\nWLValidationError.prototype.__defineGetter__('attributes', function() {\n  return _.keys(this.invalidAttributes);\n});\nWLValidationError.prototype.__defineGetter__('keys', function() {\n  return this.attributes;\n});\n\n\n/**\n * `.length`\n *\n * @return {Integer} number of invalid attributes\n */\nWLValidationError.prototype.__defineGetter__('length', function() {\n  return this.attributes.length;\n});\n\n\n/**\n * `.ValidationError`\n * (backwards-compatibility)\n *\n * @return {Object[Array[Object]]} number of invalid attributes\n */\nWLValidationError.prototype.__defineGetter__('ValidationError', function() {\n  //\n  // TODO:\n  // Down the road- emit deprecation event here--\n  // (will log information about new error handling options)\n  //\n  return this.invalidAttributes;\n});\n\n\n/**\n * [toJSON description]\n * @type {[type]}\n */\nWLValidationError.prototype.toJSON =\nWLValidationError.prototype.toPOJO =\nfunction() {\n  return {\n    error: this.code,\n    status: this.status,\n    summary: this.reason,\n    model: this.model,\n    invalidAttributes: this.invalidAttributes\n  };\n};\n\n\nmodule.exports = WLValidationError;\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/error/WLUsageError.js":"/**\n * Module dependencies\n */\n\nvar WLError = require('./WLError');\nvar util = require('util');\n\n\n/**\n * WLUsageError\n *\n * @extends WLError\n */\nfunction WLUsageError(properties) {\n\n  // Call superclass\n  WLUsageError.super_.call(this, properties);\n}\nutil.inherits(WLUsageError, WLError);\n\n\n// Override WLError defaults with WLUsageError properties.\nWLUsageError.prototype.code =\n'E_USAGE';\nWLUsageError.prototype.status =\n0;\nWLUsageError.prototype.reason =\n'Invalid usage';\n\n\nmodule.exports = WLUsageError;\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/core/transformations.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('../utils/helpers');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Transformation\n *\n * Allows for a Waterline Collection to have different\n * attributes than what actually exist in an adater's representation.\n *\n * @param {Object} attributes\n * @param {Object} tables\n */\n\nvar Transformation = module.exports = function(attributes, tables) {\n\n  // Hold an internal mapping of keys to transform\n  this._transformations = {};\n\n  // Initialize\n  this.initialize(attributes, tables);\n\n  return this;\n};\n\n/**\n * Initial mapping of transformations.\n *\n * @param {Object} attributes\n * @param {Object} tables\n */\n\nTransformation.prototype.initialize = function(attributes, tables) {\n  var self = this;\n\n  Object.keys(attributes).forEach(function(attr) {\n\n    // Ignore Functions and Strings\n    if (['function', 'string'].indexOf(typeof attributes[attr]) > -1) return;\n\n    // If not an object, ignore\n    if (attributes[attr] !== Object(attributes[attr])) return;\n\n    // Loop through an attribute and check for transformation keys\n    Object.keys(attributes[attr]).forEach(function(key) {\n\n      // Currently just works with `columnName`, `collection`, `groupKey`\n      if (key !== 'columnName') return;\n\n      // Error if value is not a string\n      if (typeof attributes[attr][key] !== 'string') {\n        throw new Error('columnName transformation must be a string');\n      }\n\n      // Set transformation attr to new key\n      if (key === 'columnName') {\n        if (attr === attributes[attr][key]) return;\n        self._transformations[attr] = attributes[attr][key];\n      }\n\n    });\n  });\n};\n\n/**\n * Transforms a set of attributes into a representation used\n * in an adapter.\n *\n * @param {Object} attributes to transform\n * @return {Object}\n */\n\nTransformation.prototype.serialize = function(attributes, behavior) {\n  var self = this;\n  var values = _.clone(attributes);\n\n  behavior = behavior || 'default';\n\n  function recursiveParse(obj) {\n\n    // Return if no object\n    if (!obj) return;\n\n    // Handle array of types for findOrCreateEach\n    if (typeof obj === 'string') {\n      if (hasOwnProperty(self._transformations, obj)) {\n        values = self._transformations[obj];\n        return;\n      }\n\n      return;\n    }\n\n    Object.keys(obj).forEach(function(property) {\n\n      // Just a double check to exit if hasOwnProperty fails\n      if (!hasOwnProperty(obj, property)) return;\n\n      // Schema must be serialized in first level only\n      if (behavior === 'schema') {\n        if (hasOwnProperty(self._transformations, property)) {\n          obj[self._transformations[property]] = _.clone(obj[property]);\n          delete obj[property];\n        }\n        return;\n      }\n\n      // Recursively parse `OR` criteria objects to transform keys\n      if (Array.isArray(obj[property]) && property === 'or') return recursiveParse(obj[property]);\n\n      // If Nested Object call function again passing the property as obj\n      if ((toString.call(obj[property]) !== '[object Date]') && (_.isPlainObject(obj[property]))) {\n\n        // check if object key is in the transformations\n        if (hasOwnProperty(self._transformations, property)) {\n          obj[self._transformations[property]] = _.clone(obj[property]);\n          delete obj[property];\n\n          return recursiveParse(obj[self._transformations[property]]);\n        }\n\n        return recursiveParse(obj[property]);\n      }\n\n      // Check if property is a transformation key\n      if (hasOwnProperty(self._transformations, property)) {\n\n        obj[self._transformations[property]] = obj[property];\n        delete obj[property];\n      }\n    });\n  }\n\n  // Recursivly parse attributes to handle nested criteria\n  recursiveParse(values);\n\n  return values;\n};\n\n/**\n * Transforms a set of attributes received from an adapter\n * into a representation used in a collection.\n *\n * @param {Object} attributes to transform\n * @return {Object}\n */\n\nTransformation.prototype.unserialize = function(attributes) {\n  var self = this;\n  var values = _.clone(attributes);\n\n  // Loop through the attributes and change them\n  Object.keys(this._transformations).forEach(function(key) {\n    var transformed = self._transformations[key];\n\n    if (!hasOwnProperty(attributes, transformed)) return;\n\n    values[key] = attributes[transformed];\n    if (transformed !== key) delete values[transformed];\n  });\n\n  return values;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/index.js":"/**\n * Dependencies\n */\n\nvar _ = require('lodash');\nvar extend = require('../utils/extend');\nvar AdapterBase = require('../adapter');\nvar utils = require('../utils/helpers');\nvar AdapterMixin = require('./adapters');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Query\n */\n\nvar Query = module.exports = function() {\n\n  // Create a reference to an internal Adapter Base\n  this.adapter = new AdapterBase({\n    connections: this.connections,\n    query: this,\n    collection: this.tableName || this.identity,\n    identity: this.identity,\n    dictionary: this.adapterDictionary\n  });\n\n  // Mixin Custom Adapter Functions.\n  AdapterMixin.call(this);\n\n  // Generate Dynamic Finders\n  this.buildDynamicFinders();\n};\n\n\n/**\n * Automigrate\n *\n * @param  {Function} cb\n */\nQuery.prototype.sync = function(cb) {\n  var self = this;\n\n  // If any adapters used in this collection have syncable turned off set migrate to safe.\n  //\n  // I don't think a collection would ever need two adapters where one needs migrations and\n  // the other doesn't but it may be a possibility. The way the auto-migrations work now doesn't\n  // allow for this either way so this should be good. We will probably need to revist this soonish\n  // however and take a pass at getting something working for better migration systems.\n  // - particlebanana\n\n  _.keys(this.connections).forEach(function(connectionName) {\n    var adapter = self.connections[connectionName]._adapter;\n\n    // If not syncable, don't sync\n    if (hop(adapter, 'syncable') && !adapter.syncable) {\n      self.migrate = 'safe';\n    }\n  });\n\n  // Assign synchronization behavior depending on migrate option in collection\n  if (this.migrate && ['drop', 'alter', 'create', 'safe'].indexOf(this.migrate) > -1) {\n\n    // Determine which sync strategy to use\n    var strategyMethodName = 'migrate' + utils.capitalize(this.migrate);\n\n    // Run automigration strategy\n    this.adapter[strategyMethodName](function(err) {\n      if (err) return cb(err);\n      cb();\n    });\n  }\n\n  // Throw Error\n  else cb(new Error('Invalid `migrate` strategy defined for collection. Must be one of the following: drop, alter, create, safe'));\n};\n\n\n_.extend(\n  Query.prototype,\n  require('./validate'),\n  require('./ddl'),\n  require('./dql'),\n  require('./aggregate'),\n  require('./composite'),\n  require('./finders/basic'),\n  require('./finders/helpers'),\n  require('./finders/dynamicFinders'),\n  require('./stream')\n);\n\n// Make Extendable\nQuery.extend = extend;\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/index.js":"/**\n * Base Adapter Definition\n */\n\nvar _ = require('lodash');\n\nvar Adapter = module.exports = function(options) {\n\n  // Ensure the connections are set\n  this.connections = options.connections || {};\n\n  // Ensure the dictionary is built\n  this.dictionary = options.dictionary || {};\n\n  // Set a Query instance to get access to top\n  // level query functions\n  this.query = options.query || {};\n\n  // Set Collection Name\n  this.collection = options.collection || '';\n\n  // Set Model Identity\n  this.identity = options.identity || '';\n\n  return this;\n};\n\n_.extend(\n  Adapter.prototype,\n  require('./dql'),\n  require('./ddl'),\n  require('./compoundQueries'),\n  require('./aggregateQueries'),\n  require('./setupTeardown'),\n  require('./sync'),\n  require('./stream')\n);\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/dql.js":"/**\n * Module Dependencies\n */\n\nvar normalize = require('../utils/normalize');\nvar schema = require('../utils/schema');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\nvar _ = require('lodash');\n\n\n/**\n * DQL Adapter Normalization\n */\nmodule.exports = {\n\n  hasJoin: function() {\n    return hasOwnProperty(this.dictionary, 'join');\n  },\n\n\n  /**\n   * join()\n   *\n   * If `join` is defined in the adapter, Waterline will use it to optimize\n   * the `.populate()` implementation when joining collections within the same\n   * database connection.\n   *\n   * @param  {[type]}   criteria\n   * @param  {Function} cb\n   */\n  join: function(criteria, cb) {\n\n    // Normalize Arguments\n    criteria = normalize.criteria(criteria);\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No join() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'join')) return cb(new Error(err));\n\n    var connName = this.dictionary.join;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'join')) return cb(new Error(err));\n\n    // Parse Join Criteria and set references to any collection tableName properties.\n    // This is done here so that everywhere else in the codebase can use the collection identity.\n    criteria = schema.serializeJoins(criteria, this.query.waterline.schema);\n\n    adapter.join(connName, this.collection, criteria, cb);\n  },\n\n\n  /**\n   * create()\n   *\n   * Create one or more models.\n   *\n   * @param  {[type]}   values [description]\n   * @param  {Function} cb     [description]\n   * @return {[type]}          [description]\n   */\n  create: function(values, cb) {\n\n    var globalId = this.query.globalId;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    if (Array.isArray(values)) return this.createEach.call(this, values, cb);\n\n    // Build Default Error Message\n    var err = 'No create() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'create')) return cb(new Error(err));\n\n    var connName = this.dictionary.create;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'create')) return cb(new Error(err));\n    adapter.create(connName, this.collection, values, normalize.callback(function afterwards(err, createdRecord) {\n      if (err) {\n        if (typeof err === 'object') err.model = globalId;\n        return cb(err);\n      }\n      else return cb(null, createdRecord);\n    }));\n  },\n\n\n  /**\n   * find()\n   *\n   * Find a set of models.\n   *\n   * @param  {[type]}   criteria [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  find: function(criteria, cb) {\n\n    // Normalize Arguments\n    criteria = normalize.criteria(criteria);\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No find() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'find')) return cb(new Error(err));\n\n    var connName = this.dictionary.find;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!adapter.find) return cb(new Error(err));\n    adapter.find(connName, this.collection, criteria, cb);\n  },\n\n\n  /**\n   * findOne()\n   *\n   * Find exactly one model.\n   *\n   * @param  {[type]}   criteria [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  findOne: function(criteria, cb) {\n\n    // make shallow copy of criteria so original does not get modified\n    criteria = _.clone(criteria);\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = '.findOne() requires a criteria. If you want the first record try .find().limit(1)';\n\n    // If no criteria is specified or where is empty return an error\n    if (!criteria || criteria.where === null) return cb(new Error(err));\n\n    // Detects if there is a `findOne` in the adapter. Use it if it exists.\n    if (hasOwnProperty(this.dictionary, 'findOne')) {\n      var connName = this.dictionary.findOne;\n      var adapter = this.connections[connName]._adapter;\n\n      if (adapter.findOne) {\n        // Normalize Arguments\n        criteria = normalize.criteria(criteria);\n        return adapter.findOne(connName, this.collection, criteria, cb);\n      }\n    }\n\n    // Fallback to use `find()` to simulate a `findOne()`\n    // Enforce limit to 1\n    criteria.limit = 1;\n\n    this.find(criteria, function(err, models) {\n      if (!models) return cb(err);\n      if (models.length < 1) return cb(err);\n\n      cb(null, models);\n    });\n  },\n\n  /**\n   * [count description]\n   * @param  {[type]}   criteria [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  count: function(criteria, cb) {\n    var connName;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n    criteria = normalize.criteria(criteria);\n\n    // Build Default Error Message\n    var err = '.count() requires the adapter define either a count method or a find method';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'count')) {\n\n      // If a count method isn't defined make sure a find method is\n      if (!hasOwnProperty(this.dictionary, 'find')) return cb(new Error(err));\n\n      // Use the find method\n      connName = this.dictionary.find;\n    }\n\n    if (!connName) connName = this.dictionary.count;\n    var adapter = this.connections[connName]._adapter;\n\n    if (hasOwnProperty(adapter, 'count')) return adapter.count(connName, this.collection, criteria, cb);\n\n    this.find(criteria, function(err, models) {\n      if (err) return cb(err);\n      var count = models && models.length || 0;\n      cb(err, count);\n    });\n  },\n\n\n  /**\n   * [update description]\n   * @param  {[type]}   criteria [description]\n   * @param  {[type]}   values   [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  update: function(criteria, values, cb) {\n    var globalId = this.query.globalId;\n\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n    criteria = normalize.criteria(criteria);\n\n    if (criteria === false) {\n      return cb(null, []);\n    } else if (!criteria) {\n      return cb(new Error('No criteria or id specified!'));\n    }\n\n    // Build Default Error Message\n    var err = 'No update() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'update')) return cb(new Error(err));\n\n    var connName = this.dictionary.update;\n    var adapter = this.connections[connName]._adapter;\n\n    adapter.update(connName, this.collection, criteria, values, normalize.callback(function afterwards(err, updatedRecords) {\n      if (err) {\n        if (typeof err === 'object') err.model = globalId;\n        return cb(err);\n      }\n      return cb(null, updatedRecords);\n    }));\n  },\n\n\n  /**\n   * [destroy description]\n   * @param  {[type]}   criteria [description]\n   * @param  {Function} cb       [description]\n   * @return {[type]}            [description]\n   */\n  destroy: function(criteria, cb) {\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n    criteria = normalize.criteria(criteria);\n\n    // Build Default Error Message\n    var err = 'No destroy() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'destroy')) return cb(new Error(err));\n\n    var connName = this.dictionary.destroy;\n    var adapter = this.connections[connName]._adapter;\n\n    adapter.destroy(connName, this.collection, criteria, cb);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/normalize.js":"var _ = require('lodash');\nvar util = require('./helpers');\nvar hop = util.object.hasOwnProperty;\nvar switchback = require('switchback');\nvar errorify = require('../error');\nvar WLUsageError = require('../error/WLUsageError');\n\nvar normalize = module.exports = {\n\n  // Expand Primary Key criteria into objects\n  expandPK: function(context, options) {\n\n    // Default to id as primary key\n    var pk = 'id';\n\n    // If autoPK is not used, attempt to find a primary key\n    if (!context.autoPK) {\n      // Check which attribute is used as primary key\n      for (var key in context.attributes) {\n        if (!util.object.hasOwnProperty(context.attributes[key], 'primaryKey')) continue;\n\n        // Check if custom primaryKey value is falsy\n        if (!context.attributes[key].primaryKey) continue;\n\n        // If a custom primary key is defined, use it\n        pk = key;\n        break;\n      }\n    }\n\n    // Check if options is an integer or string and normalize criteria\n    // to object, using the specified primary key field.\n    if (_.isNumber(options) || _.isString(options) || Array.isArray(options)) {\n      // Temporary store the given criteria\n      var pkCriteria = _.clone(options);\n\n      // Make the criteria object, with the primary key\n      options = {};\n      options[pk] = pkCriteria;\n    }\n\n    // If we're querying by primary key, create a coercion function for it\n    // depending on the data type of the key\n    if (options && options[pk]) {\n\n      var coercePK;\n      if(!context.attributes[pk]) {\n        return pk;\n      }\n      \n      if (context.attributes[pk].type == 'integer') {\n        coercePK = function(pk) {return +pk;};\n      } else if (context.attributes[pk].type == 'string') {\n        coercePK = function(pk) {return String(pk).toString();};\n\n      // If the data type is unspecified, return the key as-is\n      } else {\n        coercePK = function(pk) {return pk;};\n      }\n\n      // If the criteria is an array of PKs, coerce them all\n      if (Array.isArray(options[pk])) {\n        options[pk] = options[pk].map(coercePK);\n\n      // Otherwise just coerce the one\n      } else {\n        if (!_.isObject(options[pk])) {\n          options[pk] = coercePK(options[pk]);\n        }\n      }\n\n    }\n\n    return options;\n\n  },\n\n  // Normalize the different ways of specifying criteria into a uniform object\n  criteria: function(origCriteria) {\n    var criteria = _.cloneDeep(origCriteria);\n\n    // If original criteria is already false, keep it that way.\n    if (criteria === false) return criteria;\n\n    if (!criteria) {\n      return {\n        where: null\n      };\n    }\n\n    // Let the calling method normalize array criteria. It could be an IN query\n    // where we need the PK of the collection or a .findOrCreateEach\n    if (Array.isArray(criteria)) return criteria;\n\n    // Empty undefined values from criteria object\n    _.each(criteria, function(val, key) {\n      if (_.isUndefined(val)) criteria[key] = null;\n    });\n\n    // Convert non-objects (ids) into a criteria\n    // TODO: use customizable primary key attribute\n    if (!_.isObject(criteria)) {\n      criteria = {\n        id: +criteria || criteria\n      };\n    }\n\n    if (_.isObject(criteria) && !criteria.where && criteria.where !== null) {\n      criteria = { where: criteria };\n    }\n\n    // Return string to indicate an error\n    if (!_.isObject(criteria)) throw new WLUsageError('Invalid options/criteria :: ' + criteria);\n\n    // If criteria doesn't seem to contain operational keys, assume all the keys are criteria\n    if (!criteria.where && !criteria.joins && !criteria.join && !criteria.limit && !criteria.skip &&\n      !criteria.sort && !criteria.sum && !criteria.average &&\n      !criteria.groupBy && !criteria.min && !criteria.max && !criteria.select) {\n\n      // Delete any residuals and then use the remaining keys as attributes in a criteria query\n      delete criteria.where;\n      delete criteria.joins;\n      delete criteria.join;\n      delete criteria.limit;\n      delete criteria.skip;\n      delete criteria.sort;\n      criteria = {\n        where: criteria\n      };\n\n    // If where is null, turn it into an object\n    } else if (_.isNull(criteria.where)) criteria.where = {};\n\n\n    // Move Limit, Skip, sort outside the where criteria\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'limit')) {\n      criteria.limit = parseInt(_.clone(criteria.where.limit), 10);\n      if (criteria.limit < 0) criteria.limit = 0;\n      delete criteria.where.limit;\n    } else if (hop(criteria, 'limit')) {\n      criteria.limit = parseInt(criteria.limit, 10);\n      if (criteria.limit < 0) criteria.limit = 0;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'skip')) {\n      criteria.skip = parseInt(_.clone(criteria.where.skip), 10);\n      if (criteria.skip < 0) criteria.skip = 0;\n      delete criteria.where.skip;\n    } else if (hop(criteria, 'skip')) {\n      criteria.skip = parseInt(criteria.skip, 10);\n      if (criteria.skip < 0) criteria.skip = 0;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'sort')) {\n      criteria.sort = _.clone(criteria.where.sort);\n      delete criteria.where.sort;\n    }\n\n    // Pull out aggregation keys from where key\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'sum')) {\n      criteria.sum = _.clone(criteria.where.sum);\n      delete criteria.where.sum;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'average')) {\n      criteria.average = _.clone(criteria.where.average);\n      delete criteria.where.average;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'groupBy')) {\n      criteria.groupBy = _.clone(criteria.where.groupBy);\n      delete criteria.where.groupBy;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'min')) {\n      criteria.min = _.clone(criteria.where.min);\n      delete criteria.where.min;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'max')) {\n      criteria.max = _.clone(criteria.where.max);\n      delete criteria.where.max;\n    }\n\n    if (hop(criteria, 'where') && criteria.where !== null && hop(criteria.where, 'select')) {\n      criteria.select = _.clone(criteria.where.select);\n      delete criteria.where.select;\n    }\n\n    // If WHERE is {}, always change it back to null\n    if (criteria.where && _.keys(criteria.where).length === 0) {\n      criteria.where = null;\n    }\n\n    // If an IN was specified in the top level query and is an empty array, we can return an\n    // empty object without running the query because nothing will match anyway. Let's return\n    // false from here so the query knows to exit out.\n    if (criteria.where) {\n      var falsy = false;\n      Object.keys(criteria.where).forEach(function(key) {\n        if (Array.isArray(criteria.where[key]) && criteria.where[key].length === 0) {\n          falsy = true;\n        }\n      });\n\n      if (falsy) return false;\n    }\n\n    // If an IN was specified inside an OR clause and is an empty array, remove it because nothing will\n    // match it anyway and it can prevent errors in the adapters\n    if (criteria.where && hop(criteria.where, 'or')) {\n\n      // Ensure `or` is an array\n      if (!_.isArray(criteria.where.or)) {\n        throw new WLUsageError('An `or` clause in a query should be specified as an array of subcriteria');\n      }\n\n      var _clone = _.cloneDeep(criteria.where.or);\n      criteria.where.or.forEach(function(clause, i) {\n        Object.keys(clause).forEach(function(key) {\n          if (Array.isArray(clause[key]) && clause[key].length === 0) {\n            _clone.splice(i, 1);\n          }\n        });\n      });\n\n      criteria.where.or = _clone;\n    }\n\n    // Normalize sort criteria\n    if (hop(criteria, 'sort') && criteria.sort !== null) {\n\n      // Split string into attr and sortDirection parts (default to 'asc')\n      if (_.isString(criteria.sort)) {\n        var parts = criteria.sort.split(' ');\n\n        // Set default sort to asc\n        parts[1] = parts[1] ? parts[1].toLowerCase() : 'asc';\n\n        // Expand criteria.sort into object\n        criteria.sort = {};\n        criteria.sort[parts[0]] = parts[1];\n      }\n\n      // normalize ASC/DESC notation\n      Object.keys(criteria.sort).forEach(function(attr) {\n\n        if (_.isString(criteria.sort[attr])) {\n          criteria.sort[attr] = criteria.sort[attr].toLowerCase();\n\n          // Throw error on invalid sort order\n          if (criteria.sort[attr] !== 'asc' && criteria.sort[attr] !== 'desc') {\n            throw new WLUsageError('Invalid sort criteria :: ' + criteria.sort);\n          }\n        }\n\n        if (criteria.sort[attr] === 'asc') criteria.sort[attr] = 1;\n        if (criteria.sort[attr] === 'desc') criteria.sort[attr] = -1;\n      });\n\n      // normalize binary sorting criteria\n      Object.keys(criteria.sort).forEach(function(attr) {\n        if (criteria.sort[attr] === 0) criteria.sort[attr] = -1;\n      });\n\n      // Verify that user either specified a proper object\n      // or provided explicit comparator function\n      if (!_.isObject(criteria.sort) && !_.isFunction(criteria.sort)) {\n        throw new WLUsageError('Invalid sort criteria for ' + attrName + ' :: ' + direction);\n      }\n    }\n\n    return criteria;\n  },\n\n  // Normalize the capitalization and % wildcards in a like query\n  // Returns false if criteria is invalid,\n  // otherwise returns normalized criteria obj.\n  // Enhancer is an optional function to run on each criterion to preprocess the string\n  likeCriteria: function(criteria, attributes, enhancer) {\n\n    // Only accept criteria as an object\n    if (criteria !== Object(criteria)) return false;\n\n    criteria = _.clone(criteria);\n\n    if (!criteria.where) criteria = { where: criteria };\n\n    // Apply enhancer to each\n    if (enhancer) criteria.where = util.objMap(criteria.where, enhancer);\n\n    criteria.where = { like: criteria.where };\n\n    return criteria;\n  },\n\n\n  // Normalize a result set from an adapter\n  resultSet: function(resultSet) {\n\n    // Ensure that any numbers that can be parsed have been\n    return util.pluralize(resultSet, numberizeModel);\n  },\n\n\n  /**\n   * Normalize the different ways of specifying callbacks in built-in Waterline methods.\n   * Switchbacks vs. Callbacks (but not deferred objects/promises)\n   *\n   * @param  {Function|Handlers} cb\n   * @return {Handlers}\n   */\n  callback: function(cb) {\n\n    // Build modified callback:\n    // (only works for functions currently)\n    var wrappedCallback;\n    if (_.isFunction(cb)) {\n      wrappedCallback = function(err) {\n\n        // If no error occurred, immediately trigger the original callback\n        // without messing up the context or arguments:\n        if (!err) {\n          return applyInOriginalCtx(cb, arguments);\n        }\n\n        // If an error argument is present, upgrade it to a WLError\n        // (if it isn't one already)\n        err = errorify(err);\n\n        var modifiedArgs = Array.prototype.slice.call(arguments, 1);\n        modifiedArgs.unshift(err);\n\n        // Trigger callback without messing up the context or arguments:\n        return applyInOriginalCtx(cb, modifiedArgs);\n      };\n    }\n\n\n    //\n    // TODO: Make it clear that switchback support it experimental.\n    //\n    // Push switchback support off until >= v0.11\n    // or at least add a warning about it being a `stage 1: experimental`\n    // feature.\n    //\n\n    if (!_.isFunction(cb)) wrappedCallback = cb;\n    return switchback(wrappedCallback, {\n      invalid: 'error', // Redirect 'invalid' handler to 'error' handler\n      error: function _defaultErrorHandler() {\n        console.error.apply(console, Array.prototype.slice.call(arguments));\n      }\n    });\n\n\n    // ????\n    // TODO: determine support target for 2-way switchback usage\n    // ????\n\n    // Allow callback to be -HANDLED- in different ways\n    // at the app-level.\n    // `cb` may be passed in (at app-level) as either:\n    //    => an object of handlers\n    //    => or a callback function\n    //\n    // If a callback function was provided, it will be\n    // automatically upgraded to a simplerhandler object.\n    // var cb_fromApp = switchback(cb);\n\n    // Allow callback to be -INVOKED- in different ways.\n    // (adapter def)\n    // var cb_fromAdapter = cb_fromApp;\n\n  }\n};\n\n// If any attribute looks like a number, but it's a string\n// cast it to a number\nfunction numberizeModel(model) {\n  return util.objMap(model, numberize);\n}\n\n\n// If specified attr looks like a number, but it's a string, cast it to a number\nfunction numberize(attr) {\n  if (_.isString(attr) && isNumbery(attr) && parseInt(attr, 10) < Math.pow(2, 53)) return +attr;\n  else return attr;\n}\n\n// Returns whether this value can be successfully parsed as a finite number\nfunction isNumbery(value) {\n  return Math.pow(+value, 2) > 0;\n}\n\n// Replace % with %%%\nfunction escapeLikeQuery(likeCriterion) {\n  return likeCriterion.replace(/[^%]%[^%]/g, '%%%');\n}\n\n// Replace %%% with %\nfunction unescapeLikeQuery(likeCriterion) {\n  return likeCriterion.replace(/%%%/g, '%');\n}\n\n\n/**\n * Like _.partial, but accepts an array of arguments instead of\n * comma-seperated args (if _.partial is `call`, this is `apply`.)\n * The biggest difference from `_.partial`, other than the usage,\n * is that this helper actually CALLS the partially applied function.\n *\n * This helper is mainly useful for callbacks.\n *\n * @param  {Function} fn   [description]\n * @param  {[type]}   args [description]\n * @return {[type]}        [description]\n */\n\nfunction applyInOriginalCtx(fn, args) {\n  return (_.partial.apply(null, [fn].concat(Array.prototype.slice.call(args))))();\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/error/index.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('lodash');\nvar WLError = require('./WLError');\nvar WLValidationError = require('./WLValidationError');\n\n\n/**\n * A classifier which normalizes a mystery error into a simple,\n * consistent format.  This ensures that our instance which is\n * \"new\"-ed up belongs to one of a handful of distinct categories\n * and has a predictable method signature and properties.\n *\n * The returned error instance will always be or extend from\n * `WLError` (which extends from `Error`)\n *\n * NOTE:\n * This method should eventually be deprecated in a\n * future version of Waterline.  It exists to help\n * w/ error type negotiation.  In general, Waterline\n * should use WLError, or errors which extend from it\n * to construct error objects of the appropriate type.\n * In other words, no ** new ** errors should need to\n * be wrapped in a call to `errorify` - instead, code\n * necessary to handle any new error conditions should\n * construct a `WLError` directly and return that.\n *\n * @param  {???} err\n * @return {WLError}\n */\nmodule.exports = function errorify(err) {\n\n  // If specified `err` is already a WLError, just return it.\n  if (typeof err === 'object' && err instanceof WLError) return err;\n\n  return duckType(err);\n};\n\n\n/**\n * Determine which type of error we're working with.\n * Err... using hacks.\n *\n * @return {[type]} [description]\n */\nfunction duckType(err) {\n\n  // Validation or constraint violation error (`E_VALIDATION`)\n  //\n  // i.e. detected before talking to adapter, like `minLength`\n  // i.e. constraint violation reported by adapter, like `unique`\n  if (/* _isValidationError(err) || */ _isConstraintViolation(err)) {\n\n    // Dress `unique` rule violations to be consistent with other\n    // validation errors.\n    return new WLValidationError(err);\n  }\n\n  // Unexpected miscellaneous error  (`E_UNKNOWN`)\n  //\n  // (i.e. helmet fire. The database crashed or something. Or there's an adapter\n  //  bug. Or a bug in WL core.)\n  return new WLError({\n    originalError: err\n  });\n}\n\n\n/**\n * @param  {?} err\n * @return {Boolean} whether this is an adapter-level constraint\n * violation (e.g. `unique`)\n */\nfunction _isConstraintViolation(err) {\n\n  // If a proper error code is specified, this error can be classified.\n  if (err && typeof err === 'object' && err.code === 'E_UNIQUE') {\n    return true;\n  }\n\n  // Otherwise, there is not enough information to call this a\n  // constraint violation error and provide proper explanation to\n  // the architect.\n  else return false;\n}\n\n\n// /**\n//  * @param  {?} err\n//  * @return {Boolean} whether this is a validation error (e.g. minLength exceeded for attribute)\n//  */\n// function _isValidationError(err) {\n//   return _.isObject(err) && err.ValidationError;\n// }\n\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/ddl/index.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar normalize = require('../../utils/normalize');\nvar getRelations = require('../../utils/getRelations');\nvar hasOwnProperty = require('../../utils/helpers').object.hasOwnProperty;\n\n\n/**\n * DDL Adapter Normalization\n */\n\nmodule.exports = {\n\n  define: function(cb) {\n    var self = this;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var errMsg = 'No define() method defined in adapter!';\n\n    // Grab attributes from definition\n    var schema = _.clone(this.query._schema.schema) || {};\n\n    // Find any junctionTables that reference this collection\n    var relations = getRelations({\n      schema: self.query.waterline.schema,\n      parentCollection: self.collection\n    });\n\n    //\n    // TODO: if junction tables don't exist, define them\n    // console.log(relations);\n    //\n\n    // Verify that collection doesn't already exist\n    // and then define it and trigger callback\n    this.describe(function(err, existingAttributes) {\n      if (err) return cb(err);\n      if (existingAttributes) return cb(new Error('Trying to define a collection (' + self.collection + ') which already exists.'));\n\n      // Remove hasMany association keys before sending down to adapter\n      Object.keys(schema).forEach(function(key) {\n        if (schema[key].type) return;\n        delete schema[key];\n      });\n\n      // Find the connection to run this on\n      if (!hasOwnProperty(self.dictionary, 'define')) return cb();\n\n      var connName = self.dictionary.define;\n      var adapter = self.connections[connName]._adapter;\n\n      if (!hasOwnProperty(adapter, 'define')) return cb(new Error(errMsg));\n      adapter.define(connName, self.collection, schema, cb);\n    });\n  },\n\n  describe: function(cb) {\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No describe() method defined in adapter!';\n\n    // Find the connection to run this on\n    // NOTE: if `describe` doesn't exist, an error is not being returned.\n    if (!hasOwnProperty(this.dictionary, 'describe')) return cb();\n\n    var connName = this.dictionary.describe;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'describe')) return cb(new Error(err));\n    adapter.describe(connName, this.collection, cb);\n  },\n\n  drop: function(relations, cb) {\n    // Allow relations to be optional\n    if (typeof relations === 'function') {\n      cb = relations;\n      relations = [];\n    }\n\n    relations = [];\n\n    //\n    // TODO:\n    // Use a more normalized strategy to get relations so we can omit the extra argument above.\n    // e.g. getRelations({ schema: self.query.waterline.schema, parentCollection: self.collection });\n    //\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No drop() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'drop')) return cb(new Error(err));\n\n    var connName = this.dictionary.drop;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'drop')) return cb(new Error(err));\n    adapter.drop(connName, this.collection, relations, cb);\n  },\n\n  alter: function(cb) {\n\n    // Normalize arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No alter() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'alter')) return cb(new Error(err));\n\n    var connName = this.dictionary.alter;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'alter')) return cb(new Error(err));\n    adapter.alter(connName, this.collection, cb);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/getRelations.js":"/**\n * getRelations\n *\n * Find any `junctionTables` that reference the parent collection.\n *\n * @param  {[type]} options [description]\n *    @option parentCollection\n *    @option schema\n * @return {[type]}         [relations]\n */\n\nmodule.exports = function getRelations(options) {\n\n  var schema = options.schema;\n  var relations = [];\n\n  Object.keys(schema).forEach(function(collection) {\n    var collectionSchema = schema[collection];\n    if (!collectionSchema.hasOwnProperty('junctionTable')) return;\n\n    Object.keys(collectionSchema.attributes).forEach(function(key) {\n      if (!collectionSchema.attributes[key].hasOwnProperty('foreignKey')) return;\n      if (collectionSchema.attributes[key].references !== options.parentCollection) return;\n      relations.push(collection);\n    });\n  });\n\n  return relations;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/compoundQueries.js":"/**\n * Compound Queries Adapter Normalization\n */\n\nvar _ = require('lodash');\nvar normalize = require('../utils/normalize');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\nmodule.exports = {\n\n  findOrCreate: function(criteria, values, cb) {\n    var self = this;\n    var connName,\n        adapter;\n\n    // If no values were specified, use criteria\n    if (!values) values = criteria.where ? criteria.where : criteria;\n\n    // Normalize Arguments\n    criteria = normalize.criteria(criteria);\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No find() or create() method defined in adapter!';\n\n    // Custom user adapter behavior\n    if (hasOwnProperty(this.dictionary, 'findOrCreate')) {\n      connName = this.dictionary.findOrCreate;\n      adapter = this.connections[connName]._adapter;\n\n      if (hasOwnProperty(adapter, 'findOrCreate')) {\n        return adapter.findOrCreate(connName, this.collection, values, cb);\n      }\n    }\n\n    // Default behavior\n    // WARNING: Not transactional!  (unless your data adapter is)\n    this.findOne(criteria, function(err, result) {\n      if (err) return cb(err);\n      if (result) return cb(null, result[0]);\n\n      self.create(values, cb);\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/aggregateQueries.js":"/**\n * Aggregate Queries Adapter Normalization\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar normalize = require('../utils/normalize');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\nmodule.exports = {\n\n  // If an optimized createEach exists, use it, otherwise use an asynchronous loop with create()\n  createEach: function(valuesList, cb) {\n    var self = this;\n    var connName,\n        adapter;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    // Build Default Error Message\n    var err = 'No createEach() or create() method defined in adapter!';\n\n    // Custom user adapter behavior\n    if (hasOwnProperty(this.dictionary, 'createEach')) {\n      connName = this.dictionary.createEach;\n      adapter = this.connections[connName]._adapter;\n\n      if (hasOwnProperty(adapter, 'createEach')) {\n        return adapter.createEach(connName, this.collection, valuesList, cb);\n      }\n    }\n\n    // Default behavior\n    // WARNING: Not transactional!  (unless your data adapter is)\n    var results = [];\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'create')) return cb(new Error(err));\n\n    connName = this.dictionary.create;\n    adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'create')) return cb(new Error(err));\n\n    async.eachSeries(valuesList, function(values, cb) {\n      adapter.create(connName, self.collection, values, function(err, row) {\n        if (err) return cb(err);\n        results.push(row);\n        cb();\n      });\n    }, function(err) {\n      if (err) return cb(err);\n      cb(null, results);\n    });\n  },\n\n  // If an optimized findOrCreateEach exists, use it, otherwise use an asynchronous loop with create()\n  findOrCreateEach: function(attributesToCheck, valuesList, cb) {\n    var self = this;\n    var connName;\n    var adapter;\n\n    // Normalize Arguments\n    cb = normalize.callback(cb);\n\n    var isObjectArray = false;\n\n    if (_.isObject(attributesToCheck[0])) {\n      if (attributesToCheck.length > 1 &&\n        attributesToCheck.length !== valuesList.length) {\n        return cb(new Error('findOrCreateEach: The two passed arrays have to be of the same length.'));\n      }\n      isObjectArray = true;\n    }\n\n    // Clone sensitive data\n    attributesToCheck = _.clone(attributesToCheck);\n    valuesList = _.clone(valuesList);\n\n    // Custom user adapter behavior\n    if (hasOwnProperty(this.dictionary, 'findOrCreateEach')) {\n      connName = this.dictionary.findOrCreateEach;\n      adapter = this.connections[connName]._adapter;\n\n      if (hasOwnProperty(adapter, 'findOrCreateEach')) {\n        return adapter.findOrCreateEach(connName, this.collection, valuesList, cb);\n      }\n    }\n\n    // Build a list of models\n    var models = [];\n    var i = 0;\n\n    async.eachSeries(valuesList, function(values, cb) {\n      if (!_.isObject(values)) return cb(new Error('findOrCreateEach: Unexpected value in valuesList.'));\n      // Check that each of the criteria keys match:\n      // build a criteria query\n      var criteria = {};\n\n      if (isObjectArray) {\n        if (_.isObject(attributesToCheck[i])) {\n          Object.keys(attributesToCheck[i]).forEach(function(attrName) {\n            criteria[attrName] = values[attrName];\n          });\n          if (attributesToCheck.length > 1) {\n            i++;\n          }\n        } else {\n          return cb(new Error('findOrCreateEach: Element ' + i + ' in attributesToCheck is not an object.'));\n        }\n      } else {\n        attributesToCheck.forEach(function(attrName) {\n          criteria[attrName] = values[attrName];\n        });\n      }\n\n      return self.findOrCreate.call(self, criteria, values, function(err, model) {\n        if (err) return cb(err);\n\n        // Add model to list\n        if (model) models.push(model);\n\n        cb(null, model);\n      });\n    }, function(err) {\n      if (err) return cb(err);\n      cb(null, models);\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/setupTeardown.js":"/**\n * Setup and Teardown Adapter Normalization\n */\n\nmodule.exports = {\n\n  // Teardown is fired once-per-adapter\n  // Should tear down any open connections, etc. for each collection\n  // (i.e. tear down any remaining connections to the underlying data model)\n  // (i.e. flush data to disk before the adapter shuts down)\n  teardown: function(cb) {\n    if (this.adapter.teardown) {\n      return this.adapter.teardown.apply(this, arguments);\n    };\n\n    cb();\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/sync/index.js":"// TODO: probably can eliminate this file\nmodule.exports = {\n  migrateDrop: require('./strategies/drop.js'),\n  migrateAlter: require('./strategies/alter.js'),\n  migrateCreate: require('./strategies/create.js'),\n  migrateSafe: require('./strategies/safe.js')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/sync/strategies/drop.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar getRelations = require('../../../utils/getRelations');\n\n\n/**\n * Drop and recreate collection\n *\n * @param  {Function} cb\n */\n\nmodule.exports = function drop(cb) {\n  var self = this;\n\n  // Refuse to run this migration strategy in production.\n  if (process.env.NODE_ENV === 'production') {\n    return cb(new Error('`migrate: \"drop\"` strategy is not supported in production, please change to `migrate: \"safe\"`.'));\n  }\n\n  // Find any junctionTables that reference this collection\n  // var relations = getRelations({\n  //   schema: self.query.waterline.schema,\n  //   parentCollection: self.collection\n  // });\n\n  // Pass along relations to the drop method\n  // console.log('Dropping ' + self.collection);\n  this.drop(function afterDrop(err, data) {\n    if (err) return cb(err);\n\n    self.define(function() {\n      cb.apply(null, Array.prototype.slice.call(arguments));\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/sync/strategies/alter.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar getRelations = require('../../../utils/getRelations');\n\n\n/**\n * Try and synchronize the underlying physical-layer schema\n * to work with our app's collections. (i.e. models)\n *\n * @param  {Function} cb\n */\nmodule.exports = function(cb) {\n  var self = this;\n\n  // Refuse to run this migration strategy in production.\n  if (process.env.NODE_ENV === 'production') {\n    return cb(new Error('`migrate: \"alter\"` strategy is not supported in production, please change to `migrate: \"safe\"`.'));\n  }\n\n  // Find any junctionTables that reference this collection\n  var relations = getRelations({\n    schema: self.query.waterline.schema,\n    parentCollection: self.collection\n  });\n\n  var backupData;\n\n  // Check that collection exists--\n  self.describe(function afterDescribe(err, attrs) {\n\n    if (err) return cb(err);\n\n    // if it doesn't go ahead and add it and get out\n    if (!attrs) return self.define(cb);\n\n    var collectionName = _.find(self.query.waterline.schema, {tableName: self.collection}).identity;\n\n    // Create a mapping of column names -> attribute names\n    var columnNamesMap = _.reduce(self.query.waterline.schema[collectionName].attributes, function(memo, val, key) {\n      // If the attribute has a custom column name, use it as the key for the mapping\n      if (val.columnName) {\n        memo[val.columnName] = key;\n      // Otherwise just use the attribute name\n      } else {\n        memo[key] = key;\n      }\n      return memo;\n    }, {});\n\n    // Transform column names into attribute names using the columnNamesMap,\n    // removing attributes that no longer exist (they will be dropped)\n    attrs = _.compact(_.keys(attrs).map(function(key) {\n      return columnNamesMap[key];\n    }));\n\n    //\n    // TODO:\n    // Take a look and see if anything important has changed.\n    // If it has (at all), we still have to follow the naive strategy below,\n    // but it will at least save time in the general case.\n    // (because it really sucks to have to wait for all of this to happen\n    //  every time you initialize Waterline.)\n    //\n\n\n    //\n    // OK so we have to fix up the schema and migrate the data...\n    //\n    // ... we'll let Waterline do it for us.\n    //\n    // Load all data from this collection into memory.\n    // If this doesn't work, crash to avoid corrupting any data.\n    // (see `waterline/lib/adapter/ddl/README.md` for more info about this)\n    //\n    // Make sure we only select the existing keys for the schema.\n    // The default \"find all\" will select each attribute in the schema, which\n    // now includes attributes that haven't been added to the table yet, so\n    // on SQL databases the query will fail with \"unknown field\" error.\n    //\n    var hasSchema = self.query.hasSchema;\n\n    // If we have a schema, make sure we only select the existing keys for the schema.\n    // The default \"find all\" will select each attribute in the schema, which\n    // now includes attributes that haven't been added to the table yet, so\n    // on SQL databases the query will fail with \"unknown field\" error.\n    //\n    // If we don't have a schema then we need to select all the values to make\n    // sure we don't lose data in the process.\n    var queryCriteria;\n\n    if (hasSchema) {\n      queryCriteria = {select: attrs};\n    } else {\n      queryCriteria = {};\n    }\n\n    self.find(queryCriteria, function(err, existingData) {\n\n      if (err) {\n        //\n        // TODO:\n        // If this was a memory error, log a more useful error\n        // explaining what happened.\n        //\n        return cb(err);\n      }\n\n      //\n      // From this point forward, we must be very careful.\n      //\n      backupData = _.cloneDeep(existingData, function dealWithBuffers(val) {\n        if (val instanceof Buffer) {\n          return val.slice();\n        }\n      });\n\n\n      // Check to see if there is anything obviously troublesome\n      // that will cause the drop and redefinition of our schemaful\n      // collections to fail.\n      // (i.e. violation of uniqueness constraints)\n      var attrs = self.query.waterline.collections[self.identity]._attributes;\n      var pk = self.query.waterline.collections[self.identity].primaryKey;\n      var attrsAsArray = _.reduce(_.cloneDeep(attrs), function(memo, attrDef, attrName) {\n        attrDef.name = attrName;\n        memo.push(attrDef);\n        return memo;\n      }, []);\n      var uniqueAttrs = _.where(attrsAsArray, {unique: true});\n      async.each(uniqueAttrs, function(uniqueAttr, each_cb) {\n        var uniqueData = _.uniq(_.pluck(existingData, uniqueAttr.name));\n\n        // Remove any unique values who have their values set to undefined or null\n        var cleansedExistingData = _.filter(existingData, function(val) {\n          return [undefined, null].indexOf(val[uniqueAttr.name]) < 0;\n        });\n\n        // Remove any undefined or null values from the unique data\n        var cleansedUniqueData = _.filter(uniqueData, function(val) {\n          return [undefined, null].indexOf(val) < 0;\n        });\n\n        if (cleansedUniqueData.length < cleansedExistingData.length) {\n          // Some existing data violates a new uniqueness constraint\n          var prompt = require('prompt');\n          prompt.start();\n          console.log(\n            'One or more existing records in your database violate ' +\n            'a new uniqueness constraint\\n' +\n            'on `' + uniqueAttr.name + '` ' +\n            'in your `' + self.identity + '` model.');\n          console.log();\n          console.log('Should we automatically remove duplicates?');\n          console.log();\n          console.log('** WARNING: DO NOT TYPE \"y\" IF YOU ARE WORKING WITH PRODUCTION DATA **');\n          // var laptimer = setInterval(function beepbeepbeepbeep(){\n          //   process.stdout.write('\\u0007');\n          // }, 1500);\n          prompt.get(['y/n'], function(err, results) {\n            // clearInterval(laptimer);\n            if (err) return each_cb(err);\n            var wasConfirmedByUser = _.isString(results['y/n']) && results['y/n'].match(/y/);\n            if (wasConfirmedByUser) {\n\n              // Wipe out duplicate records in `backupData` and continue\n              // to perform the automigration\n              var diff = _.difference(existingData, _.uniq(existingData, false, uniqueAttr.name));\n\n              var destroyCriteria = {};\n              destroyCriteria[pk] = _.pluck(diff, pk);\n              // console.log(diff, '\\n', destroyCriteria);\n              backupData = _.remove(backupData, function(datum) {\n                return !_.contains(destroyCriteria[pk], datum[pk]);\n              });\n              return each_cb();\n              // console.log(backupData);\n              // throw new Error();\n              // self.query.waterline.collections[self.collection].destroy(destroyCriteria).exec(each_cb);\n            } else return each_cb(new Error('Auto-migration aborted. Please migrate your data manually and then try this again.'));\n          });\n        } else return each_cb();\n      }, function afterAsyncEach(err) {\n        if (err) return cb(err);\n\n        // Now we'll drop the collection.\n        self.drop(relations, function(err) {\n          if (err) return uhoh(err, backupData, cb);\n\n          // Now we'll redefine the collection.\n          self.define(function(err) {\n            if (err) return uhoh(err, backupData, cb);\n\n            // Now we'll create the `backupData` again,\n            // being careful not to run any lifecycle callbacks\n            // and disable automatic updating of `createdAt` and\n            // `updatedAt` attributes:\n            //\n            // ((((TODO: actually be careful about said things))))\n            //\n            self.createEach(backupData, function(err) {\n              if (err) return uhoh(err, backupData, cb);\n\n              // Done.\n              return cb();\n            });\n\n          }); // </define>\n        }); // </drop>\n      }); // </find>\n    });\n\n\n    //\n    // The old way-- (doesn't always work, and is way more\n    // complex than we should spend time on for now)\n    //\n    //   ||      ||      ||      ||      ||      ||\n    //   \\/      \\/      \\/      \\/      \\/      \\/\n    //\n    // Otherwise, if it *DOES* exist, we'll try and guess what changes need to be made\n    // self.alter(function(err) {\n    //   if (err) return cb(err);\n    //   cb();\n    // });\n\n  });\n};\n\n\n/**\n * uh oh.\n *\n * If we can't persist the data again, we'll log an error message, then\n * stream the data to stdout as JSON to make sure that it gets persisted\n * SOMEWHERE at least.\n *\n * (this is another reason this automigration strategy cannot be used in\n * production currently..)\n *\n * @param  {[type]}   err        [description]\n * @param  {[type]}   backupData [description]\n * @param  {Function} cb         [description]\n * @return {[type]}              [description]\n */\n\nfunction uhoh(err, backupData, cb) {\n\n  console.error('Waterline encountered a fatal error when trying to perform the `alter` auto-migration strategy.');\n  console.error('In a couple of seconds, the data (cached in memory) will be logged to stdout.');\n  console.error('(a failsafe put in place to preserve development data)');\n  console.error();\n  console.error('In the mean time, here\\'s the error:');\n  console.error();\n  console.error(err);\n  console.error();\n  console.error();\n\n  setTimeout(function() {\n    console.error('================================');\n    console.error('Data backup:');\n    console.error('================================');\n    console.error('');\n    console.log(backupData);\n    return cb(err);\n  }, 1200);\n\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/sync/strategies/create.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar hasOwnProperty = require('../../../utils/helpers').object.hasOwnProperty;\n\n\n/**\n * Try and synchronize the underlying physical-layer schema\n * in safely manner by only adding new collections and new attributes\n * to work with our app's collections. (i.e. models)\n *\n * @param  {Function} cb\n */\nmodule.exports = function(cb) {\n  var self = this;\n\n\n  // Check that collection exists\n  self.describe(function afterDescribe(err, attrs) {\n\n    if (err) return cb(err);\n\n    // if it doesn't go ahead and add it and get out\n    if (!attrs) return self.define(cb);\n\n    // Check if an addAttribute adapter method is defined\n    if (!hasOwnProperty(self.dictionary, 'addAttribute')) {\n      return cb();\n    }\n\n    // Find the relevant connections to run this on\n    var connName = self.dictionary.addAttribute;\n    var adapter = self.connections[connName]._adapter;\n\n    // Check if adapter has addAttribute method\n    if (!hasOwnProperty(adapter, 'addAttribute')) {\n      return cb();\n    }\n\n    // The collection we're working with\n    var collectionID = self.collection;\n\n    // Remove hasMany association keys before sending down to adapter\n    var schema = _.clone(self.query._schema.schema) || {};\n    Object.keys(schema).forEach(function(key) {\n      if (schema[key].type) return;\n      delete schema[key];\n    });\n\n    // Iterate through each attribute in the new definition\n    // Used for keeping track of previously undefined attributes\n    // when updating the data stored at the physical layer.\n    var newAttributes = _.reduce(schema, function checkAttribute(newAttributes, attribute, attrName) {\n      if (!attrs[attrName]) {\n        newAttributes[attrName] = attribute;\n      }\n      return newAttributes;\n    }, {});\n\n    // Add new attributes\n    async.eachSeries(_.keys(newAttributes), function(attrName, next) {\n      var attrDef = newAttributes[attrName];\n      adapter.addAttribute(connName, collectionID, attrName, attrDef, next);\n    }, cb);\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/sync/strategies/safe.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\n\n\n/**\n * Do absolutely nothing to the schema of the underlying datastore.\n *\n * @param  {Function} cb\n */\nmodule.exports = function(cb) {\n  cb();\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/adapter/stream.js":"/**\n * Module Dependencies\n */\n\nvar normalize = require('../utils/normalize');\nvar hasOwnProperty = require('../utils/helpers').object.hasOwnProperty;\n\n/**\n * Stream Normalization\n */\n\nmodule.exports = {\n\n  // stream.write() is used to send data\n  // Must call stream.end() to complete stream\n  stream: function(criteria, stream) {\n\n    // Normalize Arguments\n    criteria = normalize.criteria(criteria);\n\n    // Build Default Error Message\n    var err = 'No stream() method defined in adapter!';\n\n    // Find the connection to run this on\n    if (!hasOwnProperty(this.dictionary, 'stream')) return stream.end(new Error(err));\n\n    var connName = this.dictionary.stream;\n    var adapter = this.connections[connName]._adapter;\n\n    if (!hasOwnProperty(adapter, 'stream')) return stream.end(new Error(err));\n    adapter.stream(connName, this.collection, criteria, stream);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/adapters.js":"/**\n * Mixes Custom Non-CRUD Adapter Methods into the prototype.\n */\n\nmodule.exports = function() {\n  var self = this;\n\n  Object.keys(this.connections).forEach(function(conn) {\n\n    var adapter = self.connections[conn]._adapter || {};\n\n    Object.keys(adapter).forEach(function(key) {\n\n      // Ignore the Identity Property\n      if (['identity', 'tableName'].indexOf(key) >= 0) return;\n\n      // Don't override keys that already exists\n      if (self[key]) return;\n\n      // Don't override a property, only functions\n      if (typeof adapter[key] != 'function') {\n        self[key] = adapter[key];\n        return;\n      }\n\n      // Apply the Function with passed in args and set this.identity as\n      // the first argument\n      self[key] = function() {\n\n        var tableName = self.tableName || self.identity;\n\n        // If this is the teardown method, just pass in the connection name,\n        // otherwise pass the connection and the tableName\n        var defaultArgs = key === 'teardown' ? [conn] : [conn, tableName];\n\n        // Concat self.identity with args (must massage arguments into a proper array)\n        // Use a normalized _tableName set in the core module.\n        var args = defaultArgs.concat(Array.prototype.slice.call(arguments));\n        return adapter[key].apply(self, args);\n      };\n    });\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/validate.js":"/**\n * Validation\n *\n * Used in create and update methods validate a model\n * Can also be used independently\n */\n\nvar _ = require('lodash');\nvar WLValidationError = require('../error/WLValidationError');\nvar async = require('async');\n\nmodule.exports = {\n\n  validate: function(values, presentOnly, cb) {\n    var self = this;\n\n    // Handle optional second arg\n    if (typeof presentOnly === 'function') {\n      cb = presentOnly;\n      presentOnly = false;\n    }\n\n    async.series([\n\n      // Run Before Validate Lifecycle Callbacks\n      function(cb) {\n        var runner = function(item, callback) {\n          item.call(self, values, function(err) {\n            if (err) return callback(err);\n            callback();\n          });\n        };\n\n        async.eachSeries(self._callbacks.beforeValidate, runner, function(err) {\n          if (err) return cb(err);\n          cb();\n        });\n      },\n\n      // Run Validation\n      function(cb) {\n        self._validator.validate(values, presentOnly, function _afterValidating(err, invalidAttributes) {\n          // If fatal error occurred, handle it accordingly.\n          if (err) {\n            return cb(err);\n          }\n\n          // Otherwise, check out the invalid attributes that were sent back.\n          //\n          // Create validation error here\n          // (pass in the invalid attributes as well as the collection's globalId)\n          if (invalidAttributes) {\n            return cb(new WLValidationError({\n              invalidAttributes: invalidAttributes,\n              model: self.globalId || self.adapter.identity\n            }));\n          }\n\n          cb();\n        });\n      },\n\n      // Run After Validate Lifecycle Callbacks\n      function(cb) {\n        var runner = function(item, callback) {\n          item(values, function(err) {\n            if (err) return callback(err);\n            callback();\n          });\n        };\n\n        async.eachSeries(self._callbacks.afterValidate, runner, function(err) {\n          if (err) return cb(err);\n          cb();\n        });\n      }\n\n    ], function(err) {\n      if (err) return cb(err);\n      cb();\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/ddl.js":"/**\n * DDL Queries\n */\n\nmodule.exports = {\n\n  /**\n   * Describe a collection\n   */\n\n  describe: function(cb) {\n    this.adapter.describe(cb);\n  },\n\n  /**\n   * Alter a table/set/etc\n   */\n\n  alter: function(attributes, cb) {\n    this.adapter.alter(attributes, cb);\n  },\n\n  /**\n   * Drop a table/set/etc\n   */\n\n  drop: function(cb) {\n    this.adapter.drop(cb);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/dql/index.js":"\n/**\n * Export DQL Methods\n */\n\nmodule.exports = {\n  create: require('./create'),\n  update: require('./update'),\n  destroy: require('./destroy'),\n  count: require('./count'),\n  join: require('./join')\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/dql/create.js":"/**\n * Module Dependencies\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar utils = require('../../utils/helpers');\nvar Deferred = require('../deferred');\nvar callbacks = require('../../utils/callbacksRunner');\nvar nestedOperations = require('../../utils/nestedOperations');\nvar hop = utils.object.hasOwnProperty;\n\n\n/**\n * Create a new record\n *\n * @param {Object || Array} values for single model or array of multiple values\n * @param {Function} callback\n * @return Deferred object if no callback\n */\n\nmodule.exports = function(values, cb) {\n\n  var self = this;\n\n  // Handle Deferred where it passes criteria first\n  if (arguments.length === 3) {\n    var args = Array.prototype.slice.call(arguments);\n    cb = args.pop();\n    values = args.pop();\n  }\n\n  // Loop through values and pull out any buffers before cloning\n  var bufferValues = {};\n\n  _.each(_.keys(values), function(key) {\n    if (Buffer.isBuffer(values[key])) {\n      bufferValues[key] = values[key];\n    }\n  });\n\n  values = _.cloneDeep(values) || {};\n\n  // Replace clone keys with the buffer values\n  _.each(_.keys(bufferValues), function(key) {\n    values[key] = bufferValues[key];\n  });\n\n  // Remove all undefined values\n  if (_.isArray(values)) {\n    values = _.remove(values, undefined);\n  }\n\n  // Return Deferred or pass to adapter\n  if (typeof cb !== 'function') {\n    return new Deferred(this, this.create, {}, values);\n  }\n\n\n  // Handle Array of values\n  if (Array.isArray(values)) {\n    return this.createEach(values, cb);\n  }\n\n  // Process Values\n  var valuesObject = processValues.call(this, values);\n\n  // Create any of the belongsTo associations and set the foreign key values\n  createBelongsTo.call(this, valuesObject, function(err) {\n    if (err) return cb(err);\n\n    beforeCallbacks.call(self, valuesObject, function(err) {\n      if (err) return cb(err);\n      createValues.call(self, valuesObject, cb);\n    });\n  });\n};\n\n\n/**\n * Process Values\n *\n * @param {Object} values\n * @return {Object}\n */\n\nfunction processValues(values) {\n\n  // Set Default Values if available\n  for (var key in this.attributes) {\n    if ((!hop(values, key) || values[key] === undefined) && hop(this.attributes[key], 'defaultsTo')) {\n      var defaultsTo = this.attributes[key].defaultsTo;\n      values[key] = typeof defaultsTo === 'function' ? defaultsTo.call(values) : _.clone(defaultsTo);\n    }\n  }\n\n  // Pull out any associations in the values\n  var _values = _.cloneDeep(values);\n  var associations = nestedOperations.valuesParser.call(this, this.identity, this.waterline.schema, values);\n\n  // Replace associated models with their foreign key values if available.\n  // Unless the association has a custom primary key (we want to create the object)\n  values = nestedOperations.reduceAssociations.call(this, this.identity, this.waterline.schema, values, 'create');\n\n  // Cast values to proper types (handle numbers as strings)\n  values = this._cast.run(values);\n\n  return { values: values, originalValues: _values, associations: associations };\n}\n\n/**\n * Create BelongsTo Records\n *\n */\n\nfunction createBelongsTo(valuesObject, cb) {\n  var self = this;\n\n  async.each(valuesObject.associations.models, function(item, next) {\n\n    // Check if value is an object. If not don't try and create it.\n    if (!_.isPlainObject(valuesObject.values[item])) return next();\n\n    // Check for any transformations\n    var attrName = hop(self._transformer._transformations, item) ? self._transformer._transformations[item] : item;\n\n    var attribute = self._schema.schema[attrName];\n    var modelName;\n\n    if (hop(attribute, 'collection')) modelName = attribute.collection;\n    if (hop(attribute, 'model')) modelName = attribute.model;\n    if (!modelName) return next();\n\n    var model = self.waterline.collections[modelName];\n    var pkValue = valuesObject.originalValues[item][model.primaryKey];\n\n    var criteria = {};\n    criteria[model.primaryKey] = pkValue;\n\n    // If a pkValue if found, do a findOrCreate and look for a record matching the pk.\n    var query;\n    if (pkValue) {\n      query = model.findOrCreate(criteria, valuesObject.values[item]);\n    } else {\n      query = model.create(valuesObject.values[item]);\n    }\n\n    query.exec(function(err, val) {\n      if (err) return next(err);\n\n      // attach the new model's pk value to the original value's key\n      var pk = val[model.primaryKey];\n\n      valuesObject.values[item] = pk;\n      next();\n    });\n\n  }, cb);\n}\n\n/**\n * Run Before* Lifecycle Callbacks\n *\n * @param {Object} valuesObject\n * @param {Function} cb\n */\n\nfunction beforeCallbacks(valuesObject, cb) {\n  var self = this;\n\n  async.series([\n\n    // Run Validation with Validation LifeCycle Callbacks\n    function(cb) {\n      callbacks.validate(self, valuesObject.values, false, cb);\n    },\n\n    // Before Create Lifecycle Callback\n    function(cb) {\n      callbacks.beforeCreate(self, valuesObject.values, cb);\n    }\n\n  ], cb);\n\n}\n\n/**\n * Create Parent Record and any associated values\n *\n * @param {Object} valuesObject\n * @param {Function} cb\n */\n\nfunction createValues(valuesObject, cb) {\n  var self = this;\n  var date;\n\n  // Automatically add updatedAt and createdAt (if enabled)\n  if (self.autoCreatedAt) {\n    if (!valuesObject.values[self.autoCreatedAt]) {\n      date = date || new Date();\n      valuesObject.values[self.autoCreatedAt] = date;\n    }\n  }\n\n  if (self.autoUpdatedAt) {\n    if (!valuesObject.values[self.autoUpdatedAt]) {\n      date = date || new Date();\n      valuesObject.values[self.autoUpdatedAt] = date;\n    }\n  }\n\n  // Transform Values\n  valuesObject.values = self._transformer.serialize(valuesObject.values);\n\n  // Clean attributes\n  valuesObject.values = self._schema.cleanValues(valuesObject.values);\n\n  // Pass to adapter here\n  self.adapter.create(valuesObject.values, function(err, values) {\n    if (err) {\n      if (typeof err === 'object') { err.model = self._model.globalId; }\n      return cb(err);\n    }\n\n    // Unserialize values\n    values = self._transformer.unserialize(values);\n\n    // If no associations were used, run after\n    if (valuesObject.associations.collections.length === 0) return after(values);\n\n    var parentModel = new self._model(values);\n    nestedOperations.create.call(self, parentModel, valuesObject.originalValues, valuesObject.associations.collections, function(err) {\n      if (err) return cb(err);\n\n      return after(parentModel.toObject());\n    });\n\n\n    function after(values) {\n\n      // Run After Create Callbacks\n      callbacks.afterCreate(self, values, function(err) {\n        if (err) return cb(err);\n\n        // Return an instance of Model\n        var model = new self._model(values);\n        cb(null, model);\n      });\n    }\n\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/deferred.js":"/**\n * Deferred Object\n *\n * Used for building up a Query\n */\n\nvar util = require('util');\nvar Promise = require('bluebird');\nvar _ = require('lodash');\nvar normalize = require('../utils/normalize');\nvar utils = require('../utils/helpers');\nvar acyclicTraversal = require('../utils/acyclicTraversal');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n// Alias \"catch\" as \"fail\", for backwards compatibility with projects\n// that were created using Q\nPromise.prototype.fail = Promise.prototype.catch;\n\nvar Deferred = module.exports = function(context, method, criteria, values) {\n\n  if (!context) return new Error('Must supply a context to a new Deferred object. Usage: new Deferred(context, method, criteria)');\n  if (!method) return new Error('Must supply a method to a new Deferred object. Usage: new Deferred(context, method, criteria)');\n\n  this._context = context;\n  this._method = method;\n  this._criteria = criteria;\n  this._values = values || null;\n\n  this._deferred = null; // deferred object for promises\n\n  return this;\n};\n\n\n/**\n * Add join clause(s) to the criteria object to populate\n * the specified alias all the way down (or at least until a\n * circular pattern is detected.)\n *\n * @param  {String} keyName  [the initial alias aka named relation]\n * @param  {Object} criteria [optional]\n * @return this\n * @chainable\n *\n * WARNING:\n * This method is not finished yet!!\n */\nDeferred.prototype.populateDeep = function(keyName, criteria) {\n\n  // The identity of the initial model\n  var identity = this._context.identity;\n\n  // The input schema\n  var schema = this._context.waterline.schema;\n\n  // Kick off recursive function to traverse the schema graph.\n  var plan = acyclicTraversal(schema, identity, keyName);\n\n  // TODO: convert populate plan into a join plan\n  // this._criteria.joins = ....\n\n  // TODO: also merge criteria object into query\n\n  return this;\n};\n\n/**\n * Populate all associations of a collection.\n *\n * @return this\n * @chainable\n */\nDeferred.prototype.populateAll = function(criteria) {\n  var self = this;\n  this._context.associations.forEach(function(association) {\n    self.populate(association.alias, criteria);\n  });\n  return this;\n\n};\n\n/**\n * Add a `joins` clause to the criteria object.\n *\n * Used for populating associations.\n *\n * @param {String|Array} key, the key to populate or array of string keys\n * @return this\n * @chainable\n */\n\nDeferred.prototype.populate = function(keyName, criteria) {\n\n  var self = this;\n  var joins = [];\n  var pk = 'id';\n  var attr;\n  var join;\n\n  // Adds support for arrays into keyName so that a list of\n  // populates can be passed\n  if (_.isArray(keyName)) {\n    keyName.forEach(function(populate) {\n      self.populate(populate, criteria);\n    });\n    return this;\n  }\n  \n  // Normalize sub-criteria\n  try {\n    criteria = normalize.criteria(criteria);\n\n    ////////////////////////////////////////////////////////////////////////\n    // TODO:\n    // instead of doing this, target the relevant pieces of code\n    // with weird expectations and teach them a lesson\n    // e.g. `lib/waterline/query/finders/operations.js:665:12`\n    // (delete userCriteria.sort)\n    //\n    // Except make sure `where` exists\n    criteria.where = criteria.where === false ? false : (criteria.where || {});\n    ////////////////////////////////////////////////////////////////////////\n\n  } catch (e) {\n    throw new Error(\n      'Could not parse sub-criteria passed to ' +\n      util.format('`.populate(\"%s\")`', keyName) +\n      '\\nSub-criteria:\\n' + util.inspect(criteria, false, null) +\n      '\\nDetails:\\n' + util.inspect(e, false, null)\n    );\n  }\n\n  try {\n\n    // Set the attr value to the generated schema attribute\n    attr = this._context.waterline.schema[this._context.identity].attributes[keyName];\n\n    // Get the current collection's primary key attribute\n    Object.keys(this._context._attributes).forEach(function(key) {\n      if (hasOwnProperty(self._context._attributes[key], 'primaryKey') && self._context._attributes[key].primaryKey) {\n        pk = self._context._attributes[key].columnName || key;\n      }\n    });\n\n    if (!attr) {\n      throw new Error(\n        'In ' + util.format('`.populate(\"%s\")`', keyName) +\n        ', attempting to populate an attribute that doesn\\'t exist'\n      );\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // (there has been significant progress made towards both of these ///\n    // goals-- contact @mikermcneil if you want to help) /////////////////\n    //////////////////////////////////////////////////////////////////////\n    // TODO:\n    // Create synonym for `.populate()` syntax using criteria object\n    // syntax.  i.e. instead of using `joins` key in criteria object\n    // at the app level.\n    //////////////////////////////////////////////////////////////////////\n    // TODO:\n    // Support Mongoose-style `foo.bar.baz` syntax for nested `populate`s.\n    // (or something comparable.)\n    // One solution would be:\n    // .populate({\n    //   friends: {\n    //     where: { name: 'mike' },\n    //     populate: {\n    //       dentist: {\n    //         where: { name: 'rob' }\n    //       }\n    //     }\n    //   }\n    // }, optionalCriteria )\n    ////////////////////////////////////////////////////////////////////\n\n\n    // Grab the key being populated to check if it is a has many to belongs to\n    // If it's a belongs_to the adapter needs to know that it should replace the foreign key\n    // with the associated value.\n    var parentKey = this._context.waterline.collections[this._context.identity].attributes[keyName];\n\n    // Build the initial join object that will link this collection to either another collection\n    // or to a junction table.\n    join = {\n      parent: this._context.identity,\n      parentKey: attr.columnName || pk,\n      child: attr.references,\n      childKey: attr.on,\n      select: Object.keys(this._context.waterline.schema[attr.references].attributes),\n      alias: keyName,\n      removeParentKey: !!parentKey.model,\n      model: !!hasOwnProperty(parentKey, 'model'),\n      collection: !!hasOwnProperty(parentKey, 'collection')\n    };\n\n    // Build select object to use in the integrator\n    var select = [];\n    Object.keys(this._context.waterline.schema[attr.references].attributes).forEach(function(key) {\n      var obj = self._context.waterline.schema[attr.references].attributes[key];\n      if (!hasOwnProperty(obj, 'columnName')) {\n        select.push(key);\n        return;\n      }\n\n      select.push(obj.columnName);\n    });\n\n    join.select = select;\n\n    var schema = this._context.waterline.schema[attr.references];\n    var reference = null;\n\n    // If linking to a junction table the attributes shouldn't be included in the return value\n    if (schema.junctionTable) {\n      join.select = false;\n      reference = _.find(schema.attributes, function(attribute) {\n        return attribute.references && attribute.columnName !== attr.on;\n      });\n    } else if (schema.throughTable && schema.throughTable[self._context.identity + '.' + keyName]) {\n      join.select = false;\n      reference = schema.attributes[schema.throughTable[self._context.identity + '.' + keyName]];\n    }\n\n    joins.push(join);\n\n    // If a junction table is used add an additional join to get the data\n    if (reference && hasOwnProperty(attr, 'on')) {\n      // Build out the second join object that will link a junction table with the\n      // values being populated\n      var selects = _.map(_.keys(this._context.waterline.schema[reference.references].attributes), function(attr) {\n        var expandedAttr = self._context.waterline.schema[reference.references].attributes[attr];\n        return expandedAttr.columnName || attr;\n      });\n\n      join = {\n        parent: attr.references,\n        parentKey: reference.columnName,\n        child: reference.references,\n        childKey: reference.on,\n        select: selects,\n        alias: keyName,\n        junctionTable: true,\n        removeParentKey: !!parentKey.model,\n        model: false,\n        collection: true\n      };\n\n      joins.push(join);\n    }\n\n    // Append the criteria to the correct join if available\n    if (criteria && joins.length > 1) {\n      joins[1].criteria = criteria;\n    } else if (criteria) {\n      joins[0].criteria = criteria;\n    }\n\n    // Set the criteria joins\n    this._criteria.joins = Array.prototype.concat(this._criteria.joins || [], joins);\n\n    return this;\n  } catch (e) {\n    throw new Error(\n      'Encountered unexpected error while building join instructions for ' +\n      util.format('`.populate(\"%s\")`', keyName) +\n      '\\nDetails:\\n' +\n      util.inspect(e, false, null)\n    );\n  }\n};\n\n/**\n * Add a Where clause to the criteria object\n *\n * @param {Object} criteria to append\n * @return this\n */\n\nDeferred.prototype.where = function(criteria) {\n\n  if (!criteria) return this;\n\n  // If the criteria is an array of objects, wrap it in an \"or\"\n  if (Array.isArray(criteria) && _.all(criteria, function(crit) {return _.isObject(crit);})) {\n    criteria = {or: criteria};\n  }\n\n  // Normalize criteria\n  criteria = normalize.criteria(criteria);\n\n  // Wipe out the existing WHERE clause if the specified criteria ends up `false`\n  // (since neither could match anything)\n  if (criteria === false) {\n    this._criteria = false;\n  }\n\n  if (!criteria || !criteria.where) return this;\n\n  if (!this._criteria) this._criteria = {};\n  var where = this._criteria.where || {};\n\n  // Merge with existing WHERE clause\n  Object.keys(criteria.where).forEach(function(key) {\n    where[key] = criteria.where[key];\n  });\n\n  this._criteria.where = where;\n\n  return this;\n};\n\n/**\n * Add a Limit clause to the criteria object\n *\n * @param {Integer} number to limit\n * @return this\n */\n\nDeferred.prototype.limit = function(limit) {\n  this._criteria.limit = limit;\n\n  return this;\n};\n\n/**\n * Add a Skip clause to the criteria object\n *\n * @param {Integer} number to skip\n * @return this\n */\n\nDeferred.prototype.skip = function(skip) {\n  this._criteria.skip = skip;\n\n  return this;\n};\n\n/**\n * Add a Paginate clause to the criteria object\n *\n * This is syntatical sugar that calls skip and\n * limit from a single function.\n *\n * @param {Object} page and limit\n * @return this\n */\nDeferred.prototype.paginate = function(options) {\n  var defaultLimit = 10;\n\n  if (options === undefined) options = { page: 0, limit: defaultLimit };\n\n  var page = options.page || 0;\n  var limit = options.limit || defaultLimit;\n  var skip = 0;\n\n  if (page > 0 && limit === 0) skip = page - 1;\n  if (page > 0 && limit > 0) skip = (page * limit) - limit;\n\n  this\n  .skip(skip)\n  .limit(limit);\n\n  return this;\n};\n\n/**\n * Add a groupBy clause to the criteria object\n *\n * @param {Array|Arguments} Keys to group by\n * @return this\n */\nDeferred.prototype.groupBy = function() {\n  buildAggregate.call(this, 'groupBy', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n\n/**\n * Add a Sort clause to the criteria object\n *\n * @param {String|Object} key and order\n * @return this\n */\n\nDeferred.prototype.sort = function(criteria) {\n\n  if (!criteria) return this;\n\n  // Normalize criteria\n  criteria = normalize.criteria({ sort: criteria });\n\n  var sort = this._criteria.sort || {};\n\n  Object.keys(criteria.sort).forEach(function(key) {\n    sort[key] = criteria.sort[key];\n  });\n\n  this._criteria.sort = sort;\n\n  return this;\n};\n\n/**\n * Add a Sum clause to the criteria object\n *\n * @param {Array|Arguments} Keys to sum over\n * @return this\n */\nDeferred.prototype.sum = function() {\n  buildAggregate.call(this, 'sum', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n/**\n * Add an Average clause to the criteria object\n *\n * @param {Array|Arguments} Keys to average over\n * @return this\n */\nDeferred.prototype.average = function() {\n  buildAggregate.call(this, 'average', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n/**\n * Add a min clause to the criteria object\n *\n * @param {Array|Arguments} Keys to min over\n * @return this\n */\nDeferred.prototype.min = function() {\n  buildAggregate.call(this, 'min', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n/**\n * Add a min clause to the criteria object\n *\n * @param {Array|Arguments} Keys to min over\n * @return this\n */\nDeferred.prototype.max = function() {\n  buildAggregate.call(this, 'max', Array.prototype.slice.call(arguments));\n  return this;\n};\n\n\n/**\n * Add values to be used in update or create query\n *\n * @param {Object, Array} values\n * @return this\n */\n\nDeferred.prototype.set = function(values) {\n  this._values = values;\n\n  return this;\n};\n\n/**\n * Execute a Query using the method passed into the\n * constuctor.\n *\n * @param {Function} callback\n * @return callback with parameters (err, results)\n */\n\nDeferred.prototype.exec = function(cb) {\n\n  if (!cb) {\n    console.log(new Error('Error: No Callback supplied, you must define a callback.').message);\n    return;\n  }\n\n  // Normalize callback/switchback\n  cb = normalize.callback(cb);\n\n  // Set up arguments + callback\n  var args = [this._criteria, cb];\n  if (this._values) args.splice(1, 0, this._values);\n\n  // Pass control to the adapter with the appropriate arguments.\n  this._method.apply(this._context, args);\n};\n\n/**\n * Executes a Query, and returns a promise\n */\n\nDeferred.prototype.toPromise = function() {\n  if (!this._deferred) {\n    this._deferred = Promise.promisify(this.exec).bind(this)();\n  }\n  return this._deferred;\n};\n\n/**\n * Executes a Query, and returns a promise that applies cb/ec to the\n * result/error.\n */\n\nDeferred.prototype.then = function(cb, ec) {\n  return this.toPromise().then(cb, ec);\n};\n\n/**\n * Applies results to function fn.apply, and returns a promise\n */\n\nDeferred.prototype.spread = function(cb) {\n  return this.toPromise().spread(cb);\n};\n\n/**\n * returns a promise and gets resolved with error\n */\n\nDeferred.prototype.catch = function(cb) {\n  return this.toPromise().catch(cb);\n};\n\n\n/**\n * Alias \"catch\" as \"fail\"\n */\nDeferred.prototype.fail = Deferred.prototype.catch;\n\n/**\n * Build An Aggregate Criteria Option\n *\n * @param {String} key\n * @api private\n */\n\nfunction buildAggregate(key, args) {\n\n  // If passed in a list, set that as the min criteria\n  if (args[0] instanceof Array) {\n    args = args[0];\n  }\n\n  this._criteria[key] = args || {};\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/acyclicTraversal.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\n\n\n/**\n * Traverse the shema to build a populate plan object\n * that will populate every relation, sub-relation, and so on\n * reachable from the initial model and relation at least once\n * (perhaps most notable is that this provides access to most\n * related data without getting caught in loops.)\n *\n * @param  {[type]} schema          [description]\n * @param  {[type]} initialModel    [description]\n * @param  {[type]} initialRelation [description]\n * @return {[type]}                 [description]\n */\nmodule.exports = function acyclicTraversal(schema, initialModel, initialRelation) {\n\n  // Track the edges which have already been traversed\n  var alreadyTraversed = [\n    // {\n    //   relation: initialRelation,\n    //   model: initialModel\n    // }\n  ];\n\n  return traverseSchemaGraph(initialModel, initialRelation);\n\n  /**\n   * Recursive function\n   * @param  {[type]} modelIdentity  [description]\n   * @param  {[type]} nameOfRelation [description]\n   * @return {[type]}                [description]\n   */\n  function traverseSchemaGraph(modelIdentity, nameOfRelation) {\n\n    var currentModel = schema[modelIdentity];\n    var currentAttributes = currentModel.attributes;\n\n    var isRedundant;\n\n    // If this relation has already been traversed, return.\n    // (i.e. `schema.attributes.modelIdentity.nameOfRelation`)\n    isRedundant = _.findWhere(alreadyTraversed, {\n      alias: nameOfRelation,\n      model: modelIdentity\n    });\n\n    if (isRedundant) return;\n\n    // Push this relation onto the `alreadyTraversed` stack.\n    alreadyTraversed.push({\n      alias: nameOfRelation,\n      model: modelIdentity\n    });\n\n\n    var relation = currentAttributes[nameOfRelation];\n    if (!relation) throw new Error('Unknown relation in schema: ' + modelIdentity + '.' + nameOfRelation);\n    var identityOfRelatedModel = relation.model || relation.collection;\n\n    // Get the related model\n    var relatedModel = schema[identityOfRelatedModel];\n\n    // If this relation is a collection with a `via` back-reference,\n    // push it on to the `alreadyTraversed` stack.\n    // (because the information therein is probably redundant)\n    // TODO: evaluate this-- it may or may not be a good idea\n    // (but I think it's a nice touch)\n    if (relation.via) {\n      alreadyTraversed.push({\n        alias: relation.via,\n        model: identityOfRelatedModel\n      });\n    }\n\n    // Lookup ALL the relations OF THE RELATED model.\n    var relations =\n      _(relatedModel.attributes).reduce(function buildSubsetOfAssociations(relations, attrDef, attrName) {\n        if (_.isObject(attrDef) && (attrDef.model || attrDef.collection)) {\n          relations.push(_.merge({\n            alias: attrName,\n            identity: attrDef.model || attrDef.collection,\n            cardinality: attrDef.model ? 'model' : 'collection'\n          }, attrDef));\n          return relations;\n        }\n        return relations;\n      }, []);\n\n    // Return a piece of the result plan by calling `traverseSchemaGraph`\n    // on each of the RELATED model's relations.\n    return _.reduce(relations, function(resultPlanPart, relation) {\n\n      // Recursive step\n      resultPlanPart[relation.alias] = traverseSchemaGraph(identityOfRelatedModel, relation.alias);\n\n      // Trim undefined result plan parts\n      if (resultPlanPart[relation.alias] === undefined) {\n        delete resultPlanPart[relation.alias];\n      }\n\n      return resultPlanPart;\n    }, {});\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/callbacksRunner.js":"/**\n * Module Dependencies\n */\n\nvar async = require('async');\n\n/**\n * Run Lifecycle Callbacks\n */\n\nvar runner = module.exports = {};\n\n\n/**\n * Run Validation Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Boolean} presentOnly\n * @param {Function} cb\n * @api public\n */\n\nrunner.validate = function(context, values, presentOnly, cb) {\n  context.validate(values, presentOnly, cb);\n};\n\n\n/**\n * Run Before Create Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.beforeCreate = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.beforeCreate, fn, cb);\n};\n\n\n/**\n * Run After Create Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.afterCreate = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.afterCreate, fn, cb);\n};\n\n\n/**\n * Run Before Update Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.beforeUpdate = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.beforeUpdate, fn, cb);\n};\n\n\n/**\n * Run After Update Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.afterUpdate = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.afterUpdate, fn, cb);\n};\n\n\n/**\n * Run Before Destroy Callbacks\n *\n * @param {Object} context\n * @param {Object} criteria\n * @param {Function} cb\n * @api public\n */\n\nrunner.beforeDestroy = function(context, criteria, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, criteria, next);\n  };\n\n  async.eachSeries(context._callbacks.beforeDestroy, fn, cb);\n};\n\n\n/**\n * Run After Destroy Callbacks\n *\n * @param {Object} context\n * @param {Object} values\n * @param {Function} cb\n * @api public\n */\n\nrunner.afterDestroy = function(context, values, cb) {\n\n  var fn = function(item, next) {\n    item.call(context, values, next);\n  };\n\n  async.eachSeries(context._callbacks.afterDestroy, fn, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/dql/update.js":"/**\n * Module Dependencies\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar Deferred = require('../deferred');\nvar callbacks = require('../../utils/callbacksRunner');\nvar nestedOperations = require('../../utils/nestedOperations');\nvar hop = utils.object.hasOwnProperty;\n\n\n/**\n * Update all records matching criteria\n *\n * @param {Object} criteria\n * @param {Object} values\n * @param {Function} cb\n * @return Deferred object if no callback\n */\n\nmodule.exports = function(criteria, values, cb) {\n\n  var self = this;\n\n  if (typeof criteria === 'function') {\n    cb = criteria;\n    criteria = null;\n  }\n\n  // Return Deferred or pass to adapter\n  if (typeof cb !== 'function') {\n    return new Deferred(this, this.update, criteria, values);\n  }\n\n  // If there was something defined in the criteria that would return no results, don't even\n  // run the query and just return an empty result set.\n  if (criteria === false) {\n    return cb(null, []);\n  }\n\n  // Ensure proper function signature\n  var usage = utils.capitalize(this.identity) + '.update(criteria, values, callback)';\n  if (!values) return usageError('No updated values specified!', usage, cb);\n\n  // Format Criteria and Values\n  var valuesObject = prepareArguments.call(this, criteria, values);\n\n  // Create any of the belongsTo associations and set the foreign key values\n  createBelongsTo.call(this, valuesObject, function(err) {\n    if (err) return cb(err);\n\n    beforeCallbacks.call(self, valuesObject.values, function(err) {\n      if (err) return cb(err);\n      updateRecords.call(self, valuesObject, cb);\n    });\n  });\n};\n\n\n/**\n * Prepare Arguments\n *\n * @param {Object} criteria\n * @param {Object} values\n * @return {Object}\n */\n\nfunction prepareArguments(criteria, values) {\n\n  // Check if options is an integer or string and normalize criteria\n  // to object, using the specified primary key field.\n  criteria = normalize.expandPK(this, criteria);\n\n  // Normalize criteria\n  criteria = normalize.criteria(criteria);\n\n  // Pull out any associations in the values\n  var _values = _.cloneDeep(values);\n  var associations = nestedOperations.valuesParser.call(this, this.identity, this.waterline.schema, values);\n\n  // Replace associated models with their foreign key values if available.\n  // Unless the association has a custom primary key (we want to create the object)\n  values = nestedOperations.reduceAssociations.call(this, this.identity, this.waterline.schema, values, 'update');\n\n  // Cast values to proper types (handle numbers as strings)\n  values = this._cast.run(values);\n\n  return {\n    criteria: criteria,\n    values: values,\n    originalValues: _values,\n    associations: associations\n  };\n}\n\n/**\n * Create BelongsTo Records\n *\n */\n\nfunction createBelongsTo(valuesObject, cb) {\n  var self = this;\n\n  async.each(valuesObject.associations.models.slice(0), function(item, next) {\n\n    // Check if value is an object. If not don't try and create it.\n    if (!_.isPlainObject(valuesObject.values[item])) return next();\n\n    // Check for any transformations\n    var attrName = hop(self._transformer._transformations, item) ? self._transformer._transformations[item] : item;\n\n    var attribute = self._schema.schema[attrName];\n    var modelName;\n\n    if (hop(attribute, 'collection')) modelName = attribute.collection;\n    if (hop(attribute, 'model')) modelName = attribute.model;\n    if (!modelName) return next();\n\n    var model = self.waterline.collections[modelName];\n    var pkValue = valuesObject.originalValues[item][model.primaryKey];\n\n    var criteria = {};\n\n    var pkField = hop(model._transformer._transformations, model.primaryKey) ? model._transformer._transformations[model.primaryKey] : model.primaryKey;\n\n    criteria[pkField] = pkValue;\n\n    // If a pkValue if found, do a findOrCreate and look for a record matching the pk.\n    var query;\n    if (pkValue) {\n      query = model.findOrCreate(criteria, valuesObject.values[item]);\n    } else {\n      query = model.create(valuesObject.values[item]);\n    }\n\n    query.exec(function(err, val) {\n      if (err) return next(err);\n\n      // attach the new model's pk value to the original value's key\n      var pk = val[model.primaryKey];\n\n      valuesObject.values[item] = pk;\n\n      // now we have pk value attached, remove it from models\n      _.remove(valuesObject.associations.models, function(_item) { return _item == item; });\n      next();\n    });\n\n  }, cb);\n}\n\n/**\n * Run Before* Lifecycle Callbacks\n *\n * @param {Object} values\n * @param {Function} cb\n */\n\nfunction beforeCallbacks(values, cb) {\n  var self = this;\n\n  async.series([\n\n    // Run Validation with Validation LifeCycle Callbacks\n    function(cb) {\n      callbacks.validate(self, values, true, cb);\n    },\n\n    // Before Update Lifecycle Callback\n    function(cb) {\n      callbacks.beforeUpdate(self, values, cb);\n    }\n\n  ], cb);\n}\n\n/**\n * Update Records\n *\n * @param {Object} valuesObjecy\n * @param {Function} cb\n */\n\nfunction updateRecords(valuesObject, cb) {\n  var self = this;\n\n  // Automatically change updatedAt (if enabled)\n  if (this.autoUpdatedAt) {\n    // take into account that the autoUpdateAt attribute may be a string with a different column name\n    valuesObject.values[self.autoUpdatedAt] = new Date();\n  }\n\n  // Transform Values\n  valuesObject.values = this._transformer.serialize(valuesObject.values);\n\n  // Clean attributes\n  valuesObject.values = this._schema.cleanValues(valuesObject.values);\n\n  // Transform Search Criteria\n  valuesObject.criteria = self._transformer.serialize(valuesObject.criteria);\n\n\n  // Pass to adapter\n  self.adapter.update(valuesObject.criteria, valuesObject.values, function(err, values) {\n    if (err) {\n      if (typeof err === 'object') { err.model = self._model.globalId; }\n      return cb(err);\n    }\n\n    // If values is not an array, return an array\n    if (!Array.isArray(values)) values = [values];\n\n    // Unserialize each value\n    var transformedValues = values.map(function(value) {\n      return self._transformer.unserialize(value);\n    });\n\n    // Update any nested associations and run afterUpdate lifecycle callbacks for each parent\n    updatedNestedAssociations.call(self, valuesObject, transformedValues, function(err) {\n      if (err) return cb(err);\n\n      async.each(transformedValues, function(record, callback) {\n        callbacks.afterUpdate(self, record, callback);\n      }, function(err) {\n        if (err) return cb(err);\n\n        var models = transformedValues.map(function(value) {\n          return new self._model(value);\n        });\n\n        cb(null, models);\n      });\n    });\n\n  });\n}\n\n/**\n * Update Nested Associations\n *\n * @param {Object} valuesObject\n * @param {Object} values\n * @param {Function} cb\n */\n\nfunction updatedNestedAssociations(valuesObject, values, cb) {\n\n  var self = this;\n  var associations = valuesObject.associations || {};\n\n  // Only attempt nested updates if values are an object or an array\n  associations.models = _.filter(associations.models, function(model) {\n    var vals = valuesObject.originalValues[model];\n    return _.isPlainObject(vals) || Array.isArray(vals);\n  });\n\n  // If no associations were used, return callback\n  if (associations.collections.length === 0 && associations.models.length === 0) {\n    return cb();\n  }\n\n  // Create an array of model instances for each parent\n  var parents = values.map(function(val) {\n    return new self._model(val);\n  });\n\n  // Update any nested associations found in the values object\n  var args = [parents, valuesObject.originalValues, valuesObject.associations, cb];\n  nestedOperations.update.apply(self, args);\n\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/usageError.js":"/**\n * Create a nicely formatted usage error\n */\n\nmodule.exports = function(err, usage, cb) {\n  var message = err + '\\n==============================================\\nProper usage :: \\n' + usage + '\\n==============================================\\n';\n  if (cb) return cb(message);\n  throw new Error(message);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/dql/destroy.js":"/**\n * Module Dependencies\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar Deferred = require('../deferred');\nvar getRelations = require('../../utils/getRelations');\nvar callbacks = require('../../utils/callbacksRunner');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Destroy a Record\n *\n * @param {Object} criteria to destroy\n * @param {Function} callback\n * @return Deferred object if no callback\n */\n\nmodule.exports = function(criteria, cb) {\n  var self = this;\n  var pk;\n\n  if (typeof criteria === 'function') {\n    cb = criteria;\n    criteria = {};\n  }\n\n  // Check if criteria is an integer or string and normalize criteria\n  // to object, using the specified primary key field.\n  criteria = normalize.expandPK(self, criteria);\n\n  // Normalize criteria\n  criteria = normalize.criteria(criteria);\n\n  // Return Deferred or pass to adapter\n  if (typeof cb !== 'function') {\n    return new Deferred(this, this.destroy, criteria);\n  }\n\n  var usage = utils.capitalize(this.identity) + '.destroy([options], callback)';\n  if (typeof cb !== 'function') return usageError('Invalid callback specified!', usage, cb);\n\n  // If there was something defined in the criteria that would return no results, don't even\n  // run the query and just return an empty result set.\n  if (criteria === false) {\n    return cb(null, []);\n  }\n\n  callbacks.beforeDestroy(self, criteria, function(err) {\n    if (err) return cb(err);\n\n    // Transform Search Criteria\n    criteria = self._transformer.serialize(criteria);\n\n    // Pass to adapter\n    self.adapter.destroy(criteria, function(err, result) {\n      if (err) return cb(err);\n\n      // Look for any m:m associations and destroy the value in the join table\n      var relations = getRelations({\n        schema: self.waterline.schema,\n        parentCollection: self.identity\n      });\n\n      if (relations.length === 0) return after();\n\n      // Find the collection's primary key\n      for (var key in self.attributes) {\n        if (!self.attributes[key].hasOwnProperty('primaryKey')) continue;\n\n        // Check if custom primaryKey value is falsy\n        if (!self.attributes[key].primaryKey) continue;\n\n        if (self.attributes[key].columnName) {\n          pk = self.attributes[key].columnName;\n        } else {\n          pk = key;\n        }\n\n        break;\n      }\n\n      function destroyJoinTableRecords(item, next) {\n        var collection = self.waterline.collections[item];\n        var refKey = [];\n\n        Object.keys(collection._attributes).forEach(function(key) {\n          var attr = collection._attributes[key];\n          if (attr.references !== self.identity) return;\n          refKey.push(key);\n        });\n\n        // If no refKey return, this could leave orphaned join table values but it's better\n        // than crashing.\n        if (!refKey.length) return next();\n\n        // Make sure we don't return any undefined pks\n        var mappedValues = result.reduce(function(memo, vals) {\n          if (vals[pk] !== undefined) {\n            memo.push(vals[pk]);\n          }\n          return memo;\n        }, []);\n\n        var criteria = {};\n\n        if (mappedValues.length > 0) {\n          // Handle reflexive associations by building up an OR clause.\n          if (refKey.length > 1) {\n            var orCriteria = [];\n            _.each(refKey, function(columnName) {\n              var where = {};\n              where[columnName] = mappedValues;\n              orCriteria.push(where);\n            });\n\n            criteria = {\n              or: orCriteria\n            };\n          } else {\n            criteria[_.first(refKey)] = mappedValues;\n          }\n\n          collection.destroy(criteria).exec(next);\n        } else {\n          return next();\n        }\n\n      }\n\n      async.each(relations, destroyJoinTableRecords, function(err) {\n        if (err) return cb(err);\n        after();\n      });\n\n      function after() {\n\n        // If no result was returned, default to empty array\n        if (!result) {\n          result = [];\n        }\n\n        // If values is not an array, return an array\n        if (!Array.isArray(result)) {\n          result = [result];\n        }\n\n        // Unserialize each value\n        var transformedValues = result.map(function(value) {\n          return self._transformer.unserialize(value);\n        });\n\n        callbacks.afterDestroy(self, transformedValues, function(err) {\n          if (err) return cb(err);\n          cb(null, transformedValues);\n        });\n      }\n\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/dql/count.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar Deferred = require('../deferred');\n\n/**\n * Count of Records\n *\n * @param {Object} criteria\n * @param {Object} options\n * @param {Function} callback\n * @return Deferred object if no callback\n */\n\nmodule.exports = function(criteria, options, cb) {\n  var usage = utils.capitalize(this.identity) + '.count([criteria],[options],callback)';\n\n  if (typeof criteria === 'function') {\n    cb = criteria;\n    criteria = null;\n    options = null;\n  }\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  // Return Deferred or pass to adapter\n  if (typeof cb !== 'function') {\n    return new Deferred(this, this.count, criteria);\n  }\n\n  // Normalize criteria and fold in options\n  criteria = normalize.criteria(criteria);\n\n  // If there was something defined in the criteria that would return no results, don't even\n  // run the query and just return 0\n  if (criteria === false) {\n    return cb(null, 0);\n  }\n\n  if (_.isObject(options) && _.isObject(criteria)) {\n    criteria = _.extend({}, criteria, options);\n  }\n\n  if (_.isFunction(criteria) || _.isFunction(options)) {\n    return usageError('Invalid options specified!', usage, cb);\n  }\n\n  // Transform Search Criteria\n  criteria = this._transformer.serialize(criteria);\n\n  // Remove any joins from the count criteria. They won't have any effect on the\n  // number of results found.\n  if (_.isArray(criteria.joins)) {\n    delete criteria.joins;\n  }\n\n  if (criteria.where && _.isArray(criteria.where.joins)) {\n    delete criteria.where.joins;\n  }\n\n  this.adapter.count(criteria, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/dql/join.js":"/**\n * Join\n *\n * Join with another collection\n * (use optimized join in adapter if one was provided)\n */\n\nmodule.exports = function(collection, fk, pk, cb) {\n  this._adapter.join(collection, fk, pk, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/aggregate.js":"/**\n * Aggregate Queries\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar usageError = require('../utils/usageError');\nvar utils = require('../utils/helpers');\nvar normalize = require('../utils/normalize');\nvar callbacks = require('../utils/callbacksRunner');\nvar Deferred = require('./deferred');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\nmodule.exports = {\n\n  /**\n   * Create an Array of records\n   *\n   * @param {Array} array of values to create\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  createEach: function(valuesList, cb) {\n    var self = this;\n\n    // Handle Deferred where it passes criteria first\n    if (arguments.length === 3) {\n      var args = Array.prototype.slice.call(arguments);\n      cb = args.pop();\n      valuesList = args.pop();\n    }\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.createEach, {}, valuesList);\n    }\n\n    // Validate Params\n    var usage = utils.capitalize(this.identity) + '.createEach(valuesList, callback)';\n\n    if (!valuesList) return usageError('No valuesList specified!', usage, cb);\n    if (!Array.isArray(valuesList)) return usageError('Invalid valuesList specified (should be an array!)', usage, cb);\n    if (typeof cb !== 'function') return usageError('Invalid callback specified!', usage, cb);\n\n    var errStr = _validateValues(_.cloneDeep(valuesList));\n    if (errStr) return usageError(errStr, usage, cb);\n\n    // Handle undefined values\n    var filteredValues = _.filter(valuesList, function(value) {\n      return value !== undefined;\n    });\n\n    // Create will take care of cloning values so original isn't mutated\n    async.map(filteredValues, self.create.bind(self), cb);\n  },\n\n  /**\n   * Iterate through a list of objects, trying to find each one\n   * For any that don't exist, create them\n   *\n   * @param {Object} criteria\n   * @param {Array} valuesList\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  findOrCreateEach: function(criteria, valuesList, cb) {\n    var self = this;\n\n    if (typeof valuesList === 'function') {\n      cb = valuesList;\n      valuesList = null;\n    }\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.findOrCreateEach, criteria, valuesList);\n    }\n\n    // Validate Params\n    var usage = utils.capitalize(this.identity) + '.findOrCreateEach(criteria, valuesList, callback)';\n\n    if (typeof cb !== 'function') return usageError('Invalid callback specified!', usage, cb);\n    if (!criteria) return usageError('No criteria specified!', usage, cb);\n    if (!Array.isArray(criteria)) return usageError('No criteria specified!', usage, cb);\n    if (!valuesList) return usageError('No valuesList specified!', usage, cb);\n    if (!Array.isArray(valuesList)) return usageError('Invalid valuesList specified (should be an array!)', usage, cb);\n\n    var errStr = _validateValues(valuesList);\n    if (errStr) return usageError(errStr, usage, cb);\n\n    // Validate each record in the array and if all are valid\n    // pass the array to the adapter's findOrCreateEach method\n    var validateItem = function(item, next) {\n      _validate.call(self, item, next);\n    };\n\n\n    async.each(valuesList, validateItem, function(err) {\n      if (err) return cb(err);\n\n      // Transform Values\n      var transformedValues = [];\n\n      valuesList.forEach(function(value) {\n\n        // Transform values\n        value = self._transformer.serialize(value);\n\n        // Clean attributes\n        value = self._schema.cleanValues(value);\n        transformedValues.push(value);\n      });\n\n      // Set values array to the transformed array\n      valuesList = transformedValues;\n\n      // Transform Search Criteria\n      var transformedCriteria = [];\n\n      criteria.forEach(function(value) {\n        value = self._transformer.serialize(value);\n        transformedCriteria.push(value);\n      });\n\n      // Set criteria array to the transformed array\n      criteria = transformedCriteria;\n\n      // Pass criteria and attributes to adapter definition\n      self.adapter.findOrCreateEach(criteria, valuesList, function(err, values) {\n        if (err) return cb(err);\n\n        // Unserialize Values\n        var unserializedValues = [];\n\n        values.forEach(function(value) {\n          value = self._transformer.unserialize(value);\n          unserializedValues.push(value);\n        });\n\n        // Set values array to the transformed array\n        values = unserializedValues;\n\n        // Run AfterCreate Callbacks\n        async.each(values, function(item, next) {\n          callbacks.afterCreate(self, item, next);\n        }, function(err) {\n          if (err) return cb(err);\n\n          var models = [];\n\n          // Make each result an instance of model\n          values.forEach(function(value) {\n            models.push(new self._model(value));\n          });\n\n          cb(null, models);\n        });\n      });\n    });\n  }\n};\n\n\n/**\n * Validate valuesList\n *\n * @param {Array} valuesList\n * @return {String}\n * @api private\n */\n\nfunction _validateValues(valuesList) {\n  var err;\n\n  for (var i = 0; i < valuesList.length; i++) {\n    if (valuesList[i] !== Object(valuesList[i])) {\n      err = 'Invalid valuesList specified (should be an array of valid values objects!)';\n    }\n  }\n\n  return err;\n}\n\n\n/**\n * Validate values and add in default values\n *\n * @param {Object} record\n * @param {Function} cb\n * @api private\n */\n\nfunction _validate(record, cb) {\n  var self = this;\n\n  // Set Default Values if available\n  for (var key in self.attributes) {\n    if (!record[key] && record[key] !== false && hasOwnProperty(self.attributes[key], 'defaultsTo')) {\n      var defaultsTo = self.attributes[key].defaultsTo;\n      record[key] = typeof defaultsTo === 'function' ? defaultsTo.call(record) : _.clone(defaultsTo);\n    }\n  }\n\n  // Cast values to proper types (handle numbers as strings)\n  record = self._cast.run(record);\n\n  async.series([\n\n    // Run Validation with Validation LifeCycle Callbacks\n    function(next) {\n      callbacks.validate(self, record, true, next);\n    },\n\n    // Before Create Lifecycle Callback\n    function(next) {\n      callbacks.beforeCreate(self, record, next);\n    }\n\n  ], function(err) {\n    if (err) return cb(err);\n\n    // Automatically add updatedAt and createdAt (if enabled)\n    if (self.autoCreatedAt) {\n      record[self.autoCreatedAt] = new Date();\n    }\n\n    if (self.autoUpdatedAt) {\n      record[self.autoUpdatedAt] = new Date();\n    }\n\n    cb();\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/composite.js":"/**\n * Composite Queries\n */\n\nvar async = require('async');\nvar _ = require('lodash');\nvar usageError = require('../utils/usageError');\nvar utils = require('../utils/helpers');\nvar normalize = require('../utils/normalize');\nvar Deferred = require('./deferred');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\nmodule.exports = {\n\n  /**\n   * Find or Create a New Record\n   *\n   * @param {Object} search criteria\n   * @param {Object} values to create if no record found\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  findOrCreate: function(criteria, values, cb) {\n    var self = this;\n\n    if (typeof values === 'function') {\n      cb = values;\n      values = null;\n    }\n\n    // If no criteria is specified, bail out with a vengeance.\n    var usage = utils.capitalize(this.identity) + '.findOrCreate([criteria], values, callback)';\n    if (typeof cb == 'function' && (!criteria || criteria.length === 0)) {\n      return usageError('No criteria option specified!', usage, cb);\n    }\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n    // If no values were specified, use criteria\n    if (!values) values = criteria.where ? criteria.where : criteria;\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.findOrCreate, criteria, values);\n    }\n\n    // This is actually an implicit call to findOrCreateEach\n    if (Array.isArray(criteria) && Array.isArray(values)) {\n      return this.findOrCreateEach(criteria, values, cb);\n    }\n\n    if (typeof cb !== 'function') return usageError('Invalid callback specified!', usage, cb);\n\n    // Try a find first.\n    this.find(criteria).exec(function(err, results) {\n      if (err) return cb(err);\n\n      if (results && results.length !== 0) {\n\n        // Unserialize values\n        results = self._transformer.unserialize(results[0]);\n\n        // Return an instance of Model\n        var model = new self._model(results);\n        return cb(null, model);\n      }\n\n      // Create a new record if nothing is found.\n      self.create(values).exec(function(err, result) {\n        if (err) return cb(err);\n        return cb(null, result);\n      });\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/finders/basic.js":"/**\n * Basic Finder Queries\n */\n\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar sorter = require('../../utils/sorter');\nvar Deferred = require('../deferred');\nvar Joins = require('./joins');\nvar Operations = require('./operations');\nvar Integrator = require('../integrator');\nvar waterlineCriteria = require('waterline-criteria');\nvar _ = require('lodash');\nvar async = require('async');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\nmodule.exports = {\n\n  /**\n   * Find a single record that meets criteria\n   *\n   * @param {Object} criteria to search\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  findOne: function(criteria, cb) {\n    var self = this;\n\n    if (typeof criteria === 'function') {\n      cb = criteria;\n      criteria = null;\n    }\n\n    // If the criteria is an array of objects, wrap it in an \"or\"\n    if (Array.isArray(criteria) && _.all(criteria, function(crit) {return _.isObject(crit);})) {\n      criteria = {or: criteria};\n    }\n\n    // Check if criteria is an integer or string and normalize criteria\n    // to object, using the specified primary key field.\n    criteria = normalize.expandPK(self, criteria);\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.findOne, criteria);\n    }\n\n    // Transform Search Criteria\n    criteria = self._transformer.serialize(criteria);\n\n    // serialize populated object\n    if (criteria.joins) {\n      criteria.joins.forEach(function(join) {\n        if (join.criteria && join.criteria.where) {\n          var joinCollection = self.waterline.collections[join.child];\n          join.criteria.where = joinCollection._transformer.serialize(join.criteria.where);\n        }\n      });\n    }\n\n    // If there was something defined in the criteria that would return no results, don't even\n    // run the query and just return an empty result set.\n    if (criteria === false || criteria.where === null) {\n      // Build Default Error Message\n      var err = '.findOne() requires a criteria. If you want the first record try .find().limit(1)';\n      return cb(new Error(err));\n    }\n\n    // Build up an operations set\n    var operations = new Operations(self, criteria, 'findOne');\n\n    // Run the operations\n    operations.run(function(err, values) {\n      if (err) return cb(err);\n      if (!values.cache) return cb();\n\n      // If no joins are used grab the only item from the cache and pass to the returnResults\n      // function.\n      if (!criteria.joins) {\n        values = values.cache[self.identity];\n        return returnResults(values);\n      }\n\n      // If the values are already combined, return the results\n      if (values.combined) {\n        return returnResults(values.cache[self.identity]);\n      }\n\n      // Find the primaryKey of the current model so it can be passed down to the integrator.\n      // Use 'id' as a good general default;\n      var primaryKey = 'id';\n\n      Object.keys(self._schema.schema).forEach(function(key) {\n        if (self._schema.schema[key].hasOwnProperty('primaryKey') && self._schema.schema[key].primaryKey) {\n          primaryKey = key;\n        }\n      });\n\n\n      // Perform in-memory joins\n      Integrator(values.cache, criteria.joins, primaryKey, function(err, results) {\n        if (err) return cb(err);\n        if (!results) return cb();\n\n        // We need to run one last check on the results using the criteria. This allows a self\n        // association where we end up with two records in the cache both having each other as\n        // embedded objects and we only want one result. However we need to filter any join criteria\n        // out of the top level where query so that searchs by primary key still work.\n        var tmpCriteria = _.cloneDeep(criteria.where);\n        if (!tmpCriteria) tmpCriteria = {};\n\n        criteria.joins.forEach(function(join) {\n          if (!hasOwnProperty(join, 'alias')) return;\n\n          // Check for `OR` criteria\n          if (hasOwnProperty(tmpCriteria, 'or')) {\n            tmpCriteria.or.forEach(function(search) {\n              if (!hasOwnProperty(search, join.alias)) return;\n              delete search[join.alias];\n            });\n          }\n\n          if (!hasOwnProperty(tmpCriteria, join.alias)) return;\n          delete tmpCriteria[join.alias];\n        });\n\n        // Pass results into Waterline-Criteria\n        var _criteria = { where: tmpCriteria };\n        results = waterlineCriteria('parent', { parent: results }, _criteria).results;\n\n        results.forEach(function(res) {\n\n          // Go Ahead and perform any sorts on the associated data\n          criteria.joins.forEach(function(join) {\n            if (!join.criteria) return;\n            var c = normalize.criteria(join.criteria);\n            if (!c.sort) return;\n\n            var alias = join.alias;\n            res[alias] = sorter(res[alias], c.sort);\n          });\n        });\n\n        returnResults(results);\n      });\n\n      function returnResults(results) {\n\n        if (!results) return cb();\n\n        // Normalize results to an array\n        if (!Array.isArray(results) && results) results = [results];\n\n        // Unserialize each of the results before attempting any join logic on them\n        var unserializedModels = [];\n        results.forEach(function(result) {\n          unserializedModels.push(self._transformer.unserialize(result));\n        });\n\n        var models = [];\n        var joins = criteria.joins ? criteria.joins : [];\n        var data = new Joins(joins, unserializedModels, self.identity, self._schema.schema, self.waterline.collections);\n\n        // If `data.models` is invalid (not an array) return early to avoid getting into trouble.\n        if (!data || !data.models || !data.models.forEach) {\n          return cb(new Error('Values returned from operations set are not an array...'));\n        }\n\n        // Create a model for the top level values\n        data.models.forEach(function(model) {\n          models.push(new self._model(model, data.options));\n        });\n\n        cb(null, models[0]);\n      }\n    });\n  },\n\n  /**\n   * Find All Records that meet criteria\n   *\n   * @param {Object} search criteria\n   * @param {Object} options\n   * @param {Function} callback\n   * @return Deferred object if no callback\n   */\n\n  find: function(criteria, options, cb) {\n    var self = this;\n\n    var usage = utils.capitalize(this.identity) + '.find([criteria],[options]).exec(callback|switchback)';\n\n    if (typeof criteria === 'function') {\n      cb = criteria;\n      criteria = null;\n      options = null;\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    // If the criteria is an array of objects, wrap it in an \"or\"\n    if (Array.isArray(criteria) && _.all(criteria, function(crit) {return _.isObject(crit);})) {\n      criteria = {or: criteria};\n    }\n\n    // Check if criteria is an integer or string and normalize criteria\n    // to object, using the specified primary key field.\n    criteria = normalize.expandPK(self, criteria);\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n\n    // Validate Arguments\n    if (typeof criteria === 'function' || typeof options === 'function') {\n      return usageError('Invalid options specified!', usage, cb);\n    }\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.find, criteria, options);\n    }\n\n    // If there was something defined in the criteria that would return no results, don't even\n    // run the query and just return an empty result set.\n    if (criteria === false) {\n      return cb(null, []);\n    }\n\n    // Fold in options\n    if (options === Object(options) && criteria === Object(criteria)) {\n      criteria = _.extend({}, criteria, options);\n    }\n\n    // Transform Search Criteria\n    if (!self._transformer) {\n      throw new Error('Waterline can not access transformer-- maybe the context of the method is being overridden?');\n    }\n\n    criteria = self._transformer.serialize(criteria);\n\n    // serialize populated object\n    if (criteria.joins) {\n      criteria.joins.forEach(function(join) {\n        if (join.criteria && join.criteria.where) {\n          var joinCollection = self.waterline.collections[join.child];\n          join.criteria.where = joinCollection._transformer.serialize(join.criteria.where);\n        }\n      });\n    }\n\n    // Build up an operations set\n    var operations = new Operations(self, criteria, 'find');\n\n    // Run the operations\n    operations.run(function(err, values) {\n      if (err) return cb(err);\n      if (!values.cache) return cb();\n\n      // If no joins are used grab current collection's item from the cache and pass to the returnResults\n      // function.\n      if (!criteria.joins) {\n        values = values.cache[self.identity];\n        return returnResults(values);\n      }\n\n      // If the values are already combined, return the results\n      if (values.combined) {\n        return returnResults(values.cache[self.identity]);\n      }\n\n      // Find the primaryKey of the current model so it can be passed down to the integrator.\n      // Use 'id' as a good general default;\n      var primaryKey = 'id';\n\n      Object.keys(self._schema.schema).forEach(function(key) {\n        if (self._schema.schema[key].hasOwnProperty('primaryKey') && self._schema.schema[key].primaryKey) {\n          primaryKey = key;\n        }\n      });\n\n      // Perform in-memory joins\n      Integrator(values.cache, criteria.joins, primaryKey, function(err, results) {\n        if (err) return cb(err);\n        if (!results) return cb();\n\n        // We need to run one last check on the results using the criteria. This allows a self\n        // association where we end up with two records in the cache both having each other as\n        // embedded objects and we only want one result. However we need to filter any join criteria\n        // out of the top level where query so that searchs by primary key still work.\n        var tmpCriteria = _.cloneDeep(criteria.where);\n        if (!tmpCriteria) tmpCriteria = {};\n\n        criteria.joins.forEach(function(join) {\n          if (!hasOwnProperty(join, 'alias')) return;\n\n          // Check for `OR` criteria\n          if (hasOwnProperty(tmpCriteria, 'or')) {\n            tmpCriteria.or.forEach(function(search) {\n              if (!hasOwnProperty(search, join.alias)) return;\n              delete search[join.alias];\n            });\n          }\n\n          if (!hasOwnProperty(tmpCriteria, join.alias)) return;\n          delete tmpCriteria[join.alias];\n        });\n\n        // Pass results into Waterline-Criteria\n        var _criteria = { where: tmpCriteria };\n        results = waterlineCriteria('parent', { parent: results }, _criteria).results;\n\n        // Serialize values coming from an in-memory join before modelizing\n        var _results = [];\n        results.forEach(function(res) {\n\n          // Go Ahead and perform any sorts on the associated data\n          criteria.joins.forEach(function(join) {\n            if (!join.criteria) return;\n            var c = normalize.criteria(join.criteria);\n            var alias = join.alias;\n            if (c.sort) {\n              res[alias] = sorter(res[alias], c.sort);\n            }\n\n            // If a junction table was used we need to do limit and skip in-memory\n            // This is where it gets nasty, paginated stuff here is a pain and needs work\n            // Hopefully we can get a chance to re-do it in WL2 and not have this. Basically\n            // if you need paginated populates try and have all the tables in the query on the\n            // same connection so it can be done in a nice single query.\n            if (!join.junctionTable) return;\n\n            if (c.skip) {\n              res[alias].splice(0, c.skip);\n            }\n\n            if (c.limit) {\n              res[alias] = _.take(res[alias], c.limit);\n            }\n          });\n        });\n\n        returnResults(results);\n      });\n\n      function returnResults(results) {\n\n        if (!results) return cb(null, []);\n\n        // Normalize results to an array\n        if (!Array.isArray(results) && results) results = [results];\n\n        // Unserialize each of the results before attempting any join logic on them\n        var unserializedModels = [];\n\n        if (results) {\n          results.forEach(function(result) {\n            unserializedModels.push(self._transformer.unserialize(result));\n          });\n        }\n\n        var models = [];\n        var joins = criteria.joins ? criteria.joins : [];\n        var data = new Joins(joins, unserializedModels, self.identity, self._schema.schema, self.waterline.collections);\n\n        // NOTE:\n        // If a \"belongsTo\" (i.e. HAS_FK) association is null, should it be transformed into\n        // an empty array here?  That is not what is happening currently, and it can cause\n        // unexpected problems when implementing the native join method as an adapter implementor.\n        // ~Mike June 22, 2014\n\n        // If `data.models` is invalid (not an array) return early to avoid getting into trouble.\n        if (!data || !data.models || !data.models.forEach) {\n          return cb(new Error('Values returned from operations set are not an array...'));\n        }\n\n        // Create a model for the top level values\n        data.models.forEach(function(model) {\n          models.push(new self._model(model, data.options));\n        });\n\n\n        cb(null, models);\n      }\n\n    });\n  },\n\n  where: function() {\n    this.find.apply(this, Array.prototype.slice.call(arguments));\n  },\n\n  select: function() {\n    this.find.apply(this, Array.prototype.slice.call(arguments));\n  },\n\n\n  /**\n   * findAll\n   * [[ Deprecated! ]]\n   *\n   * @param  {Object}   criteria\n   * @param  {Object}   options\n   * @param  {Function} cb\n   */\n  findAll: function(criteria, options, cb) {\n    if (typeof criteria === 'function') {\n      cb = criteria;\n      criteria = null;\n      options = null;\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    // Return Deferred or pass to adapter\n    if (typeof cb !== 'function') {\n      return new Deferred(this, this.findAll, criteria);\n    }\n\n    cb(new Error('In Waterline >= 0.9, findAll() has been deprecated in favor of find().' +\n                '\\nPlease visit the migration guide at http://sailsjs.org for help upgrading.'));\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/sorter.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\n\n/**\n * Sort `data` (tuples) using `sortCriteria` (comparator)\n *\n * Based on method described here:\n * http://stackoverflow.com/a/4760279/909625\n *\n * @param  { Object[] } data         [tuples]\n * @param  { Object }   sortCriteria [mongo-style comparator object]\n * @return { Object[] }\n */\n\nmodule.exports = function sortData(data, sortCriteria) {\n\n  function dynamicSort(property) {\n    var sortOrder = 1;\n    if (property[0] === '-') {\n      sortOrder = -1;\n      property = property.substr(1);\n    }\n\n    return function(a, b) {\n      var result = (a[property] < b[property]) ? -1 : (a[property] > b[property]) ? 1 : 0;\n      return result * sortOrder;\n    };\n  }\n\n  function dynamicSortMultiple() {\n    var props = arguments;\n    return function(obj1, obj2) {\n      var i = 0;\n      var result = 0;\n      var numberOfProperties = props.length;\n\n      while (result === 0 && i < numberOfProperties) {\n        result = dynamicSort(props[i])(obj1, obj2);\n        i++;\n      }\n      return result;\n    };\n  }\n\n  // build sort criteria in the format ['firstName', '-lastName']\n  var sortArray = [];\n  _.each(_.keys(sortCriteria), function(key) {\n    if (sortCriteria[key] === -1) sortArray.push('-' + key);\n    else sortArray.push(key);\n  });\n\n  data.sort(dynamicSortMultiple.apply(null, sortArray));\n  return data;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/finders/joins.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar utils = require('../../utils/helpers');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Logic For Handling Joins inside a Query Results Object\n */\n\nvar Joins = module.exports = function(joins, values, identity, schema, collections) {\n\n  this.identity = identity;\n\n  // Hold Joins specified in the criteria\n  this.joins = joins || [];\n\n  // Hold the result values\n  this.values = values || [];\n\n  // Hold the overall schema\n  this.schema = schema || {};\n\n  // Hold all the Waterline collections so we can make models\n  this.collections = collections || {};\n\n  // Build up modelOptions\n  this.modelOptions();\n\n  // Modelize values\n  this.models = this.makeModels();\n\n  return this;\n};\n\n/**\n * Build up Join Options that will be passed down to a Model instance.\n *\n * @api private\n */\n\nJoins.prototype.modelOptions = function modelOptions() {\n\n  var self = this;\n  var joins;\n\n  // Build Model Options, determines what associations to render in toObject\n  this.options = {\n    showJoins: !!this.joins\n  };\n\n  // If no joins were used, just return\n  if (!this.joins) return;\n\n  // Map out join names to pass down to the model instance\n  joins = this.joins.filter(function(join) {\n\n    // If the value is not being selected, don't add it to the array\n    if (!join.select) return false;\n\n    return join;\n  });\n\n  // Map out join key names and attach to the options object.\n  // For normal assoiciations, use the child table name that is being joined. For many-to-many\n  // associations the child table name won't work so grab the alias used and use that for the\n  // join name. It will be the one that is transformed.\n  this.options.joins = joins.map(function(join) {\n    var child = [];\n    // If a junctionTable was not used, return the child table\n    if (!join.junctionTable) return join.child;\n\n    // Find the original alias for the join\n    self.joins.forEach(function(j) {\n      if (j.child !== join.parent) return;\n      child.push(j.alias);\n    });\n\n    // If a child was found, return it otherwise just return the original child join\n    if (child) return child;\n    return join.child;\n  });\n\n  // Flatten joins\n  this.options.joins = _.uniq(_.flatten(this.options.joins));\n};\n\n/**\n * Transform Values into instantiated Models.\n *\n * @return {Array}\n * @api private\n */\n\nJoins.prototype.makeModels = function makeModels() {\n\n  var self = this;\n  var models = [];\n  var model;\n\n  // If values are invalid (not an array), return them early.\n  if (!this.values || !this.values.forEach) return this.values;\n\n  // Make each result an instance of model\n  this.values.forEach(function(value) {\n    model = self.modelize(value);\n    models.push(model);\n  });\n\n  return models;\n};\n\n/**\n * Handle a single Result and inspect it's values for anything\n * that needs to become a Model instance.\n *\n * @param {Object} value\n * @return {Object}\n * @api private\n */\n\nJoins.prototype.modelize = function modelize(value) {\n  var self = this;\n\n  // Look at each key in the object and see if it was used in a join\n  Object.keys(value).forEach(function(key) {\n\n    var joinKey = false;\n    var attr,\n        usedInJoin;\n\n    // If showJoins wasn't set or no joins were found there is nothing to modelize\n    if (!self.options.showJoins || !self.options.joins) return;\n\n    // Look at the schema for an attribute and check if it's a foreign key\n    // or a virtual hasMany collection attribute\n\n    // Check if there is a transformation on this attribute\n    var transformer = self.collections[self.identity]._transformer._transformations;\n    if (hop(transformer, key)) {\n      attr = self.schema[transformer[key]];\n    } else {\n      attr = self.schema[key];\n    }\n\n    // If an attribute was found but it's not a model, this means it's a normal\n    // key/value attribute and not an association so there is no need to modelize it.\n    if (attr && !attr.hasOwnProperty('model')) return;\n\n    // If the attribute has a `model` property, the joinKey is the collection of the model\n    if (attr && attr.hasOwnProperty('model')) joinKey = attr.model;\n\n    // If the attribute is a foreign key but it was not populated, just leave the foreign key\n    // as it is and don't try and modelize it.\n    if (joinKey && self.options.joins.indexOf(joinKey) < 0) return;\n\n    // Check if the key was used in a join\n    usedInJoin = self.checkForJoin(key);\n\n    // If the attribute wasn't used in the join, don't turn it into a model instance.\n    // NOTE: Not sure if this is correct or not?\n    if (!usedInJoin.used) return;\n\n    // If the attribute is an array of child values, for each one make a model out of it.\n    if (Array.isArray(value[key])) {\n\n      var records = [];\n\n      value[key].forEach(function(val) {\n        var collection,\n            model;\n\n        // If there is a joinKey this means it's a belongsTo association so the collection\n        // containing the proper model will be the name of the joinKey model.\n        if (joinKey) {\n          collection = self.collections[joinKey];\n          val = collection._transformer.unserialize(val);\n          model = new collection._model(val, { showJoins: false });\n          return records.push(model);\n        }\n\n        // Otherwise look at the join used and determine which key should be used to get\n        // the proper model from the collections.\n        collection = self.collections[usedInJoin.join.child];\n        val = collection._transformer.unserialize(val);\n        model = new collection._model(val, { showJoins: false });\n        return records.push(model);\n      });\n\n      // Set the value to the array of model values\n      value[key] = records;\n      return;\n    }\n\n    // If the value isn't an array it's a populated foreign key so modelize it and attach\n    // it directly on the attribute\n    collection = self.collections[joinKey];\n    value[key] = collection._transformer.unserialize(value[key]);\n    value[key] = new collection._model(value[key], { showJoins: false });\n  });\n\n  return value;\n};\n\n/**\n * Test if an attribute was used in a join.\n * Requires generating a key to test against an attribute because the model process\n * will be run before any transformations have taken place.\n *\n * @param {String} key\n * @return {Object}\n * @api private\n */\n\nJoins.prototype.checkForJoin = function checkForJoin(key) {\n\n  var generatedKey;\n  var usedInJoin = false;\n  var relatedJoin;\n\n  // Loop through each join and see if the given key matches a join used\n  this.joins.forEach(function(join) {\n    if (join.alias !== key) return;\n    usedInJoin = true;\n    relatedJoin = join;\n  });\n\n  return { used: usedInJoin, join: relatedJoin };\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/finders/operations.js":"\n/**\n * Module Dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n/**\n * Builds up a set of operations to perform based on search criteria.\n *\n * This allows the ability to do cross-adapter joins as well as fake joins\n * on adapters that haven't implemented the join interface yet.\n */\n\nvar Operations = module.exports = function(context, criteria, parent) {\n\n  // Build up a cache\n  this.cache = {};\n\n  // Set context\n  this.context = context;\n\n  // Set criteria\n  this.criteria = criteria;\n\n  // Set parent\n  this.parent = parent;\n\n  // Hold a default value for pre-combined results (native joins)\n  this.preCombined = false;\n\n  // Seed the Cache\n  this._seedCache();\n\n  // Build Up Operations\n  this.operations = this._buildOperations();\n\n  return this;\n};\n\n\n/*\n ***********************************************************************************\n * PUBLIC METHODS\n ***********************************************************************************/\n\n\n/**\n * Run Operations\n *\n * Execute a set of generated operations returning an array of results that can\n * joined in-memory to build out a valid results set.\n *\n * @param {Function} cb\n * @api public\n */\n\nOperations.prototype.run = function run(cb) {\n\n  var self = this;\n\n  // Grab the parent operation, it will always be the very first operation\n  var parentOp = this.operations.shift();\n\n  // Run The Parent Operation\n  this._runOperation(parentOp.collection, parentOp.method, parentOp.criteria, function(err, results) {\n\n    if (err) return cb(err);\n\n    // Set the cache values\n    self.cache[parentOp.collection] = results;\n\n    // If results are empty, or we're already combined, nothing else to so do return\n    if (!results || self.preCombined) return cb(null, { combined: true, cache: self.cache });\n\n    // Run child operations and populate the cache\n    self._execChildOpts(results, function(err) {\n      if (err) return cb(err);\n      cb(null, { combined: self.preCombined, cache: self.cache });\n    });\n\n  });\n\n};\n\n\n/*\n ***********************************************************************************\n * PRIVATE METHODS\n ***********************************************************************************/\n\n\n/**\n * Seed Cache with empty values.\n *\n * For each Waterline Collection set an empty array of values into the cache.\n *\n * @api private\n */\n\nOperations.prototype._seedCache = function _seedCache() {\n  var self = this;\n\n  // Fill the cache with empty values for each collection\n  Object.keys(this.context.waterline.schema).forEach(function(key) {\n    self.cache[key] = [];\n  });\n};\n\n/**\n * Build up the operations needed to perform the query based on criteria.\n *\n * @return {Array}\n * @api private\n */\n\nOperations.prototype._buildOperations = function _buildOperations() {\n\n  var self = this;\n  var operations = [];\n\n  // Check if joins were used, if not only a single operation is needed on a single connection\n  if (!hasOwnProperty(this.criteria, 'joins')) {\n\n    // Grab the collection\n    var collection = this.context.waterline.collections[this.context.identity];\n\n    // Find the name of the connection to run the query on using the dictionary\n    var connectionName = collection.adapterDictionary[this.parent];\n    if (!connectionName) connectionName = collection.adapterDictionary.find;\n\n    operations.push({\n      connection: connectionName,\n      collection: this.context.identity,\n      method: this.parent,\n      criteria: this.criteria\n    });\n\n    return operations;\n  }\n\n  // Joins were used in this operation. Lets grab the connections needed for these queries. It may\n  // only be a single connection in a simple case or it could be multiple connections in some cases.\n  var connections = this._getConnections();\n\n  // Now that all the connections are created, build up operations needed to accomplish the end\n  // goal of getting all the results no matter which connection they are on. To do this,\n  // figure out if a connection supports joins and if so pass down a criteria object containing\n  // join instructions. If joins are not supported by a connection, build a series of operations\n  // to achieve the end result.\n  operations = this._stageOperations(connections);\n\n  return operations;\n};\n\n/**\n * Stage Operation Sets\n *\n * @param {Object} connections\n * @api private\n */\n\nOperations.prototype._stageOperations = function _stageOperations(connections) {\n\n  var self = this;\n  var operations = [];\n\n  // Build the parent operation and set it as the first operation in the array\n  operations = operations.concat(this._createParentOperation(connections));\n\n  // Parent Connection Name\n  var parentConnection = this.context.adapterDictionary[this.parent];\n\n  // Parent Operation\n  var parentOperation = operations[0];\n\n  // For each additional connection build operations\n  Object.keys(connections).forEach(function(connection) {\n\n    // Ignore the connection used for the parent operation if a join can be used on it.\n    // This means all of the operations for the query can take place on a single connection\n    // using a single query.\n    if (connection === parentConnection && parentOperation.method === 'join') return;\n\n    // Operations are needed that will be run after the parent operation has been completed.\n    // If there are more than a single join, set the parent join and build up children operations.\n    // This occurs in a many-to-many relationship when a join table is needed.\n\n    // Criteria is omitted until after the parent operation has been run so that an IN query can\n    // be formed on child operations.\n\n    var localOpts = [];\n\n    connections[connection].joins.forEach(function(join, idx) {\n\n      var optCollection = self.context.waterline.collections[join.child];\n      var optConnectionName = optCollection.adapterDictionary['find'];\n\n      var operation = {\n        connection: optConnectionName,\n        collection: join.child,\n        method: 'find',\n        join: join\n      };\n\n      // If this is the first join, it can't have any parents\n      if (idx === 0) {\n        localOpts.push(operation);\n        return;\n      }\n\n      // Look into the previous operations and see if this is a child of any of them\n      var child = false;\n      localOpts.forEach(function(localOpt) {\n        if (localOpt.join.child != join.parent) return;\n        localOpt.child = operation;\n        child = true;\n      });\n\n      if (child) return;\n      localOpts.push(operation);\n    });\n\n    operations = operations.concat(localOpts);\n  });\n\n  return operations;\n};\n\n/**\n * Create The Parent Operation\n *\n * @param {Object} connections\n * @return {Object}\n * @api private\n */\n\nOperations.prototype._createParentOperation = function _createParentOperation(connections) {\n\n  var nativeJoin = this.context.adapter.hasJoin();\n  var operation,\n      connectionName,\n      connection;\n\n  // If the parent supports native joins, check if all the joins on the connection can be\n  // run on the same connection and if so just send the entire criteria down to the connection.\n  if (nativeJoin) {\n\n    connectionName = this.context.adapterDictionary.join;\n    connection = connections[connectionName];\n\n    // Hold any joins that can't be run natively on this connection\n    var unsupportedJoins = false;\n\n    // Pull out any unsupported joins\n    connection.joins.forEach(function(join) {\n      if (connection.collections.indexOf(join.child) > -1) return;\n      unsupportedJoins = true;\n    });\n\n    // If all the joins were supported then go ahead and build an operation.\n    if (!unsupportedJoins) {\n      operation = [{\n        connection: connectionName,\n        collection: this.context.identity,\n        method: 'join',\n        criteria: this.criteria\n      }];\n\n      // Set the preCombined flag\n      this.preCombined = true;\n\n      return operation;\n    }\n  }\n\n  // Remove the joins from the criteria object, this will be an in-memory join\n  var tmpCriteria = _.cloneDeep(this.criteria);\n  delete tmpCriteria.joins;\n\n  connectionName = this.context.adapterDictionary[this.parent];\n\n  // If findOne was used, use the same connection `find` is on.\n  if (this.parent === 'findOne' && !connectionName) {\n    connectionName = this.context.adapterDictionary.find;\n  }\n\n  connection = connections[connectionName];\n\n  operation = [{\n    connection: connectionName,\n    collection: this.context.identity,\n    method: this.parent,\n    criteria: tmpCriteria\n  }];\n\n  return operation;\n};\n\n\n/**\n * Get the connections used in this query and the join logic for each piece.\n *\n * @return {Object}\n * @api private\n */\n\nOperations.prototype._getConnections = function _getConnections() {\n\n  var self = this;\n  var connections = {};\n\n  // Default structure for connection objects\n  var defaultConnection = {\n    collections: [],\n    children: [],\n    joins: []\n  };\n\n  // For each join build a connection item to build up an entire collection/connection registry\n  // for this query. Using this, queries should be able to be seperated into discrete queries\n  // which can be run on connections in parallel.\n  this.criteria.joins.forEach(function(join) {\n    var connection;\n    var parentConnection;\n    var childConnection;\n\n    function getConnection(collName) {\n      var collection = self.context.waterline.collections[collName];\n      var connectionName = collection.adapterDictionary['find'];\n      connections[connectionName] = connections[connectionName] || _.cloneDeep(defaultConnection);\n      return connections[connectionName];\n    }\n\n    // If this join is a junctionTable, find the parent operation and add it to that connections\n    // children instead of creating a new operation on another connection. This allows cross-connection\n    // many-to-many joins to be used where the join relies on the results of the parent operation\n    // being run first.\n\n    if (join.junctionTable) {\n\n      // Find the previous join\n      var parentJoin = _.find(self.criteria.joins, function(otherJoin) {\n        return otherJoin.child == join.parent;\n      });\n\n      // Grab the parent join connection\n      var parentJoinConnection = getConnection(parentJoin.parent);\n\n      // Find the connection the parent and child collections belongs to\n      parentConnection = getConnection(join.parent);\n      childConnection = getConnection(join.child);\n\n      // Update the registry\n      parentConnection.collections.push(join.parent);\n      childConnection.collections.push(join.child);\n      parentConnection.children.push(join.parent);\n\n      // Ensure the arrays are made up only of unique values\n      parentConnection.collections = _.uniq(parentConnection.collections);\n      childConnection.collections = _.uniq(childConnection.collections);\n      parentConnection.children = _.uniq(parentConnection.children);\n\n      // Add the join to the correct joins array. We want it to be on the same\n      // connection as the operation before so the timing is correct.\n      parentJoinConnection.joins = parentJoinConnection.joins.concat(join);\n\n    // Build up the connection registry like normal\n    } else {\n      parentConnection = getConnection(join.parent);\n      childConnection = getConnection(join.child);\n\n      parentConnection.collections.push(join.parent);\n      childConnection.collections.push(join.child);\n      parentConnection.joins = parentConnection.joins.concat(join);\n    }\n\n  });\n  return connections;\n};\n\n\n/**\n * Run An Operation\n *\n * Performs an operation and runs a supplied callback.\n *\n * @param {Object} collectionName\n * @param {String} method\n * @param {Object} criteria\n * @param {Function} cb\n *\n * @api private\n */\n\nOperations.prototype._runOperation = function _runOperation(collectionName, method, criteria, cb) {\n\n  // Ensure the collection exist\n  if (!hasOwnProperty(this.context.waterline.collections, collectionName)) {\n    return cb(new Error('Invalid Collection specfied in operation.'));\n  }\n\n  // Find the connection object to run the operation\n  var collection = this.context.waterline.collections[collectionName];\n\n  // Run the operation\n  collection.adapter[method](criteria, cb);\n\n};\n\n/**\n * Execute Child Operations\n *\n * If joins are used and an adapter doesn't support them, there will be child operations that will\n * need to be run. Parse each child operation and run them along with any tree joins and return\n * an array of children results that can be combined with the parent results.\n *\n * @param {Array} parentResults\n * @param {Function} cb\n */\n\nOperations.prototype._execChildOpts = function _execChildOpts(parentResults, cb) {\n\n  var self = this;\n\n  // Build up a set of child operations that will need to be run\n  // based on the results returned from the parent operation.\n  this._buildChildOpts(parentResults, function(err, opts) {\n    if (err) return cb(err);\n\n    // Run the generated operations in parallel\n    async.each(opts, function(item, next) {\n      self._collectChildResults(item, next);\n    }, cb);\n  });\n\n};\n\n/**\n * Build Child Operations\n *\n * Using the results of a parent operation, build up a set of operations that contain criteria\n * based on what is returned from a parent operation. These can be arrays containing more than\n * one operation for each child, which will happen when \"join tables\" would be used.\n *\n * Each set should be able to be run in parallel.\n *\n * @param {Array} parentResults\n * @param {Function} cb\n * @return {Array}\n * @api private\n */\n\nOperations.prototype._buildChildOpts = function _buildChildOpts(parentResults, cb) {\n\n  var self = this;\n  var opts = [];\n\n  // Build up operations that can be run in parallel using the results of the parent operation\n  async.each(this.operations, function(item, next) {\n\n    var localOpts = [];\n    var parents = [];\n    var idx = 0;\n\n    // Go through all the parent records and build up an array of keys to look in. This\n    // will be used in an IN query to grab all the records needed for the \"join\".\n    parentResults.forEach(function(result) {\n\n      if (!hasOwnProperty(result, item.join.parentKey)) return;\n      if (result[item.join.parentKey] === null || typeof result[item.join.parentKey] === undefined) return;\n      parents.push(result[item.join.parentKey]);\n\n    });\n\n    // If no parents match the join criteria, don't build up an operation\n    if (parents.length === 0) return next();\n\n    // Build up criteria that will be used inside an IN query\n    var criteria = {};\n    criteria[item.join.childKey] = parents;\n\n    var _tmpCriteria = {};\n\n    // Check if the join contains any criteria\n    if (item.join.criteria) {\n      var userCriteria = _.cloneDeep(item.join.criteria);\n      _tmpCriteria = _.cloneDeep(userCriteria);\n      _tmpCriteria = normalize.criteria(_tmpCriteria);\n\n      // Ensure `where` criteria is properly formatted\n      if (hasOwnProperty(userCriteria, 'where')) {\n        if (userCriteria.where === undefined) {\n          delete userCriteria.where;\n        } else {\n\n          // If an array of primary keys was passed in, normalize the criteria\n          if (Array.isArray(userCriteria.where)) {\n            var pk = self.context.waterline.collections[item.join.child].primaryKey;\n            var obj = {};\n            obj[pk] = _.clone(userCriteria.where);\n            userCriteria.where = obj;\n          }\n\n          userCriteria = userCriteria.where;\n        }\n      }\n\n\n      criteria = _.merge(userCriteria, criteria);\n    }\n\n    // Normalize criteria\n    criteria = normalize.criteria(criteria);\n\n    // If criteria contains a skip or limit option, an operation will be needed for each parent.\n    if (hasOwnProperty(_tmpCriteria, 'skip') || hasOwnProperty(_tmpCriteria, 'limit')) {\n      parents.forEach(function(parent) {\n\n        var tmpCriteria = _.cloneDeep(criteria);\n        tmpCriteria.where[item.join.childKey] = parent;\n\n        // Mixin the user defined skip and limit\n        if (hasOwnProperty(_tmpCriteria, 'skip')) tmpCriteria.skip = _tmpCriteria.skip;\n        if (hasOwnProperty(_tmpCriteria, 'limit')) tmpCriteria.limit = _tmpCriteria.limit;\n\n        // Build a simple operation to run with criteria from the parent results.\n        // Give it an ID so that children operations can reference it if needed.\n        localOpts.push({\n          id: idx,\n          collection: item.collection,\n          method: item.method,\n          criteria: tmpCriteria,\n          join: item.join\n        });\n\n      });\n    } else {\n\n      // Build a simple operation to run with criteria from the parent results.\n      // Give it an ID so that children operations can reference it if needed.\n      localOpts.push({\n        id: idx,\n        collection: item.collection,\n        method: item.method,\n        criteria: criteria,\n        join: item.join\n      });\n\n    }\n\n    // If there are child records, add the opt but don't add the criteria\n    if (!item.child) {\n      opts.push(localOpts);\n      return next();\n    }\n\n    localOpts.push({\n      collection: item.child.collection,\n      method: item.child.method,\n      parent: idx,\n      join: item.child.join\n    });\n\n    // Add the local opt to the opts array\n    opts.push(localOpts);\n\n    next();\n  }, function(err) {\n    cb(err, opts);\n  });\n};\n\n/**\n * Collect Child Operation Results\n *\n * Run a set of child operations and return the results in a namespaced array\n * that can later be used to do an in-memory join.\n *\n * @param {Array} opts\n * @param {Function} cb\n * @api private\n */\n\nOperations.prototype._collectChildResults = function _collectChildResults(opts, cb) {\n\n  var self = this;\n  var intermediateResults = [];\n  var i = 0;\n\n  if (!opts || opts.length === 0) return cb(null, {});\n\n  // Run the operations and any child operations in series so that each can access the\n  // results of the previous operation.\n  async.eachSeries(opts, function(opt, next) {\n    self._runChildOperations(intermediateResults, opt, function(err, values) {\n      if (err) return next(err);\n\n      // If there are multiple operations and we are on the first one lets put the results\n      // into an intermediate results array\n      if (opts.length > 1 && i === 0) {\n        intermediateResults = intermediateResults.concat(values);\n      }\n\n      // Add values to the cache key\n      self.cache[opt.collection] = self.cache[opt.collection] || [];\n      self.cache[opt.collection] = self.cache[opt.collection].concat(values);\n\n      // Ensure the values are unique\n      var pk = self._findCollectionPK(opt.collection);\n      self.cache[opt.collection] = _.uniq(self.cache[opt.collection], pk);\n\n      i++;\n      next();\n    });\n  }, cb);\n\n};\n\n/**\n * Run A Child Operation\n *\n * Executes a child operation and appends the results as a namespaced object to the\n * main operation results object.\n *\n * @param {Object} optResults\n * @param {Object} opt\n * @param {Function} callback\n * @api private\n */\n\nOperations.prototype._runChildOperations = function _runChildOperations(intermediateResults, opt, cb) {\n  var self = this;\n\n  // Check if value has a parent, if so a join table was used and we need to build up dictionary\n  // values that can be used to join the parent and the children together.\n\n  // If the operation doesn't have a parent operation run it\n  if (!hasOwnProperty(opt, 'parent')) {\n    return self._runOperation(opt.collection, opt.method, opt.criteria, function(err, values) {\n      if (err) return cb(err);\n      cb(null, values);\n    });\n  }\n\n  // If the operation has a parent, look into the optResults and build up a criteria\n  // object using the results of a previous operation\n  var parents = [];\n\n  // Normalize to array\n  var res = _.cloneDeep(intermediateResults);\n\n  // Build criteria that can be used with an `in` query\n  res.forEach(function(result) {\n    parents.push(result[opt.join.parentKey]);\n  });\n\n  var criteria = {};\n  criteria[opt.join.childKey] = parents;\n\n  // Check if the join contains any criteria\n  if (opt.join.criteria) {\n    var userCriteria = _.cloneDeep(opt.join.criteria);\n\n    // Ensure `where` criteria is properly formatted\n    if (hasOwnProperty(userCriteria, 'where')) {\n      if (userCriteria.where === undefined) {\n        delete userCriteria.where;\n      } else {\n        userCriteria = userCriteria.where;\n      }\n    }\n\n    delete userCriteria.sort;\n    criteria = _.extend(criteria, userCriteria);\n  }\n\n  criteria = normalize.criteria({ where: criteria });\n\n  // Empty the cache for the join table so we can only add values used\n  var cacheCopy = _.cloneDeep(self.cache[opt.join.parent]);\n  self.cache[opt.join.parent] = [];\n\n  self._runOperation(opt.collection, opt.method, criteria, function(err, values) {\n    if (err) return cb(err);\n\n    // Build up the new join table result\n    values.forEach(function(val) {\n      cacheCopy.forEach(function(copy) {\n        if (copy[opt.join.parentKey] === val[opt.join.childKey]) self.cache[opt.join.parent].push(copy);\n      });\n    });\n\n    // Ensure the values are unique\n    var pk = self._findCollectionPK(opt.join.parent);\n    self.cache[opt.join.parent] = _.uniq(self.cache[opt.join.parent], pk);\n\n    cb(null, values);\n  });\n};\n\n/**\n * Find A Collection's Primary Key\n *\n * @param {String} collectionName\n * @api private\n * @return {String}\n */\n\nOperations.prototype._findCollectionPK = function _findCollectionPK(collectionName) {\n  var pk;\n\n  for (var attribute in this.context.waterline.collections[collectionName]._attributes) {\n    var attr = this.context.waterline.collections[collectionName]._attributes[attribute];\n    if (hasOwnProperty(attr, 'primaryKey') && attr.primaryKey) {\n      pk = attr.columnName || attribute;\n      break;\n    }\n  }\n\n  return pk || null;\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/integrator/index.js":"/**\n * Module dependencies\n */\nvar anchor = require('anchor');\nvar _ = require('lodash');\nvar leftOuterJoin = require('./leftOuterJoin');\nvar innerJoin = require('./innerJoin');\nvar populate = require('./populate');\n\n\n/**\n * Query Integrator\n *\n * Combines the results from multiple child queries into\n * the final return format using an in-memory join.\n * Final step in fulfilling a `.find()` with one or more\n * `populate(alias[n])` modifiers.\n *\n *    > Why is this asynchronous?\n *    >\n *    > While this function isn't doing anything strictly\n *    > asynchronous, it still expects a callback to enable\n *    > future use of `process[setImmediate|nextTick]()` as\n *    > an optimization.\n *\n * @param  {Object}   cache\n * @param  {Array}    joinInstructions      - see JOIN_INSTRUCTIONS.md\n * @callback  {Function} cb(err, results)\n *           @param {Error}\n *           @param {Array}  [results, complete w/ populations]\n *\n * @throws {Error} on invalid input\n * @asynchronous\n */\nmodule.exports = function integrate(cache, joinInstructions, primaryKey, cb) {\n\n  // Ensure valid usage\n  var invalid = false;\n  invalid = invalid || anchor(cache).to({ type: 'object' });\n  invalid = invalid || anchor(joinInstructions).to({ type: 'array' });\n  invalid = invalid || anchor(joinInstructions[0]).to({ type: 'object' });\n  invalid = invalid || anchor(joinInstructions[0].parent).to({ type: 'string' });\n  invalid = invalid || anchor(cache[joinInstructions[0].parent]).to({ type: 'object' });\n  invalid = invalid || typeof primaryKey !== 'string';\n  invalid = invalid || typeof cb !== 'function';\n  if (invalid) return cb(invalid);\n\n\n  // Constant: String prepended to child attribute keys for use in namespacing.\n  var CHILD_ATTR_PREFIX = '.';\n  var GRANDCHILD_ATTR_PREFIX = '..';\n\n\n  // We'll reuse the cached data from the `parent` table modifying it in-place\n  // and returning it as our result set. (`results`)\n  var results = cache[ joinInstructions[0].parent ];\n\n  // Group the joinInstructions array by alias, then interate over each one\n  // s.t. `instructions` in our lambda function contains a list of join instructions\n  // for the particular `populate` on the specified key (i.e. alias).\n  //\n  // Below, `results` are mutated inline.\n  _.each(_.groupBy(joinInstructions, 'alias'),\n    function eachAssociation(instructions, alias) {\n\n      var parentPK, fkToParent, fkToChild, childPK;\n\n      // N..N Association\n      if (instructions.length === 2) {\n\n        // Name keys explicitly\n        // (makes it easier to see what's going on)\n        parentPK = instructions[0].parentKey;\n        fkToParent = instructions[0].childKey;\n        fkToChild = instructions[1].parentKey;\n        childPK = instructions[1].childKey;\n\n        // console.log('\\n\\n------------:: n..m leftOuterJoin ::--------\\n',\n        //   leftOuterJoin({\n        //     left: cache[instructions[0].parent],\n        //     right: cache[instructions[0].child],\n        //     leftKey: parentPK,\n        //     rightKey: fkToParent\n        //   })\n        // );\n        // console.log('------------:: / ::--------\\n');\n\n        // console.log('\\n\\n------------:: n..m childRows ::--------\\n',innerJoin({\n        //   left: leftOuterJoin({\n        //     left: cache[instructions[0].parent],\n        //     right: cache[instructions[0].child],\n        //     leftKey: parentPK,\n        //     rightKey: fkToParent\n        //   }),\n        //   right: cache[instructions[1].child],\n        //   leftKey: CHILD_ATTR_PREFIX+fkToChild,\n        //   rightKey: childPK,\n        //   childNamespace: GRANDCHILD_ATTR_PREFIX\n        // }));\n        // console.log('------------:: / ::--------\\n');\n\n        // Calculate and sanitize join data,\n        // then shove it into the parent results under `alias`\n        populate({\n          parentRows: results,\n          alias: alias,\n\n          childRows: innerJoin({\n            left: leftOuterJoin({\n              left: cache[instructions[0].parent],\n              right: cache[instructions[0].child],\n              leftKey: parentPK,\n              rightKey: fkToParent\n            }),\n            right: cache[instructions[1].child],\n            leftKey: CHILD_ATTR_PREFIX + fkToChild,\n            rightKey: childPK,\n            childNamespace: GRANDCHILD_ATTR_PREFIX\n          }),\n\n          parentPK: parentPK,   // e.g. `id` (of message)\n          fkToChild: CHILD_ATTR_PREFIX + fkToChild, // e.g. `user_id` (of join table)\n          childPK: GRANDCHILD_ATTR_PREFIX + childPK,      // e.g. `id` (of user)\n\n          childNamespace: GRANDCHILD_ATTR_PREFIX\n        });\n\n      // 1 ..N Association\n      } else if (instructions.length === 1) {\n\n        // Name keys explicitly\n        // (makes it easier to see what's going on)\n        parentPK = primaryKey;\n        fkToParent = parentPK;\n        fkToChild = instructions[0].parentKey;\n        childPK = instructions[0].childKey;\n\n        // Determine if this is a \"hasOne\" or a \"belongsToMany\"\n        // if the parent's primary key is the same as the fkToChild, it must be belongsToMany\n        if (parentPK === fkToChild) {\n          // In belongsToMany case, fkToChild needs prefix because it's actually the\n          // console.log('belongsToMany');\n          fkToChild = CHILD_ATTR_PREFIX + fkToChild;\n        // \"hasOne\" case\n        } else {\n          // console.log('hasOne');\n        }\n\n        // var childRows = innerJoin({\n        //   left: cache[instructions[0].parent],\n        //   right: cache[instructions[0].child],\n        //   leftKey: instructions[0].parentKey,\n        //   rightKey: instructions[0].childKey\n        // });\n\n        // console.log('1..N JOIN--------------\\n',instructions,'\\n^^^^^^^^^^^^^^^^^^^^^^');\n        // console.log('1..N KEYS--------------\\n',{\n        //   parentPK: parentPK,\n        //   fkToParent: fkToParent,\n        //   fkToChild: fkToChild,\n        //   childPK: childPK,\n        // },'\\n^^^^^^^^^^^^^^^^^^^^^^');\n        // console.log('1..N CHILD ROWS--------\\n',childRows);\n\n        // Calculate and sanitize join data,\n        // then shove it into the parent results under `alias`\n        populate({\n          parentRows: results,\n          alias: alias,\n\n          childRows: innerJoin({\n            left: cache[instructions[0].parent],\n            right: cache[instructions[0].child],\n            leftKey: instructions[0].parentKey,\n            rightKey: instructions[0].childKey\n          }),\n\n          parentPK: fkToParent,  // e.g. `id` (of message)\n          fkToChild: fkToChild,  // e.g. `from`\n          childPK: childPK,      // e.g. `id` (of user)\n\n          childNamespace: CHILD_ATTR_PREFIX\n        });\n\n        // If the alias isn't the same as the parent_key AND removeParentKey is set to true\n        // in the instructions this means that we are turning a FK into an embedded record and a\n        // columnName was used. We need to move the values attached to the alias property to\n        // the parent key value. If we don't then when we run the transformer everything would get crazy.\n        if (alias !== instructions[0].parentKey && instructions[0].removeParentKey === true) {\n\n          results = _.map(results, function(result) {\n            result[instructions[0].parentKey] = result[alias];\n            delete result[alias];\n            return result;\n          });\n\n        }\n      }\n\n    }\n  );\n\n\n  // And call the callback\n  // (the final joined data is in the cache -- also referenced by `results`)\n  return cb(null, results);\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/integrator/leftOuterJoin.js":"/**\n * Module dependencies\n */\nvar join = require('./_join');\n\n\n/**\n * Left outer join\n *\n * Return a result set with data from child and parent\n * merged on childKey===parentKey, where t.e. at least one\n * entry for each row of parent (unmatched columns in child are null).\n *\n * @option {Array} parent       [rows from the \"lefthand table\"]\n * @option {Array} child        [rows from the \"righthand table\"]\n * @option {String} parentKey   [primary key of the \"lefthand table\"]\n * @option {String} childKey    [foreign key from the \"righthand table\" to the \"lefthand table\"]\n * @return {Array}              [a new array of joined row data]\n *\n * @throws {Error} on invalid input\n * @synchronous\n */\nmodule.exports = function leftOuterJoin(options) {\n  options.outer = 'left';\n  return join(options);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/integrator/_join.js":"/**\n * Module dependencies\n */\nvar anchor = require('anchor');\nvar _ = require('lodash');\nvar partialJoin = require('./_partialJoin');\n\n\n/**\n * _join\n *\n * @api private\n *\n * Helper method- can perform and inner -OR- outer join.\n *\n * @option {String|Boolean} outer    [whether to do an outer join, and if so the direction (\"left\"|\"right\")]\n * @option {Array} parent            [rows from the \"lefthand table\"]\n * @option {Array} child             [rows from the \"righthand table\"]\n * @option {String} parentKey        [primary key of the \"lefthand table\"]\n * @option {String} childKey         [foreign key from the \"righthand table\" to the \"lefthand table\"]\n * @option {String} childNamespace   [string prepended to child attribute keys (default='.')]\n *\n * @return {Array} new joined row data\n *\n * @throws {Error} on invalid input\n *\n * @synchronous\n */\nmodule.exports = function _join(options) {\n\n\n  // Usage\n  var invalid = false;\n  invalid = invalid || anchor(options).to({\n    type: 'object'\n  });\n\n  // Tolerate `right` and `left` usage\n  _.defaults(options, {\n    parent: options.left,\n    child: options.right,\n    parentKey: options.leftKey,\n    childKey: options.rightKey,\n    childNamespace: options.childNamespace || '.'\n  });\n\n  invalid = invalid || anchor(options.parent).to({\n    type: 'array'\n  });\n  invalid = invalid || anchor(options.child).to({\n    type: 'array'\n  });\n  invalid = invalid || anchor(options.parentKey).to({\n    type: 'string'\n  });\n  invalid = invalid || anchor(options.childKey).to({\n    type: 'string'\n  });\n\n  invalid = invalid || (options.outer === 'right' ?\n    new Error('Right joins not supported yet.') : false);\n\n  if (invalid) throw invalid;\n\n\n  var resultSet = _.reduce(options.parent, function eachParentRow(memo, parentRow) {\n\n    // For each childRow whose childKey matches\n    // this parentRow's parentKey...\n    var foundMatch = _.reduce(options.child, function eachChildRow(hasFoundMatchYet, childRow) {\n\n      var newRow = partialJoin({\n        parentRow: parentRow,\n        childRow: childRow,\n        parentKey: options.parentKey,\n        childKey: options.childKey,\n        childNamespace: options.childNamespace\n      });\n\n      // console.log('PARENT ROW: ', parentRow);\n      // console.log('CHILD ROW: ', childRow);\n      // console.log('JOIN ROW: ', newRow);\n\n      // Save the new row for the join result if it exists\n      // and mark the match as found\n      if (newRow) {\n        memo.push(newRow);\n        return true;\n      }\n      return hasFoundMatchYet;\n    }, false);\n\n    // If this is a left outer join and we didn't find a match\n    // for this parentRow, add it to the result set anyways\n    if (!foundMatch && options.outer === 'left') {\n      memo.push(_.cloneDeep(parentRow));\n    }\n\n    return memo;\n  }, []);\n\n  // console.log('JOIN RESULT SET::', resultSet);\n  return resultSet;\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/integrator/_partialJoin.js":"/**\n * Module dependencies\n */\nvar assert = require('assert');\nvar _ = require('lodash');\n\n\n/**\n * _partialJoin\n *\n * @api private\n *\n * Check whether two rows match on the specified keys,\n * and if they do, merge `parentRow` into a copy of `childRow`\n * and return it (omit `childRow`'s key, since it === `parentRow`'s).\n *\n * Hypothetically, this function could be operated by a stream,\n * but in the case of a left outer join, at least, the final\n * result set cannot be accurately known until both the complete\n * contents of both the `left` and `right` data set have been checked.\n *\n * An optimization from polynomial to logarithmic computational\n * complexity could potentially be achieved by taking advantage\n * of the known L[k..l] and R[m..n] values as each new L[i] or R[j]\n * arrives from a stream, but a comparably-sized cache would have to\n * be maintained, so we'd still be stuck with polynomial memory usage.\n * i.e. O( |R|*|L| )  This could be resolved by batching-- e.g. grab the\n * first 3000 parent and child rows, join matches together, discard\n * the unneeded data, and repeat.\n *\n * Anyways, worth investigating, since this is a hot code path for\n * cross-adapter joins.\n *\n *\n * Usage:\n *\n * partialJoin({\n *   parentRow: { id: 5, name: 'Lucy', email: 'lucy@fakemail.org' }\n *   childRow:  { owner_id: 5, name: 'Rover', breed: 'Australian Shepherd' }\n *   parentKey: 'id'\n *   childKey:  'owner_id',\n *   childNamespace:  '.'\n * })\n *\n * @param  {Object} options\n * @return {Object|False}   If false, don't save the join row.\n * @synchronous\n */\nmodule.exports = function partialJoin(options) {\n\n  // Usage\n  var invalid = false;\n  invalid = invalid || !_.isObject(options);\n  invalid = invalid || !_.isString(options.parentKey);\n  invalid = invalid || !_.isString(options.childKey);\n  invalid = invalid || !_.isObject(options.parentRow);\n  invalid = invalid || !_.isObject(options.childRow);\n  assert(!invalid);\n\n  var CHILD_ATTR_PREFIX = (options.childNamespace || '.');\n\n  // If the rows aren't a match, bail out\n  if (\n    options.childRow[options.childKey] !==\n    options.parentRow[options.parentKey]\n    ) {\n    return false;\n  }\n\n  // deep clone the childRow, then delete `childKey` in the copy.\n  var newJoinRow = _.cloneDeep(options.childRow);\n  // console.log('deleting childKEy :: ',options.childKey);\n  // var _childKeyValue = newJoinRow[options.childKey];\n  // delete newJoinRow[options.childKey];\n\n  // namespace the remaining attributes in childRow\n  var namespacedJoinRow = {};\n  _.each(newJoinRow, function(value, key) {\n    var namespacedKey = CHILD_ATTR_PREFIX + key;\n    namespacedJoinRow[namespacedKey] = value;\n  });\n\n\n  // Merge namespaced values from current parentRow into the copy.\n  _.merge(namespacedJoinRow, options.parentRow);\n\n\n  // Return the newly joined row.\n  return namespacedJoinRow;\n};\n\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/integrator/innerJoin.js":"/**\n * Module dependencies\n */\nvar join = require('./_join');\n\n\n/**\n * Inner join\n *\n * Return a result set with data from child and parent\n * merged on childKey===parentKey, where t.e. exactly one\n * entry for each match.\n *\n * @option {Array} parent    [rows from the \"lefthand table\"]\n * @option {Array} child   [rows from the \"righthand table\"]\n * @option {String} parentKey     [primary key of the \"lefthand table\"]\n * @option {String} childKey     [foreign key from the \"righthand table\" to the \"lefthand table\"]\n * @return {Array}          [a new array of joined row data]\n *\n * @throws {Error} on invalid input\n * @synchronous\n */\nmodule.exports = function leftOuterJoin(options) {\n  options.outer = false;\n  return join(options);\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/integrator/populate.js":"/**\n * Module dependencies\n */\nvar _ = require('lodash');\n\n\n/**\n * populate()\n *\n * Destructive mapping of `parentRows` to include a new key, `alias`,\n * which is an ordered array of child rows.\n *\n * @option [{Object}] parentRows    - the parent rows the joined rows will be folded into\n * @option {String} alias           - the alias of the association\n * @option [{Object}] childRows     - the unfolded result set from the joins\n *\n * @option {String} parentPK        - the primary key of the parent table (optional- only needed for M..N associations)\n * @option {String} fkToChild       - the foreign key associating a row with the child table\n * @option {String} childPK         - the primary key of the child table\n *\n * @option [{String}] childNamespace- attributes to keep\n *\n * @return {*Object} reference to `parentRows`\n */\nmodule.exports = function populate(options) {\n\n  var parentRows = options.parentRows;\n  var alias = options.alias;\n  var childRows = options.childRows;\n\n  var parentPK = options.parentPK;\n  var childPK = options.childPK;\n  var fkToChild = options.fkToChild;\n  var fkToParent = parentPK;// At least for all use cases currently, `fkToParent` <=> `parentPK`\n\n  var childNamespace = options.childNamespace || '';\n\n  return _.map(parentRows, function _insertJoinedResults(parentRow) {\n\n    // Gather the subset of child rows associated with the current parent row\n    var associatedChildRows = _.where(childRows,\n      // { (parentPK): (parentRow[(parentPK)]) }, e.g. { id: 3 }\n      _cons(fkToParent, parentRow[parentPK])\n    );\n\n    // Clone the `associatedChildRows` to avoid mutating the original\n    // `childRows` in the cache.\n    associatedChildRows = _.cloneDeep(associatedChildRows);\n\n    // Stuff the sanitized associated child rows into the parent row.\n    parentRow[alias] =\n    _.reduce(associatedChildRows, function(memo, childRow) {\n\n      // Ignore child rows without an appropriate foreign key\n      // to an instance in the REAL child collection.\n      if (!childRow[childNamespace + childPK] && !childRow[childPK]) return memo;\n\n      // Rename childRow's [fkToChild] key to [childPK]\n      // (so that it will have the proper primary key attribute for its collection)\n      var childPKValue = childRow[fkToChild];\n      childRow[childPK] = childPKValue;\n\n      // Determine if we have any double nested attributes.\n      // These would come from m:m joins\n      var doubleNested = _.find(childRow, function(name, key) {\n        return _.startsWith(key, '..');\n      });\n\n      // Grab all the keys that start with a dot or double dot depending on\n      // the status of doubleNested\n      childRow = _.pick(childRow, function(name, key) {\n        if (doubleNested) {\n          return _.startsWith(key, '..');\n        } else {\n          return _.startsWith(key, '.');\n        }\n      });\n\n      var _origChildRow = childRow;\n\n      // Strip off childNamespace prefix\n      childRow = {};\n      var PREFIX_REGEXP = new RegExp('^' + childNamespace + '');\n      _.each(_origChildRow, function(attrValue, attrName) {\n        var unprefixedKey = attrName.replace(PREFIX_REGEXP, '');\n        childRow[unprefixedKey] = attrValue;\n      });\n\n      // Build the set of rows to stuff into our parent row.\n      memo.push(childRow);\n      return memo;\n    }, []);\n\n    return parentRow;\n  });\n};\n\n\n/**\n * Dumb little helper because I hate naming anonymous objects just to use them once.\n *\n * @return {Object} [a tuple]\n * @api private\n */\nfunction _cons(key, value) {\n  var obj = {};\n  obj[key] = value;\n  return obj;\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/finders/helpers.js":"/**\n * Finder Helper Queries\n *\n * (these call other collection-level methods)\n */\n\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\n\nmodule.exports = {\n\n  // Return models where ALL of the specified attributes match queryString\n\n  findOneLike: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.findOneLike([criteria],[options],callback)';\n\n    // Normalize criteria\n    criteria = normalize.likeCriteria(criteria, this._schema.schema);\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.findOne(criteria, options, cb);\n  },\n\n  findLike: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.findLike([criteria],[options],callback)';\n\n    // Normalize criteria\n    criteria = normalize.likeCriteria(criteria, this._schema.schema);\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.find(criteria, options, cb);\n  },\n\n  // Return models where >= 1 of the specified attributes start with queryString\n  startsWith: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.startsWith([criteria],[options],callback)';\n\n    criteria = normalize.likeCriteria(criteria, this._schema.schema, function applyStartsWith(criteria) {\n      return criteria + '%';\n    });\n\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.find(criteria, options, cb);\n  },\n\n  // Return models where >= 1 of the specified attributes end with queryString\n  endsWith: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.startsWith([criteria],[options],callback)';\n\n    criteria = normalize.likeCriteria(criteria, this._schema.schema, function applyEndsWith(criteria) {\n      return '%' + criteria;\n    });\n\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.find(criteria, options, cb);\n  },\n\n  // Return models where >= 1 of the specified attributes contain queryString\n  contains: function(criteria, options, cb) {\n    var usage = utils.capitalize(this.identity) + '.startsWith([criteria],[options],callback)';\n\n    criteria = normalize.likeCriteria(criteria, this._schema.schema, function applyContains(criteria) {\n      return '%' + criteria + '%';\n    });\n\n    if (!criteria) return usageError('Criteria must be an object!', usage, cb);\n\n    this.find(criteria, options, cb);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/finders/dynamicFinders.js":"/**\n * Dynamic Queries\n *\n * Query the collection using the name of the attribute directly\n */\n\nvar _ = require('lodash');\nvar usageError = require('../../utils/usageError');\nvar utils = require('../../utils/helpers');\nvar normalize = require('../../utils/normalize');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\nvar finder = module.exports = {};\n\n/**\n * buildDynamicFinders\n *\n * Attaches shorthand dynamic methods to the prototype for each attribute\n * in the schema.\n */\n\nfinder.buildDynamicFinders = function() {\n  var self = this;\n\n  // For each defined attribute, create a dynamic finder function\n  Object.keys(this._attributes).forEach(function(attrName) {\n\n    // Check if attribute is an association, if so generate limited dynamic finders\n    if (hasOwnProperty(self._schema.schema[attrName], 'foreignKey')) {\n      if (self.associationFinders !== false) {\n        self.generateAssociationFinders(attrName);\n      }\n      return;\n    }\n\n    var capitalizedMethods = ['findOneBy*', 'findOneBy*In', 'findOneBy*Like', 'findBy*', 'findBy*In',\n      'findBy*Like', 'countBy*', 'countBy*In', 'countBy*Like'];\n\n    var lowercasedMethods = ['*StartsWith', '*Contains', '*EndsWith'];\n\n\n    if (self.dynamicFinders !== false) {\n      capitalizedMethods.forEach(function(method) {\n        self.generateDynamicFinder(attrName, method);\n      });\n      lowercasedMethods.forEach(function(method) {\n        self.generateDynamicFinder(attrName, method, true);\n      });\n    }\n  });\n};\n\n\n/**\n * generateDynamicFinder\n *\n * Creates a dynamic method based off the schema. Used for shortcuts for various\n * methods where a criteria object can automatically be built.\n *\n * @param {String} attrName\n * @param {String} method\n * @param {Boolean} dont capitalize the attrName or do, defaults to false\n */\n\nfinder.generateDynamicFinder = function(attrName, method, dontCapitalize) {\n  var self = this;\n  var criteria;\n\n  // Capitalize Attribute Name for camelCase\n  var preparedAttrName = dontCapitalize ? attrName : utils.capitalize(attrName);\n\n  // Figure out actual dynamic method name by injecting attribute name\n  var actualMethodName = method.replace(/\\*/g, preparedAttrName);\n\n  // Assign this finder to the collection\n  this[actualMethodName] = function dynamicMethod(value, options, cb) {\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    options = options || {};\n\n    var usage = utils.capitalize(self.identity) + '.' + actualMethodName + '(someValue,[options],callback)';\n\n    if (typeof value === 'undefined') return usageError('No value specified!', usage, cb);\n    if (options.where) return usageError('Cannot specify `where` option in a dynamic ' + method + '*() query!', usage, cb);\n\n    // Build criteria query and submit it\n    options.where = {};\n    options.where[attrName] = value;\n\n    switch (method) {\n\n\n      ///////////////////////////////////////\n      // Finders\n      ///////////////////////////////////////\n\n\n      case 'findOneBy*':\n      case 'findOneBy*In':\n        return self.findOne(options, cb);\n\n      case 'findOneBy*Like':\n        criteria = _.extend(options, {\n          where: {\n            like: options.where\n          }\n        });\n\n        return self.findOne(criteria, cb);\n\n\n      ///////////////////////////////////////\n      // Aggregate Finders\n      ///////////////////////////////////////\n\n\n      case 'findBy*':\n      case 'findBy*In':\n        return self.find(options, cb);\n\n      case 'findBy*Like':\n        criteria = _.extend(options, {\n          where: {\n            like: options.where\n          }\n        });\n\n        return self.find(criteria, cb);\n\n\n      ///////////////////////////////////////\n      // Count Finders\n      ///////////////////////////////////////\n\n\n      case 'countBy*':\n      case 'countBy*In':\n        return self.count(options, cb);\n\n      case 'countBy*Like':\n        criteria = _.extend(options, {\n          where: {\n            like: options.where\n          }\n        });\n\n        return self.count(criteria, cb);\n\n\n      ///////////////////////////////////////\n      // Searchers\n      ///////////////////////////////////////\n\n      case '*StartsWith':\n        return self.startsWith(options, cb);\n\n      case '*Contains':\n        return self.contains(options, cb);\n\n      case '*EndsWith':\n        return self.endsWith(options, cb);\n    }\n  };\n};\n\n\n/**\n * generateAssociationFinders\n *\n * Generate Dynamic Finders for an association.\n * Adds a .findBy<name>() method for has_one and belongs_to associations.\n *\n * @param {String} attrName, the column name of the attribute\n */\n\nfinder.generateAssociationFinders = function(attrName) {\n  var self = this;\n  var name, model;\n\n  // Find the user defined key for this attrName, look in self defined columnName\n  // properties and if that's not set see if the generated columnName matches the attrName\n  for (var key in this._attributes) {\n\n    // Cache the value\n    var cache = this._attributes[key];\n\n    if (!hasOwnProperty(cache, 'model')) continue;\n\n    if (cache.model.toLowerCase() + '_id' === attrName) {\n      name = key;\n      model = cache.model;\n    }\n  }\n\n  if (!name || !model) return;\n\n  // Build a findOneBy<attrName> dynamic finder that forces a join on the association\n  this['findOneBy' + utils.capitalize(name)] = function dynamicAssociationMethod(value, cb) {\n\n    // Check proper usage\n    var usage = utils.capitalize(self.identity) + '.' + 'findBy' + utils.capitalize(name) +\n      '(someValue, callback)';\n\n    if (typeof value === 'undefined') return usageError('No value specified!', usage, cb);\n    if (typeof value === 'function') return usageError('No value specified!', usage, cb);\n\n    var criteria = associationQueryCriteria(self, value, attrName);\n    return this.findOne(criteria, cb);\n  };\n\n  // Build a findBy<attrName> dynamic finder that forces a join on the association\n  this['findBy' + utils.capitalize(name)] = function dynamicAssociationMethod(value, cb) {\n\n    // Check proper usage\n    var usage = utils.capitalize(self.identity) + '.' + 'findBy' + utils.capitalize(name) +\n      '(someValue, callback)';\n\n    if (typeof value === 'undefined') return usageError('No value specified!', usage, cb);\n    if (typeof value === 'function') return usageError('No value specified!', usage, cb);\n\n    var criteria = associationQueryCriteria(self, value, attrName);\n    return this.find(criteria, cb);\n  };\n};\n\n\n/**\n * Build Join Array\n */\n\nfunction buildJoin() {\n  var self = this;\n  var pk, attr;\n\n  // Set the attr value to the generated schema attribute\n  attr = self.waterline.schema[self.identity].attributes[name];\n\n  // Get the current collection's primary key attribute\n  Object.keys(self._attributes).forEach(function(key) {\n    if (hasOwnProperty(self._attributes[key], 'primaryKey') && self._attributes[key].primaryKey) {\n      pk = key;\n    }\n  });\n\n  if (!attr) throw new Error('Attempting to populate an attribute that doesn\\'t exist');\n\n  // Grab the key being populated to check if it is a has many to belongs to\n  // If it's a belongs_to the adapter needs to know that it should replace the foreign key\n  // with the associated value.\n  var parentKey = self.waterline.collections[self.identity].attributes[name];\n\n\n  // Build the initial join object that will link this collection to either another collection\n  // or to a junction table.\n  var join = {\n    parent: self._tableName,\n    parentKey: attr.columnName || pk,\n    child: attr.references,\n    childKey: attr.on,\n    select: true,\n    removeParentKey: !!parentKey.model\n  };\n\n  return join;\n}\n\n/**\n * Query Criteria Builder for associations\n */\n\nfunction associationQueryCriteria(context, value, attrName) {\n\n  // Build a criteria object\n  var criteria = {\n    where: {},\n    joins: []\n  };\n\n  // Build a join condition\n  var join = buildJoin.call(context);\n  criteria.joins.push(join);\n\n  // Add where values\n  criteria.where[attrName] = value;\n  return criteria;\n}\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/query/stream.js":"/**\n * Streaming Queries\n */\n\nvar usageError = require('../utils/usageError');\nvar utils = require('../utils/helpers');\nvar normalize = require('../utils/normalize');\nvar ModelStream = require('../utils/stream');\n\nmodule.exports = {\n\n  /**\n   * Stream a Result Set\n   *\n   * @param {Object} criteria\n   * @param {Object} transformation, defaults to JSON\n   */\n\n  stream: function(criteria, transformation) {\n    var self = this;\n\n    var usage = utils.capitalize(this.identity) + '.stream([criteria],[options])';\n\n    // Normalize criteria and fold in options\n    criteria = normalize.criteria(criteria);\n\n    // Transform Search Criteria\n    criteria = self._transformer.serialize(criteria);\n\n    // Configure stream to adapter, kick off fetch, and return stream object\n    // so that user code can use it as it fires data events\n    var stream = new ModelStream(transformation);\n\n    // very important to wait until next tick before triggering adapter\n    // otherwise write() and end() won't fire properly\n    process.nextTick(function() {\n\n      // Write once immediately to force prefix in case no models are returned\n      stream.write();\n\n      // Trigger Adapter Method\n      self.adapter.stream(criteria, stream);\n    });\n\n    return stream;\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/stream.js":"/**\n * Streams\n *\n * A Streaming API with support for Transformations\n */\n\nvar util = require('util');\nvar Stream = require('stream');\nvar Transformations = require('./transformations');\nvar _ = require('lodash');\n\nvar ModelStream = module.exports = function(transformation) {\n\n  // Use specified, or otherwise default, JSON transformation\n  this.transformation = transformation || Transformations.json;\n\n  // Reset write index\n  this.index = 0;\n\n  // Make stream writable\n  this.writable = true;\n};\n\nutil.inherits(ModelStream, Stream);\n\n/**\n * Write to stream\n *\n * Extracts args to write and emits them as data events\n *\n * @param {Object} model\n * @param {Function} cb\n */\n\nModelStream.prototype.write = function(model, cb) {\n  var self = this;\n\n  // Run transformation on this item\n  this.transformation.write(model, this.index, function writeToStream(err, transformedModel) {\n\n    // Increment index for next time\n    self.index++;\n\n    // Write transformed model to stream\n    self.emit('data', _.clone(transformedModel));\n\n    // Inform that we're finished\n    if (cb) return cb(err);\n  });\n\n};\n\n/**\n * End Stream\n */\n\nModelStream.prototype.end = function(err, cb) {\n  var self = this;\n\n  if (err) {\n    this.emit('error', err.message);\n    if (cb) return cb(err);\n    return;\n  }\n\n  this.transformation.end(function(err, suffix) {\n\n    if (err) {\n      self.emit('error', err);\n      if (cb) return cb(err);\n      return;\n    }\n\n    // Emit suffix if specified\n    if (suffix) self.emit('data', suffix);\n    self.emit('end');\n    if (cb) return cb();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-waterline/waterline/lib/waterline/utils/transformations.js":"/**\n * Transformations\n */\n\nvar Transformations = module.exports = {};\n\n// Add JSON Transformation methods\nTransformations.json = {};\n\n/**\n * Write Method Transformations\n *\n * Used to stream back valid JSON from Waterline\n */\n\nTransformations.json.write = function(model, index, cb) {\n  var transformedModel;\n\n  if (!model) transformedModel = '';\n\n  // Transform to JSON\n  if (model) {\n    try {\n      transformedModel = JSON.stringify(model);\n    } catch (e) {\n      return cb(e);\n    }\n  }\n\n  // Prefix with opening [\n  if (index === 0) { transformedModel = '['; }\n\n  // Prefix with comma after first model\n  if (index > 1) transformedModel = ',' + transformedModel;\n\n  cb(null, transformedModel);\n};\n\n/**\n * Close off JSON Array\n */\nTransformations.json.end = function(cb) {\n  var suffix = ']';\n  cb(null, suffix);\n};\n"}